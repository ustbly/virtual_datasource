// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: source/kh/KhContext.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_source_2fkh_2fKhContext_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_source_2fkh_2fKhContext_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dcts.pb.h"
#include "source/source.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_source_2fkh_2fKhContext_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_source_2fkh_2fKhContext_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_source_2fkh_2fKhContext_2eproto;
namespace zb {
namespace dcts {
namespace source {
namespace kh {
class DataSource;
class DataSourceDefaultTypeInternal;
extern DataSourceDefaultTypeInternal _DataSource_default_instance_;
class FreqTriggerParam;
class FreqTriggerParamDefaultTypeInternal;
extern FreqTriggerParamDefaultTypeInternal _FreqTriggerParam_default_instance_;
class GainControlParam;
class GainControlParamDefaultTypeInternal;
extern GainControlParamDefaultTypeInternal _GainControlParam_default_instance_;
class LevelTriggerParam;
class LevelTriggerParamDefaultTypeInternal;
extern LevelTriggerParamDefaultTypeInternal _LevelTriggerParam_default_instance_;
class OffLinePositionParam;
class OffLinePositionParamDefaultTypeInternal;
extern OffLinePositionParamDefaultTypeInternal _OffLinePositionParam_default_instance_;
class OnLinePositionParam;
class OnLinePositionParamDefaultTypeInternal;
extern OnLinePositionParamDefaultTypeInternal _OnLinePositionParam_default_instance_;
class OperationStatus;
class OperationStatusDefaultTypeInternal;
extern OperationStatusDefaultTypeInternal _OperationStatus_default_instance_;
class PositionDataSource;
class PositionDataSourceDefaultTypeInternal;
extern PositionDataSourceDefaultTypeInternal _PositionDataSource_default_instance_;
class PositionTargetDescriptor;
class PositionTargetDescriptorDefaultTypeInternal;
extern PositionTargetDescriptorDefaultTypeInternal _PositionTargetDescriptor_default_instance_;
class PulseCluster;
class PulseClusterDefaultTypeInternal;
extern PulseClusterDefaultTypeInternal _PulseCluster_default_instance_;
class PulseSample;
class PulseSampleDefaultTypeInternal;
extern PulseSampleDefaultTypeInternal _PulseSample_default_instance_;
class StartPositionRequest;
class StartPositionRequestDefaultTypeInternal;
extern StartPositionRequestDefaultTypeInternal _StartPositionRequest_default_instance_;
class StaticSelfTestResult;
class StaticSelfTestResultDefaultTypeInternal;
extern StaticSelfTestResultDefaultTypeInternal _StaticSelfTestResult_default_instance_;
class TargetDirection;
class TargetDirectionDefaultTypeInternal;
extern TargetDirectionDefaultTypeInternal _TargetDirection_default_instance_;
class TargetSpeed;
class TargetSpeedDefaultTypeInternal;
extern TargetSpeedDefaultTypeInternal _TargetSpeed_default_instance_;
class TimeTriggerParam;
class TimeTriggerParamDefaultTypeInternal;
extern TimeTriggerParamDefaultTypeInternal _TimeTriggerParam_default_instance_;
class WindowParams;
class WindowParamsDefaultTypeInternal;
extern WindowParamsDefaultTypeInternal _WindowParams_default_instance_;
}  // namespace kh
}  // namespace source
}  // namespace dcts
}  // namespace zb
PROTOBUF_NAMESPACE_OPEN
template<> ::zb::dcts::source::kh::DataSource* Arena::CreateMaybeMessage<::zb::dcts::source::kh::DataSource>(Arena*);
template<> ::zb::dcts::source::kh::FreqTriggerParam* Arena::CreateMaybeMessage<::zb::dcts::source::kh::FreqTriggerParam>(Arena*);
template<> ::zb::dcts::source::kh::GainControlParam* Arena::CreateMaybeMessage<::zb::dcts::source::kh::GainControlParam>(Arena*);
template<> ::zb::dcts::source::kh::LevelTriggerParam* Arena::CreateMaybeMessage<::zb::dcts::source::kh::LevelTriggerParam>(Arena*);
template<> ::zb::dcts::source::kh::OffLinePositionParam* Arena::CreateMaybeMessage<::zb::dcts::source::kh::OffLinePositionParam>(Arena*);
template<> ::zb::dcts::source::kh::OnLinePositionParam* Arena::CreateMaybeMessage<::zb::dcts::source::kh::OnLinePositionParam>(Arena*);
template<> ::zb::dcts::source::kh::OperationStatus* Arena::CreateMaybeMessage<::zb::dcts::source::kh::OperationStatus>(Arena*);
template<> ::zb::dcts::source::kh::PositionDataSource* Arena::CreateMaybeMessage<::zb::dcts::source::kh::PositionDataSource>(Arena*);
template<> ::zb::dcts::source::kh::PositionTargetDescriptor* Arena::CreateMaybeMessage<::zb::dcts::source::kh::PositionTargetDescriptor>(Arena*);
template<> ::zb::dcts::source::kh::PulseCluster* Arena::CreateMaybeMessage<::zb::dcts::source::kh::PulseCluster>(Arena*);
template<> ::zb::dcts::source::kh::PulseSample* Arena::CreateMaybeMessage<::zb::dcts::source::kh::PulseSample>(Arena*);
template<> ::zb::dcts::source::kh::StartPositionRequest* Arena::CreateMaybeMessage<::zb::dcts::source::kh::StartPositionRequest>(Arena*);
template<> ::zb::dcts::source::kh::StaticSelfTestResult* Arena::CreateMaybeMessage<::zb::dcts::source::kh::StaticSelfTestResult>(Arena*);
template<> ::zb::dcts::source::kh::TargetDirection* Arena::CreateMaybeMessage<::zb::dcts::source::kh::TargetDirection>(Arena*);
template<> ::zb::dcts::source::kh::TargetSpeed* Arena::CreateMaybeMessage<::zb::dcts::source::kh::TargetSpeed>(Arena*);
template<> ::zb::dcts::source::kh::TimeTriggerParam* Arena::CreateMaybeMessage<::zb::dcts::source::kh::TimeTriggerParam>(Arena*);
template<> ::zb::dcts::source::kh::WindowParams* Arena::CreateMaybeMessage<::zb::dcts::source::kh::WindowParams>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zb {
namespace dcts {
namespace source {
namespace kh {

enum TimeTriggerParam_TriggerType : int {
  TimeTriggerParam_TriggerType_NONE = 0,
  TimeTriggerParam_TriggerType_ABS_TIME = 2,
  TimeTriggerParam_TriggerType_REL_TIME = 4,
  TimeTriggerParam_TriggerType_TimeTriggerParam_TriggerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TimeTriggerParam_TriggerType_TimeTriggerParam_TriggerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TimeTriggerParam_TriggerType_IsValid(int value);
constexpr TimeTriggerParam_TriggerType TimeTriggerParam_TriggerType_TriggerType_MIN = TimeTriggerParam_TriggerType_NONE;
constexpr TimeTriggerParam_TriggerType TimeTriggerParam_TriggerType_TriggerType_MAX = TimeTriggerParam_TriggerType_REL_TIME;
constexpr int TimeTriggerParam_TriggerType_TriggerType_ARRAYSIZE = TimeTriggerParam_TriggerType_TriggerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeTriggerParam_TriggerType_descriptor();
template<typename T>
inline const std::string& TimeTriggerParam_TriggerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeTriggerParam_TriggerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeTriggerParam_TriggerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeTriggerParam_TriggerType_descriptor(), enum_t_value);
}
inline bool TimeTriggerParam_TriggerType_Parse(
    const std::string& name, TimeTriggerParam_TriggerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeTriggerParam_TriggerType>(
    TimeTriggerParam_TriggerType_descriptor(), name, value);
}
enum FreqTriggerParam_TriggerType : int {
  FreqTriggerParam_TriggerType_NONE = 0,
  FreqTriggerParam_TriggerType_FREQ = 8,
  FreqTriggerParam_TriggerType_FreqTriggerParam_TriggerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FreqTriggerParam_TriggerType_FreqTriggerParam_TriggerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FreqTriggerParam_TriggerType_IsValid(int value);
constexpr FreqTriggerParam_TriggerType FreqTriggerParam_TriggerType_TriggerType_MIN = FreqTriggerParam_TriggerType_NONE;
constexpr FreqTriggerParam_TriggerType FreqTriggerParam_TriggerType_TriggerType_MAX = FreqTriggerParam_TriggerType_FREQ;
constexpr int FreqTriggerParam_TriggerType_TriggerType_ARRAYSIZE = FreqTriggerParam_TriggerType_TriggerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FreqTriggerParam_TriggerType_descriptor();
template<typename T>
inline const std::string& FreqTriggerParam_TriggerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FreqTriggerParam_TriggerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FreqTriggerParam_TriggerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FreqTriggerParam_TriggerType_descriptor(), enum_t_value);
}
inline bool FreqTriggerParam_TriggerType_Parse(
    const std::string& name, FreqTriggerParam_TriggerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FreqTriggerParam_TriggerType>(
    FreqTriggerParam_TriggerType_descriptor(), name, value);
}
enum LevelTriggerParam_TriggerType : int {
  LevelTriggerParam_TriggerType_NONE = 0,
  LevelTriggerParam_TriggerType_LEVEL = 8,
  LevelTriggerParam_TriggerType_RISING = 16,
  LevelTriggerParam_TriggerType_FALLING = 24,
  LevelTriggerParam_TriggerType_LevelTriggerParam_TriggerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LevelTriggerParam_TriggerType_LevelTriggerParam_TriggerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LevelTriggerParam_TriggerType_IsValid(int value);
constexpr LevelTriggerParam_TriggerType LevelTriggerParam_TriggerType_TriggerType_MIN = LevelTriggerParam_TriggerType_NONE;
constexpr LevelTriggerParam_TriggerType LevelTriggerParam_TriggerType_TriggerType_MAX = LevelTriggerParam_TriggerType_FALLING;
constexpr int LevelTriggerParam_TriggerType_TriggerType_ARRAYSIZE = LevelTriggerParam_TriggerType_TriggerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LevelTriggerParam_TriggerType_descriptor();
template<typename T>
inline const std::string& LevelTriggerParam_TriggerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LevelTriggerParam_TriggerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LevelTriggerParam_TriggerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LevelTriggerParam_TriggerType_descriptor(), enum_t_value);
}
inline bool LevelTriggerParam_TriggerType_Parse(
    const std::string& name, LevelTriggerParam_TriggerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LevelTriggerParam_TriggerType>(
    LevelTriggerParam_TriggerType_descriptor(), name, value);
}
enum SourceControlCmd : int {
  SELT_TEST_STATIC = 0,
  SELT_TEST_DYNAMIC = 1,
  SourceControlCmd_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SourceControlCmd_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SourceControlCmd_IsValid(int value);
constexpr SourceControlCmd SourceControlCmd_MIN = SELT_TEST_STATIC;
constexpr SourceControlCmd SourceControlCmd_MAX = SELT_TEST_DYNAMIC;
constexpr int SourceControlCmd_ARRAYSIZE = SourceControlCmd_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SourceControlCmd_descriptor();
template<typename T>
inline const std::string& SourceControlCmd_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SourceControlCmd>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SourceControlCmd_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SourceControlCmd_descriptor(), enum_t_value);
}
inline bool SourceControlCmd_Parse(
    const std::string& name, SourceControlCmd* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SourceControlCmd>(
    SourceControlCmd_descriptor(), name, value);
}
enum DetectMode : int {
  MAXHOLD = 0,
  MINHOLD = 1,
  CURRENT = 2,
  AVERAGE = 3,
  DetectMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DetectMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DetectMode_IsValid(int value);
constexpr DetectMode DetectMode_MIN = MAXHOLD;
constexpr DetectMode DetectMode_MAX = AVERAGE;
constexpr int DetectMode_ARRAYSIZE = DetectMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DetectMode_descriptor();
template<typename T>
inline const std::string& DetectMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DetectMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DetectMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DetectMode_descriptor(), enum_t_value);
}
inline bool DetectMode_Parse(
    const std::string& name, DetectMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DetectMode>(
    DetectMode_descriptor(), name, value);
}
enum FFTDetectMode : int {
  POSITIVE = 0,
  NEGATIVE = 1,
  SAMPLED = 2,
  AVERAGEF = 3,
  FFTDetectMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FFTDetectMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FFTDetectMode_IsValid(int value);
constexpr FFTDetectMode FFTDetectMode_MIN = POSITIVE;
constexpr FFTDetectMode FFTDetectMode_MAX = AVERAGEF;
constexpr int FFTDetectMode_ARRAYSIZE = FFTDetectMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FFTDetectMode_descriptor();
template<typename T>
inline const std::string& FFTDetectMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FFTDetectMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FFTDetectMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FFTDetectMode_descriptor(), enum_t_value);
}
inline bool FFTDetectMode_Parse(
    const std::string& name, FFTDetectMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FFTDetectMode>(
    FFTDetectMode_descriptor(), name, value);
}
enum ChannelMode : int {
  NORMAL = 0,
  LOWNOISE = 1,
  LOWDISTORT = 2,
  ChannelMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ChannelMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ChannelMode_IsValid(int value);
constexpr ChannelMode ChannelMode_MIN = NORMAL;
constexpr ChannelMode ChannelMode_MAX = LOWDISTORT;
constexpr int ChannelMode_ARRAYSIZE = ChannelMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelMode_descriptor();
template<typename T>
inline const std::string& ChannelMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelMode_descriptor(), enum_t_value);
}
inline bool ChannelMode_Parse(
    const std::string& name, ChannelMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelMode>(
    ChannelMode_descriptor(), name, value);
}
enum WindowType : int {
  HANNING = 0,
  HAMMING = 1,
  RECTWIN = 2,
  FLATTOP = 3,
  GAUSS = 4,
  BLACKHARRIS = 5,
  WindowType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WindowType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WindowType_IsValid(int value);
constexpr WindowType WindowType_MIN = HANNING;
constexpr WindowType WindowType_MAX = BLACKHARRIS;
constexpr int WindowType_ARRAYSIZE = WindowType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WindowType_descriptor();
template<typename T>
inline const std::string& WindowType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WindowType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WindowType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WindowType_descriptor(), enum_t_value);
}
inline bool WindowType_Parse(
    const std::string& name, WindowType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WindowType>(
    WindowType_descriptor(), name, value);
}
enum AntennaControlMode : int {
  ANT_INVALID = 0,
  ANT_THROUGH = 1,
  ANT_1_AMPLIFY = 2,
  ANT_2_AMPLIFY = 3,
  ANT_1_2_AMPLIFY = 4,
  AntennaControlMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AntennaControlMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AntennaControlMode_IsValid(int value);
constexpr AntennaControlMode AntennaControlMode_MIN = ANT_INVALID;
constexpr AntennaControlMode AntennaControlMode_MAX = ANT_1_2_AMPLIFY;
constexpr int AntennaControlMode_ARRAYSIZE = AntennaControlMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AntennaControlMode_descriptor();
template<typename T>
inline const std::string& AntennaControlMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AntennaControlMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AntennaControlMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AntennaControlMode_descriptor(), enum_t_value);
}
inline bool AntennaControlMode_Parse(
    const std::string& name, AntennaControlMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AntennaControlMode>(
    AntennaControlMode_descriptor(), name, value);
}
enum GainControlMode : int {
  AGC = 0,
  MGC = 1,
  GainControlMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GainControlMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GainControlMode_IsValid(int value);
constexpr GainControlMode GainControlMode_MIN = AGC;
constexpr GainControlMode GainControlMode_MAX = MGC;
constexpr int GainControlMode_ARRAYSIZE = GainControlMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GainControlMode_descriptor();
template<typename T>
inline const std::string& GainControlMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GainControlMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GainControlMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GainControlMode_descriptor(), enum_t_value);
}
inline bool GainControlMode_Parse(
    const std::string& name, GainControlMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GainControlMode>(
    GainControlMode_descriptor(), name, value);
}
enum ThresholdMode : int {
  AUTO = 0,
  MANUAL = 1,
  ThresholdMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ThresholdMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ThresholdMode_IsValid(int value);
constexpr ThresholdMode ThresholdMode_MIN = AUTO;
constexpr ThresholdMode ThresholdMode_MAX = MANUAL;
constexpr int ThresholdMode_ARRAYSIZE = ThresholdMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThresholdMode_descriptor();
template<typename T>
inline const std::string& ThresholdMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThresholdMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThresholdMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ThresholdMode_descriptor(), enum_t_value);
}
inline bool ThresholdMode_Parse(
    const std::string& name, ThresholdMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ThresholdMode>(
    ThresholdMode_descriptor(), name, value);
}
enum DataType : int {
  cplx_16 = 0,
  cplx_32 = 1,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = cplx_16;
constexpr DataType DataType_MAX = cplx_32;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    const std::string& name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum LinkType : int {
  UNKNOWN = 0,
  LINK11 = 1,
  LINK16 = 2,
  LINK4A = 3,
  LinkType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LinkType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LinkType_IsValid(int value);
constexpr LinkType LinkType_MIN = UNKNOWN;
constexpr LinkType LinkType_MAX = LINK4A;
constexpr int LinkType_ARRAYSIZE = LinkType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LinkType_descriptor();
template<typename T>
inline const std::string& LinkType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LinkType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LinkType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LinkType_descriptor(), enum_t_value);
}
inline bool LinkType_Parse(
    const std::string& name, LinkType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LinkType>(
    LinkType_descriptor(), name, value);
}
// ===================================================================

class StaticSelfTestResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.StaticSelfTestResult) */ {
 public:
  inline StaticSelfTestResult() : StaticSelfTestResult(nullptr) {};
  virtual ~StaticSelfTestResult();

  StaticSelfTestResult(const StaticSelfTestResult& from);
  StaticSelfTestResult(StaticSelfTestResult&& from) noexcept
    : StaticSelfTestResult() {
    *this = ::std::move(from);
  }

  inline StaticSelfTestResult& operator=(const StaticSelfTestResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline StaticSelfTestResult& operator=(StaticSelfTestResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StaticSelfTestResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StaticSelfTestResult* internal_default_instance() {
    return reinterpret_cast<const StaticSelfTestResult*>(
               &_StaticSelfTestResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StaticSelfTestResult& a, StaticSelfTestResult& b) {
    a.Swap(&b);
  }
  inline void Swap(StaticSelfTestResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StaticSelfTestResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StaticSelfTestResult* New() const final {
    return CreateMaybeMessage<StaticSelfTestResult>(nullptr);
  }

  StaticSelfTestResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StaticSelfTestResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StaticSelfTestResult& from);
  void MergeFrom(const StaticSelfTestResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticSelfTestResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.StaticSelfTestResult";
  }
  protected:
  explicit StaticSelfTestResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kSourceIdFieldNumber = 1,
  };
  // string status = 2;
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_status();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_status(
      std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // .zb.dcts.source.SourceId source_id = 1;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::zb::dcts::source::SourceId& source_id() const;
  ::zb::dcts::source::SourceId* release_source_id();
  ::zb::dcts::source::SourceId* mutable_source_id();
  void set_allocated_source_id(::zb::dcts::source::SourceId* source_id);
  private:
  const ::zb::dcts::source::SourceId& _internal_source_id() const;
  ::zb::dcts::source::SourceId* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::zb::dcts::source::SourceId* source_id);
  ::zb::dcts::source::SourceId* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.StaticSelfTestResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::zb::dcts::source::SourceId* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class WindowParams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.WindowParams) */ {
 public:
  inline WindowParams() : WindowParams(nullptr) {};
  virtual ~WindowParams();

  WindowParams(const WindowParams& from);
  WindowParams(WindowParams&& from) noexcept
    : WindowParams() {
    *this = ::std::move(from);
  }

  inline WindowParams& operator=(const WindowParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowParams& operator=(WindowParams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WindowParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WindowParams* internal_default_instance() {
    return reinterpret_cast<const WindowParams*>(
               &_WindowParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WindowParams& a, WindowParams& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowParams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WindowParams* New() const final {
    return CreateMaybeMessage<WindowParams>(nullptr);
  }

  WindowParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WindowParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WindowParams& from);
  void MergeFrom(const WindowParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.WindowParams";
  }
  protected:
  explicit WindowParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // double param = 2;
  void clear_param();
  double param() const;
  void set_param(double value);
  private:
  double _internal_param() const;
  void _internal_set_param(double value);
  public:

  // .zb.dcts.source.kh.WindowType type = 1;
  void clear_type();
  ::zb::dcts::source::kh::WindowType type() const;
  void set_type(::zb::dcts::source::kh::WindowType value);
  private:
  ::zb::dcts::source::kh::WindowType _internal_type() const;
  void _internal_set_type(::zb::dcts::source::kh::WindowType value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.WindowParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double param_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class GainControlParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.GainControlParam) */ {
 public:
  inline GainControlParam() : GainControlParam(nullptr) {};
  virtual ~GainControlParam();

  GainControlParam(const GainControlParam& from);
  GainControlParam(GainControlParam&& from) noexcept
    : GainControlParam() {
    *this = ::std::move(from);
  }

  inline GainControlParam& operator=(const GainControlParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline GainControlParam& operator=(GainControlParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GainControlParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GainControlParam* internal_default_instance() {
    return reinterpret_cast<const GainControlParam*>(
               &_GainControlParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GainControlParam& a, GainControlParam& b) {
    a.Swap(&b);
  }
  inline void Swap(GainControlParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GainControlParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GainControlParam* New() const final {
    return CreateMaybeMessage<GainControlParam>(nullptr);
  }

  GainControlParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GainControlParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GainControlParam& from);
  void MergeFrom(const GainControlParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GainControlParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.GainControlParam";
  }
  protected:
  explicit GainControlParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHoldTimeFieldNumber = 1,
    kIncFieldNumber = 2,
  };
  // float hold_time = 1;
  void clear_hold_time();
  float hold_time() const;
  void set_hold_time(float value);
  private:
  float _internal_hold_time() const;
  void _internal_set_hold_time(float value);
  public:

  // float inc = 2;
  void clear_inc();
  float inc() const;
  void set_inc(float value);
  private:
  float _internal_inc() const;
  void _internal_set_inc(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.GainControlParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float hold_time_;
  float inc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class OperationStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.OperationStatus) */ {
 public:
  inline OperationStatus() : OperationStatus(nullptr) {};
  virtual ~OperationStatus();

  OperationStatus(const OperationStatus& from);
  OperationStatus(OperationStatus&& from) noexcept
    : OperationStatus() {
    *this = ::std::move(from);
  }

  inline OperationStatus& operator=(const OperationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationStatus& operator=(OperationStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OperationStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationStatus* internal_default_instance() {
    return reinterpret_cast<const OperationStatus*>(
               &_OperationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OperationStatus& a, OperationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OperationStatus* New() const final {
    return CreateMaybeMessage<OperationStatus>(nullptr);
  }

  OperationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OperationStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OperationStatus& from);
  void MergeFrom(const OperationStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.OperationStatus";
  }
  protected:
  explicit OperationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeSpanFieldNumber = 1,
    kTotalSweepCountFieldNumber = 2,
    kRecordCountFieldNumber = 3,
  };
  // .zb.dcts.TimeSpan time_span = 1;
  bool has_time_span() const;
  private:
  bool _internal_has_time_span() const;
  public:
  void clear_time_span();
  const ::zb::dcts::TimeSpan& time_span() const;
  ::zb::dcts::TimeSpan* release_time_span();
  ::zb::dcts::TimeSpan* mutable_time_span();
  void set_allocated_time_span(::zb::dcts::TimeSpan* time_span);
  private:
  const ::zb::dcts::TimeSpan& _internal_time_span() const;
  ::zb::dcts::TimeSpan* _internal_mutable_time_span();
  public:
  void unsafe_arena_set_allocated_time_span(
      ::zb::dcts::TimeSpan* time_span);
  ::zb::dcts::TimeSpan* unsafe_arena_release_time_span();

  // uint64 total_sweep_count = 2;
  void clear_total_sweep_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 total_sweep_count() const;
  void set_total_sweep_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_total_sweep_count() const;
  void _internal_set_total_sweep_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 record_count = 3;
  void clear_record_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 record_count() const;
  void set_record_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_record_count() const;
  void _internal_set_record_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.OperationStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::TimeSpan* time_span_;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_sweep_count_;
  ::PROTOBUF_NAMESPACE_ID::uint64 record_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class TargetDirection PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.TargetDirection) */ {
 public:
  inline TargetDirection() : TargetDirection(nullptr) {};
  virtual ~TargetDirection();

  TargetDirection(const TargetDirection& from);
  TargetDirection(TargetDirection&& from) noexcept
    : TargetDirection() {
    *this = ::std::move(from);
  }

  inline TargetDirection& operator=(const TargetDirection& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetDirection& operator=(TargetDirection&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TargetDirection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TargetDirection* internal_default_instance() {
    return reinterpret_cast<const TargetDirection*>(
               &_TargetDirection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TargetDirection& a, TargetDirection& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetDirection* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetDirection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TargetDirection* New() const final {
    return CreateMaybeMessage<TargetDirection>(nullptr);
  }

  TargetDirection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TargetDirection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TargetDirection& from);
  void MergeFrom(const TargetDirection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetDirection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.TargetDirection";
  }
  protected:
  explicit TargetDirection(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeStampFieldNumber = 5,
    kCenterFrequencyFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kConfidenceFieldNumber = 3,
    kAmplitudeFieldNumber = 4,
    kPitchAngleFieldNumber = 6,
  };
  // .zb.dcts.Timestamp time_stamp = 5;
  bool has_time_stamp() const;
  private:
  bool _internal_has_time_stamp() const;
  public:
  void clear_time_stamp();
  const ::zb::dcts::Timestamp& time_stamp() const;
  ::zb::dcts::Timestamp* release_time_stamp();
  ::zb::dcts::Timestamp* mutable_time_stamp();
  void set_allocated_time_stamp(::zb::dcts::Timestamp* time_stamp);
  private:
  const ::zb::dcts::Timestamp& _internal_time_stamp() const;
  ::zb::dcts::Timestamp* _internal_mutable_time_stamp();
  public:
  void unsafe_arena_set_allocated_time_stamp(
      ::zb::dcts::Timestamp* time_stamp);
  ::zb::dcts::Timestamp* unsafe_arena_release_time_stamp();

  // double center_frequency = 1;
  void clear_center_frequency();
  double center_frequency() const;
  void set_center_frequency(double value);
  private:
  double _internal_center_frequency() const;
  void _internal_set_center_frequency(double value);
  public:

  // double direction = 2;
  void clear_direction();
  double direction() const;
  void set_direction(double value);
  private:
  double _internal_direction() const;
  void _internal_set_direction(double value);
  public:

  // int32 confidence = 3;
  void clear_confidence();
  ::PROTOBUF_NAMESPACE_ID::int32 confidence() const;
  void set_confidence(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_confidence() const;
  void _internal_set_confidence(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float amplitude = 4;
  void clear_amplitude();
  float amplitude() const;
  void set_amplitude(float value);
  private:
  float _internal_amplitude() const;
  void _internal_set_amplitude(float value);
  public:

  // double pitch_angle = 6;
  void clear_pitch_angle();
  double pitch_angle() const;
  void set_pitch_angle(double value);
  private:
  double _internal_pitch_angle() const;
  void _internal_set_pitch_angle(double value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.TargetDirection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::Timestamp* time_stamp_;
  double center_frequency_;
  double direction_;
  ::PROTOBUF_NAMESPACE_ID::int32 confidence_;
  float amplitude_;
  double pitch_angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class PulseSample PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.PulseSample) */ {
 public:
  inline PulseSample() : PulseSample(nullptr) {};
  virtual ~PulseSample();

  PulseSample(const PulseSample& from);
  PulseSample(PulseSample&& from) noexcept
    : PulseSample() {
    *this = ::std::move(from);
  }

  inline PulseSample& operator=(const PulseSample& from) {
    CopyFrom(from);
    return *this;
  }
  inline PulseSample& operator=(PulseSample&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PulseSample& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PulseSample* internal_default_instance() {
    return reinterpret_cast<const PulseSample*>(
               &_PulseSample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PulseSample& a, PulseSample& b) {
    a.Swap(&b);
  }
  inline void Swap(PulseSample* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PulseSample* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PulseSample* New() const final {
    return CreateMaybeMessage<PulseSample>(nullptr);
  }

  PulseSample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PulseSample>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PulseSample& from);
  void MergeFrom(const PulseSample& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PulseSample* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.PulseSample";
  }
  protected:
  explicit PulseSample(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCarrierFreqFieldNumber = 1,
    kPulseWidthFieldNumber = 2,
    kRepeatPeriodFieldNumber = 3,
    kRepeatPeriodTypeFieldNumber = 4,
    kFreqTypeFieldNumber = 5,
    kPwTypeFieldNumber = 6,
  };
  // double carrier_freq = 1;
  void clear_carrier_freq();
  double carrier_freq() const;
  void set_carrier_freq(double value);
  private:
  double _internal_carrier_freq() const;
  void _internal_set_carrier_freq(double value);
  public:

  // float pulse_width = 2;
  void clear_pulse_width();
  float pulse_width() const;
  void set_pulse_width(float value);
  private:
  float _internal_pulse_width() const;
  void _internal_set_pulse_width(float value);
  public:

  // float repeat_period = 3;
  void clear_repeat_period();
  float repeat_period() const;
  void set_repeat_period(float value);
  private:
  float _internal_repeat_period() const;
  void _internal_set_repeat_period(float value);
  public:

  // uint32 repeat_period_type = 4;
  void clear_repeat_period_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 repeat_period_type() const;
  void set_repeat_period_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_repeat_period_type() const;
  void _internal_set_repeat_period_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 freq_type = 5;
  void clear_freq_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 freq_type() const;
  void set_freq_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_freq_type() const;
  void _internal_set_freq_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 pw_type = 6;
  void clear_pw_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 pw_type() const;
  void set_pw_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pw_type() const;
  void _internal_set_pw_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.PulseSample)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double carrier_freq_;
  float pulse_width_;
  float repeat_period_;
  ::PROTOBUF_NAMESPACE_ID::uint32 repeat_period_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 freq_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pw_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class PulseCluster PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.PulseCluster) */ {
 public:
  inline PulseCluster() : PulseCluster(nullptr) {};
  virtual ~PulseCluster();

  PulseCluster(const PulseCluster& from);
  PulseCluster(PulseCluster&& from) noexcept
    : PulseCluster() {
    *this = ::std::move(from);
  }

  inline PulseCluster& operator=(const PulseCluster& from) {
    CopyFrom(from);
    return *this;
  }
  inline PulseCluster& operator=(PulseCluster&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PulseCluster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PulseCluster* internal_default_instance() {
    return reinterpret_cast<const PulseCluster*>(
               &_PulseCluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PulseCluster& a, PulseCluster& b) {
    a.Swap(&b);
  }
  inline void Swap(PulseCluster* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PulseCluster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PulseCluster* New() const final {
    return CreateMaybeMessage<PulseCluster>(nullptr);
  }

  PulseCluster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PulseCluster>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PulseCluster& from);
  void MergeFrom(const PulseCluster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PulseCluster* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.PulseCluster";
  }
  protected:
  explicit PulseCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPulseSamplesFieldNumber = 5,
    kAmptFieldNumber = 4,
    kTimeSpanFieldNumber = 6,
    kFreqFieldNumber = 1,
    kBwFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // repeated .zb.dcts.source.kh.PulseSample pulse_samples = 5;
  int pulse_samples_size() const;
  private:
  int _internal_pulse_samples_size() const;
  public:
  void clear_pulse_samples();
  ::zb::dcts::source::kh::PulseSample* mutable_pulse_samples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::PulseSample >*
      mutable_pulse_samples();
  private:
  const ::zb::dcts::source::kh::PulseSample& _internal_pulse_samples(int index) const;
  ::zb::dcts::source::kh::PulseSample* _internal_add_pulse_samples();
  public:
  const ::zb::dcts::source::kh::PulseSample& pulse_samples(int index) const;
  ::zb::dcts::source::kh::PulseSample* add_pulse_samples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::PulseSample >&
      pulse_samples() const;

  // .zb.dcts.StatisticVal ampt = 4;
  bool has_ampt() const;
  private:
  bool _internal_has_ampt() const;
  public:
  void clear_ampt();
  const ::zb::dcts::StatisticVal& ampt() const;
  ::zb::dcts::StatisticVal* release_ampt();
  ::zb::dcts::StatisticVal* mutable_ampt();
  void set_allocated_ampt(::zb::dcts::StatisticVal* ampt);
  private:
  const ::zb::dcts::StatisticVal& _internal_ampt() const;
  ::zb::dcts::StatisticVal* _internal_mutable_ampt();
  public:
  void unsafe_arena_set_allocated_ampt(
      ::zb::dcts::StatisticVal* ampt);
  ::zb::dcts::StatisticVal* unsafe_arena_release_ampt();

  // .zb.dcts.TimeSpan time_span = 6;
  bool has_time_span() const;
  private:
  bool _internal_has_time_span() const;
  public:
  void clear_time_span();
  const ::zb::dcts::TimeSpan& time_span() const;
  ::zb::dcts::TimeSpan* release_time_span();
  ::zb::dcts::TimeSpan* mutable_time_span();
  void set_allocated_time_span(::zb::dcts::TimeSpan* time_span);
  private:
  const ::zb::dcts::TimeSpan& _internal_time_span() const;
  ::zb::dcts::TimeSpan* _internal_mutable_time_span();
  public:
  void unsafe_arena_set_allocated_time_span(
      ::zb::dcts::TimeSpan* time_span);
  ::zb::dcts::TimeSpan* unsafe_arena_release_time_span();

  // float freq = 1;
  void clear_freq();
  float freq() const;
  void set_freq(float value);
  private:
  float _internal_freq() const;
  void _internal_set_freq(float value);
  public:

  // float bw = 2;
  void clear_bw();
  float bw() const;
  void set_bw(float value);
  private:
  float _internal_bw() const;
  void _internal_set_bw(float value);
  public:

  // uint32 type = 3;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.PulseCluster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::PulseSample > pulse_samples_;
  ::zb::dcts::StatisticVal* ampt_;
  ::zb::dcts::TimeSpan* time_span_;
  float freq_;
  float bw_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class DataSource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.DataSource) */ {
 public:
  inline DataSource() : DataSource(nullptr) {};
  virtual ~DataSource();

  DataSource(const DataSource& from);
  DataSource(DataSource&& from) noexcept
    : DataSource() {
    *this = ::std::move(from);
  }

  inline DataSource& operator=(const DataSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataSource& operator=(DataSource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataSource* internal_default_instance() {
    return reinterpret_cast<const DataSource*>(
               &_DataSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DataSource& a, DataSource& b) {
    a.Swap(&b);
  }
  inline void Swap(DataSource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataSource* New() const final {
    return CreateMaybeMessage<DataSource>(nullptr);
  }

  DataSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataSource& from);
  void MergeFrom(const DataSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.DataSource";
  }
  protected:
  explicit DataSource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 2,
    kPositionFieldNumber = 3,
    kTaskIdFieldNumber = 1,
  };
  // .zb.dcts.source.SourceId source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::zb::dcts::source::SourceId& source_id() const;
  ::zb::dcts::source::SourceId* release_source_id();
  ::zb::dcts::source::SourceId* mutable_source_id();
  void set_allocated_source_id(::zb::dcts::source::SourceId* source_id);
  private:
  const ::zb::dcts::source::SourceId& _internal_source_id() const;
  ::zb::dcts::source::SourceId* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::zb::dcts::source::SourceId* source_id);
  ::zb::dcts::source::SourceId* unsafe_arena_release_source_id();

  // .zb.dcts.Position position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::zb::dcts::Position& position() const;
  ::zb::dcts::Position* release_position();
  ::zb::dcts::Position* mutable_position();
  void set_allocated_position(::zb::dcts::Position* position);
  private:
  const ::zb::dcts::Position& _internal_position() const;
  ::zb::dcts::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::zb::dcts::Position* position);
  ::zb::dcts::Position* unsafe_arena_release_position();

  // uint32 task_id = 1;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.DataSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::source::SourceId* source_id_;
  ::zb::dcts::Position* position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 task_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class PositionDataSource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.PositionDataSource) */ {
 public:
  inline PositionDataSource() : PositionDataSource(nullptr) {};
  virtual ~PositionDataSource();

  PositionDataSource(const PositionDataSource& from);
  PositionDataSource(PositionDataSource&& from) noexcept
    : PositionDataSource() {
    *this = ::std::move(from);
  }

  inline PositionDataSource& operator=(const PositionDataSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionDataSource& operator=(PositionDataSource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PositionDataSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionDataSource* internal_default_instance() {
    return reinterpret_cast<const PositionDataSource*>(
               &_PositionDataSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PositionDataSource& a, PositionDataSource& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionDataSource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionDataSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PositionDataSource* New() const final {
    return CreateMaybeMessage<PositionDataSource>(nullptr);
  }

  PositionDataSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PositionDataSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PositionDataSource& from);
  void MergeFrom(const PositionDataSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionDataSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.PositionDataSource";
  }
  protected:
  explicit PositionDataSource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskRunnerFieldNumber = 2,
    kTaskIdFieldNumber = 1,
  };
  // repeated .zb.dcts.source.SourceId task_runner = 2;
  int task_runner_size() const;
  private:
  int _internal_task_runner_size() const;
  public:
  void clear_task_runner();
  ::zb::dcts::source::SourceId* mutable_task_runner(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::SourceId >*
      mutable_task_runner();
  private:
  const ::zb::dcts::source::SourceId& _internal_task_runner(int index) const;
  ::zb::dcts::source::SourceId* _internal_add_task_runner();
  public:
  const ::zb::dcts::source::SourceId& task_runner(int index) const;
  ::zb::dcts::source::SourceId* add_task_runner();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::SourceId >&
      task_runner() const;

  // uint32 task_id = 1;
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.PositionDataSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::SourceId > task_runner_;
  ::PROTOBUF_NAMESPACE_ID::uint32 task_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class OnLinePositionParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.OnLinePositionParam) */ {
 public:
  inline OnLinePositionParam() : OnLinePositionParam(nullptr) {};
  virtual ~OnLinePositionParam();

  OnLinePositionParam(const OnLinePositionParam& from);
  OnLinePositionParam(OnLinePositionParam&& from) noexcept
    : OnLinePositionParam() {
    *this = ::std::move(from);
  }

  inline OnLinePositionParam& operator=(const OnLinePositionParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnLinePositionParam& operator=(OnLinePositionParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OnLinePositionParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnLinePositionParam* internal_default_instance() {
    return reinterpret_cast<const OnLinePositionParam*>(
               &_OnLinePositionParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OnLinePositionParam& a, OnLinePositionParam& b) {
    a.Swap(&b);
  }
  inline void Swap(OnLinePositionParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnLinePositionParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OnLinePositionParam* New() const final {
    return CreateMaybeMessage<OnLinePositionParam>(nullptr);
  }

  OnLinePositionParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OnLinePositionParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OnLinePositionParam& from);
  void MergeFrom(const OnLinePositionParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnLinePositionParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.OnLinePositionParam";
  }
  protected:
  explicit OnLinePositionParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataSourceFieldNumber = 1,
  };
  // .zb.dcts.source.kh.PositionDataSource data_source = 1;
  bool has_data_source() const;
  private:
  bool _internal_has_data_source() const;
  public:
  void clear_data_source();
  const ::zb::dcts::source::kh::PositionDataSource& data_source() const;
  ::zb::dcts::source::kh::PositionDataSource* release_data_source();
  ::zb::dcts::source::kh::PositionDataSource* mutable_data_source();
  void set_allocated_data_source(::zb::dcts::source::kh::PositionDataSource* data_source);
  private:
  const ::zb::dcts::source::kh::PositionDataSource& _internal_data_source() const;
  ::zb::dcts::source::kh::PositionDataSource* _internal_mutable_data_source();
  public:
  void unsafe_arena_set_allocated_data_source(
      ::zb::dcts::source::kh::PositionDataSource* data_source);
  ::zb::dcts::source::kh::PositionDataSource* unsafe_arena_release_data_source();

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.OnLinePositionParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::source::kh::PositionDataSource* data_source_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class OffLinePositionParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.OffLinePositionParam) */ {
 public:
  inline OffLinePositionParam() : OffLinePositionParam(nullptr) {};
  virtual ~OffLinePositionParam();

  OffLinePositionParam(const OffLinePositionParam& from);
  OffLinePositionParam(OffLinePositionParam&& from) noexcept
    : OffLinePositionParam() {
    *this = ::std::move(from);
  }

  inline OffLinePositionParam& operator=(const OffLinePositionParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline OffLinePositionParam& operator=(OffLinePositionParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OffLinePositionParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OffLinePositionParam* internal_default_instance() {
    return reinterpret_cast<const OffLinePositionParam*>(
               &_OffLinePositionParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OffLinePositionParam& a, OffLinePositionParam& b) {
    a.Swap(&b);
  }
  inline void Swap(OffLinePositionParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OffLinePositionParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OffLinePositionParam* New() const final {
    return CreateMaybeMessage<OffLinePositionParam>(nullptr);
  }

  OffLinePositionParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OffLinePositionParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OffLinePositionParam& from);
  void MergeFrom(const OffLinePositionParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OffLinePositionParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.OffLinePositionParam";
  }
  protected:
  explicit OffLinePositionParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataSourceFieldNumber = 1,
  };
  // repeated .zb.dcts.source.kh.PositionDataSource data_source = 1;
  int data_source_size() const;
  private:
  int _internal_data_source_size() const;
  public:
  void clear_data_source();
  ::zb::dcts::source::kh::PositionDataSource* mutable_data_source(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::PositionDataSource >*
      mutable_data_source();
  private:
  const ::zb::dcts::source::kh::PositionDataSource& _internal_data_source(int index) const;
  ::zb::dcts::source::kh::PositionDataSource* _internal_add_data_source();
  public:
  const ::zb::dcts::source::kh::PositionDataSource& data_source(int index) const;
  ::zb::dcts::source::kh::PositionDataSource* add_data_source();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::PositionDataSource >&
      data_source() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.OffLinePositionParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::PositionDataSource > data_source_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class StartPositionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.StartPositionRequest) */ {
 public:
  inline StartPositionRequest() : StartPositionRequest(nullptr) {};
  virtual ~StartPositionRequest();

  StartPositionRequest(const StartPositionRequest& from);
  StartPositionRequest(StartPositionRequest&& from) noexcept
    : StartPositionRequest() {
    *this = ::std::move(from);
  }

  inline StartPositionRequest& operator=(const StartPositionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartPositionRequest& operator=(StartPositionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartPositionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartPositionRequest* internal_default_instance() {
    return reinterpret_cast<const StartPositionRequest*>(
               &_StartPositionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StartPositionRequest& a, StartPositionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartPositionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartPositionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartPositionRequest* New() const final {
    return CreateMaybeMessage<StartPositionRequest>(nullptr);
  }

  StartPositionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartPositionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartPositionRequest& from);
  void MergeFrom(const StartPositionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartPositionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.StartPositionRequest";
  }
  protected:
  explicit StartPositionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskDescribeFieldNumber = 3,
    kOnlineParamFieldNumber = 1,
    kOfflineParamFieldNumber = 2,
    kPosFreqFieldNumber = 4,
  };
  // string task_describe = 3;
  void clear_task_describe();
  const std::string& task_describe() const;
  void set_task_describe(const std::string& value);
  void set_task_describe(std::string&& value);
  void set_task_describe(const char* value);
  void set_task_describe(const char* value, size_t size);
  std::string* mutable_task_describe();
  std::string* release_task_describe();
  void set_allocated_task_describe(std::string* task_describe);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_task_describe();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_task_describe(
      std::string* task_describe);
  private:
  const std::string& _internal_task_describe() const;
  void _internal_set_task_describe(const std::string& value);
  std::string* _internal_mutable_task_describe();
  public:

  // .zb.dcts.source.kh.OnLinePositionParam online_param = 1;
  bool has_online_param() const;
  private:
  bool _internal_has_online_param() const;
  public:
  void clear_online_param();
  const ::zb::dcts::source::kh::OnLinePositionParam& online_param() const;
  ::zb::dcts::source::kh::OnLinePositionParam* release_online_param();
  ::zb::dcts::source::kh::OnLinePositionParam* mutable_online_param();
  void set_allocated_online_param(::zb::dcts::source::kh::OnLinePositionParam* online_param);
  private:
  const ::zb::dcts::source::kh::OnLinePositionParam& _internal_online_param() const;
  ::zb::dcts::source::kh::OnLinePositionParam* _internal_mutable_online_param();
  public:
  void unsafe_arena_set_allocated_online_param(
      ::zb::dcts::source::kh::OnLinePositionParam* online_param);
  ::zb::dcts::source::kh::OnLinePositionParam* unsafe_arena_release_online_param();

  // .zb.dcts.source.kh.OffLinePositionParam offline_param = 2;
  bool has_offline_param() const;
  private:
  bool _internal_has_offline_param() const;
  public:
  void clear_offline_param();
  const ::zb::dcts::source::kh::OffLinePositionParam& offline_param() const;
  ::zb::dcts::source::kh::OffLinePositionParam* release_offline_param();
  ::zb::dcts::source::kh::OffLinePositionParam* mutable_offline_param();
  void set_allocated_offline_param(::zb::dcts::source::kh::OffLinePositionParam* offline_param);
  private:
  const ::zb::dcts::source::kh::OffLinePositionParam& _internal_offline_param() const;
  ::zb::dcts::source::kh::OffLinePositionParam* _internal_mutable_offline_param();
  public:
  void unsafe_arena_set_allocated_offline_param(
      ::zb::dcts::source::kh::OffLinePositionParam* offline_param);
  ::zb::dcts::source::kh::OffLinePositionParam* unsafe_arena_release_offline_param();

  // double pos_freq = 4;
  void clear_pos_freq();
  double pos_freq() const;
  void set_pos_freq(double value);
  private:
  double _internal_pos_freq() const;
  void _internal_set_pos_freq(double value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.StartPositionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_describe_;
  ::zb::dcts::source::kh::OnLinePositionParam* online_param_;
  ::zb::dcts::source::kh::OffLinePositionParam* offline_param_;
  double pos_freq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class TargetSpeed PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.TargetSpeed) */ {
 public:
  inline TargetSpeed() : TargetSpeed(nullptr) {};
  virtual ~TargetSpeed();

  TargetSpeed(const TargetSpeed& from);
  TargetSpeed(TargetSpeed&& from) noexcept
    : TargetSpeed() {
    *this = ::std::move(from);
  }

  inline TargetSpeed& operator=(const TargetSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetSpeed& operator=(TargetSpeed&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TargetSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TargetSpeed* internal_default_instance() {
    return reinterpret_cast<const TargetSpeed*>(
               &_TargetSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TargetSpeed& a, TargetSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetSpeed* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetSpeed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TargetSpeed* New() const final {
    return CreateMaybeMessage<TargetSpeed>(nullptr);
  }

  TargetSpeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TargetSpeed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TargetSpeed& from);
  void MergeFrom(const TargetSpeed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetSpeed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.TargetSpeed";
  }
  protected:
  explicit TargetSpeed(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLnSpeedFieldNumber = 1,
    kLtSpeedFieldNumber = 2,
    kAltSpeedFieldNumber = 3,
  };
  // double ln_speed = 1;
  void clear_ln_speed();
  double ln_speed() const;
  void set_ln_speed(double value);
  private:
  double _internal_ln_speed() const;
  void _internal_set_ln_speed(double value);
  public:

  // double lt_speed = 2;
  void clear_lt_speed();
  double lt_speed() const;
  void set_lt_speed(double value);
  private:
  double _internal_lt_speed() const;
  void _internal_set_lt_speed(double value);
  public:

  // double alt_speed = 3;
  void clear_alt_speed();
  double alt_speed() const;
  void set_alt_speed(double value);
  private:
  double _internal_alt_speed() const;
  void _internal_set_alt_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.TargetSpeed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double ln_speed_;
  double lt_speed_;
  double alt_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class PositionTargetDescriptor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.PositionTargetDescriptor) */ {
 public:
  inline PositionTargetDescriptor() : PositionTargetDescriptor(nullptr) {};
  virtual ~PositionTargetDescriptor();

  PositionTargetDescriptor(const PositionTargetDescriptor& from);
  PositionTargetDescriptor(PositionTargetDescriptor&& from) noexcept
    : PositionTargetDescriptor() {
    *this = ::std::move(from);
  }

  inline PositionTargetDescriptor& operator=(const PositionTargetDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionTargetDescriptor& operator=(PositionTargetDescriptor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PositionTargetDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionTargetDescriptor* internal_default_instance() {
    return reinterpret_cast<const PositionTargetDescriptor*>(
               &_PositionTargetDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PositionTargetDescriptor& a, PositionTargetDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionTargetDescriptor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionTargetDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PositionTargetDescriptor* New() const final {
    return CreateMaybeMessage<PositionTargetDescriptor>(nullptr);
  }

  PositionTargetDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PositionTargetDescriptor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PositionTargetDescriptor& from);
  void MergeFrom(const PositionTargetDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionTargetDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.PositionTargetDescriptor";
  }
  protected:
  explicit PositionTargetDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataSourceFieldNumber = 7,
    kTargetPositionFieldNumber = 2,
    kTargetSpeedFieldNumber = 3,
    kTimeFieldNumber = 5,
    kConfidenceIntervalFieldNumber = 4,
    kTargetIdFieldNumber = 1,
  };
  // repeated .zb.dcts.source.kh.DataSource data_source = 7;
  int data_source_size() const;
  private:
  int _internal_data_source_size() const;
  public:
  void clear_data_source();
  ::zb::dcts::source::kh::DataSource* mutable_data_source(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::DataSource >*
      mutable_data_source();
  private:
  const ::zb::dcts::source::kh::DataSource& _internal_data_source(int index) const;
  ::zb::dcts::source::kh::DataSource* _internal_add_data_source();
  public:
  const ::zb::dcts::source::kh::DataSource& data_source(int index) const;
  ::zb::dcts::source::kh::DataSource* add_data_source();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::DataSource >&
      data_source() const;

  // .zb.dcts.Position target_position = 2;
  bool has_target_position() const;
  private:
  bool _internal_has_target_position() const;
  public:
  void clear_target_position();
  const ::zb::dcts::Position& target_position() const;
  ::zb::dcts::Position* release_target_position();
  ::zb::dcts::Position* mutable_target_position();
  void set_allocated_target_position(::zb::dcts::Position* target_position);
  private:
  const ::zb::dcts::Position& _internal_target_position() const;
  ::zb::dcts::Position* _internal_mutable_target_position();
  public:
  void unsafe_arena_set_allocated_target_position(
      ::zb::dcts::Position* target_position);
  ::zb::dcts::Position* unsafe_arena_release_target_position();

  // .zb.dcts.source.kh.TargetSpeed target_speed = 3;
  bool has_target_speed() const;
  private:
  bool _internal_has_target_speed() const;
  public:
  void clear_target_speed();
  const ::zb::dcts::source::kh::TargetSpeed& target_speed() const;
  ::zb::dcts::source::kh::TargetSpeed* release_target_speed();
  ::zb::dcts::source::kh::TargetSpeed* mutable_target_speed();
  void set_allocated_target_speed(::zb::dcts::source::kh::TargetSpeed* target_speed);
  private:
  const ::zb::dcts::source::kh::TargetSpeed& _internal_target_speed() const;
  ::zb::dcts::source::kh::TargetSpeed* _internal_mutable_target_speed();
  public:
  void unsafe_arena_set_allocated_target_speed(
      ::zb::dcts::source::kh::TargetSpeed* target_speed);
  ::zb::dcts::source::kh::TargetSpeed* unsafe_arena_release_target_speed();

  // .zb.dcts.Timestamp time = 5;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::zb::dcts::Timestamp& time() const;
  ::zb::dcts::Timestamp* release_time();
  ::zb::dcts::Timestamp* mutable_time();
  void set_allocated_time(::zb::dcts::Timestamp* time);
  private:
  const ::zb::dcts::Timestamp& _internal_time() const;
  ::zb::dcts::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::zb::dcts::Timestamp* time);
  ::zb::dcts::Timestamp* unsafe_arena_release_time();

  // double confidence_interval = 4;
  void clear_confidence_interval();
  double confidence_interval() const;
  void set_confidence_interval(double value);
  private:
  double _internal_confidence_interval() const;
  void _internal_set_confidence_interval(double value);
  public:

  // uint32 target_id = 1;
  void clear_target_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 target_id() const;
  void set_target_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_target_id() const;
  void _internal_set_target_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.PositionTargetDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::DataSource > data_source_;
  ::zb::dcts::Position* target_position_;
  ::zb::dcts::source::kh::TargetSpeed* target_speed_;
  ::zb::dcts::Timestamp* time_;
  double confidence_interval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 target_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class TimeTriggerParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.TimeTriggerParam) */ {
 public:
  inline TimeTriggerParam() : TimeTriggerParam(nullptr) {};
  virtual ~TimeTriggerParam();

  TimeTriggerParam(const TimeTriggerParam& from);
  TimeTriggerParam(TimeTriggerParam&& from) noexcept
    : TimeTriggerParam() {
    *this = ::std::move(from);
  }

  inline TimeTriggerParam& operator=(const TimeTriggerParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeTriggerParam& operator=(TimeTriggerParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimeTriggerParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeTriggerParam* internal_default_instance() {
    return reinterpret_cast<const TimeTriggerParam*>(
               &_TimeTriggerParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TimeTriggerParam& a, TimeTriggerParam& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeTriggerParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeTriggerParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimeTriggerParam* New() const final {
    return CreateMaybeMessage<TimeTriggerParam>(nullptr);
  }

  TimeTriggerParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimeTriggerParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimeTriggerParam& from);
  void MergeFrom(const TimeTriggerParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeTriggerParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.TimeTriggerParam";
  }
  protected:
  explicit TimeTriggerParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TimeTriggerParam_TriggerType TriggerType;
  static constexpr TriggerType NONE =
    TimeTriggerParam_TriggerType_NONE;
  static constexpr TriggerType ABS_TIME =
    TimeTriggerParam_TriggerType_ABS_TIME;
  static constexpr TriggerType REL_TIME =
    TimeTriggerParam_TriggerType_REL_TIME;
  static inline bool TriggerType_IsValid(int value) {
    return TimeTriggerParam_TriggerType_IsValid(value);
  }
  static constexpr TriggerType TriggerType_MIN =
    TimeTriggerParam_TriggerType_TriggerType_MIN;
  static constexpr TriggerType TriggerType_MAX =
    TimeTriggerParam_TriggerType_TriggerType_MAX;
  static constexpr int TriggerType_ARRAYSIZE =
    TimeTriggerParam_TriggerType_TriggerType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TriggerType_descriptor() {
    return TimeTriggerParam_TriggerType_descriptor();
  }
  template<typename T>
  static inline const std::string& TriggerType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TriggerType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TriggerType_Name.");
    return TimeTriggerParam_TriggerType_Name(enum_t_value);
  }
  static inline bool TriggerType_Parse(const std::string& name,
      TriggerType* value) {
    return TimeTriggerParam_TriggerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerTimeFieldNumber = 2,
    kTriggerTypeFieldNumber = 1,
    kSweepIntervalFieldNumber = 3,
    kSegmentIntervalFieldNumber = 4,
  };
  // .zb.dcts.Timestamp trigger_time = 2;
  bool has_trigger_time() const;
  private:
  bool _internal_has_trigger_time() const;
  public:
  void clear_trigger_time();
  const ::zb::dcts::Timestamp& trigger_time() const;
  ::zb::dcts::Timestamp* release_trigger_time();
  ::zb::dcts::Timestamp* mutable_trigger_time();
  void set_allocated_trigger_time(::zb::dcts::Timestamp* trigger_time);
  private:
  const ::zb::dcts::Timestamp& _internal_trigger_time() const;
  ::zb::dcts::Timestamp* _internal_mutable_trigger_time();
  public:
  void unsafe_arena_set_allocated_trigger_time(
      ::zb::dcts::Timestamp* trigger_time);
  ::zb::dcts::Timestamp* unsafe_arena_release_trigger_time();

  // .zb.dcts.source.kh.TimeTriggerParam.TriggerType trigger_type = 1;
  void clear_trigger_type();
  ::zb::dcts::source::kh::TimeTriggerParam_TriggerType trigger_type() const;
  void set_trigger_type(::zb::dcts::source::kh::TimeTriggerParam_TriggerType value);
  private:
  ::zb::dcts::source::kh::TimeTriggerParam_TriggerType _internal_trigger_type() const;
  void _internal_set_trigger_type(::zb::dcts::source::kh::TimeTriggerParam_TriggerType value);
  public:

  // uint32 sweep_interval = 3;
  void clear_sweep_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 sweep_interval() const;
  void set_sweep_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sweep_interval() const;
  void _internal_set_sweep_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 segment_interval = 4;
  void clear_segment_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 segment_interval() const;
  void set_segment_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_segment_interval() const;
  void _internal_set_segment_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.TimeTriggerParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::Timestamp* trigger_time_;
  int trigger_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sweep_interval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 segment_interval_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class FreqTriggerParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.FreqTriggerParam) */ {
 public:
  inline FreqTriggerParam() : FreqTriggerParam(nullptr) {};
  virtual ~FreqTriggerParam();

  FreqTriggerParam(const FreqTriggerParam& from);
  FreqTriggerParam(FreqTriggerParam&& from) noexcept
    : FreqTriggerParam() {
    *this = ::std::move(from);
  }

  inline FreqTriggerParam& operator=(const FreqTriggerParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreqTriggerParam& operator=(FreqTriggerParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FreqTriggerParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreqTriggerParam* internal_default_instance() {
    return reinterpret_cast<const FreqTriggerParam*>(
               &_FreqTriggerParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(FreqTriggerParam& a, FreqTriggerParam& b) {
    a.Swap(&b);
  }
  inline void Swap(FreqTriggerParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreqTriggerParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FreqTriggerParam* New() const final {
    return CreateMaybeMessage<FreqTriggerParam>(nullptr);
  }

  FreqTriggerParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FreqTriggerParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FreqTriggerParam& from);
  void MergeFrom(const FreqTriggerParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreqTriggerParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.FreqTriggerParam";
  }
  protected:
  explicit FreqTriggerParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef FreqTriggerParam_TriggerType TriggerType;
  static constexpr TriggerType NONE =
    FreqTriggerParam_TriggerType_NONE;
  static constexpr TriggerType FREQ =
    FreqTriggerParam_TriggerType_FREQ;
  static inline bool TriggerType_IsValid(int value) {
    return FreqTriggerParam_TriggerType_IsValid(value);
  }
  static constexpr TriggerType TriggerType_MIN =
    FreqTriggerParam_TriggerType_TriggerType_MIN;
  static constexpr TriggerType TriggerType_MAX =
    FreqTriggerParam_TriggerType_TriggerType_MAX;
  static constexpr int TriggerType_ARRAYSIZE =
    FreqTriggerParam_TriggerType_TriggerType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TriggerType_descriptor() {
    return FreqTriggerParam_TriggerType_descriptor();
  }
  template<typename T>
  static inline const std::string& TriggerType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TriggerType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TriggerType_Name.");
    return FreqTriggerParam_TriggerType_Name(enum_t_value);
  }
  static inline bool TriggerType_Parse(const std::string& name,
      TriggerType* value) {
    return FreqTriggerParam_TriggerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerTypeFieldNumber = 1,
    kTriggerValueFieldNumber = 2,
  };
  // .zb.dcts.source.kh.FreqTriggerParam.TriggerType trigger_type = 1;
  void clear_trigger_type();
  ::zb::dcts::source::kh::FreqTriggerParam_TriggerType trigger_type() const;
  void set_trigger_type(::zb::dcts::source::kh::FreqTriggerParam_TriggerType value);
  private:
  ::zb::dcts::source::kh::FreqTriggerParam_TriggerType _internal_trigger_type() const;
  void _internal_set_trigger_type(::zb::dcts::source::kh::FreqTriggerParam_TriggerType value);
  public:

  // float trigger_value = 2;
  void clear_trigger_value();
  float trigger_value() const;
  void set_trigger_value(float value);
  private:
  float _internal_trigger_value() const;
  void _internal_set_trigger_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.FreqTriggerParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int trigger_type_;
  float trigger_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// -------------------------------------------------------------------

class LevelTriggerParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.source.kh.LevelTriggerParam) */ {
 public:
  inline LevelTriggerParam() : LevelTriggerParam(nullptr) {};
  virtual ~LevelTriggerParam();

  LevelTriggerParam(const LevelTriggerParam& from);
  LevelTriggerParam(LevelTriggerParam&& from) noexcept
    : LevelTriggerParam() {
    *this = ::std::move(from);
  }

  inline LevelTriggerParam& operator=(const LevelTriggerParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline LevelTriggerParam& operator=(LevelTriggerParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LevelTriggerParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LevelTriggerParam* internal_default_instance() {
    return reinterpret_cast<const LevelTriggerParam*>(
               &_LevelTriggerParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LevelTriggerParam& a, LevelTriggerParam& b) {
    a.Swap(&b);
  }
  inline void Swap(LevelTriggerParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LevelTriggerParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LevelTriggerParam* New() const final {
    return CreateMaybeMessage<LevelTriggerParam>(nullptr);
  }

  LevelTriggerParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LevelTriggerParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LevelTriggerParam& from);
  void MergeFrom(const LevelTriggerParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LevelTriggerParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.source.kh.LevelTriggerParam";
  }
  protected:
  explicit LevelTriggerParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_source_2fkh_2fKhContext_2eproto);
    return ::descriptor_table_source_2fkh_2fKhContext_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LevelTriggerParam_TriggerType TriggerType;
  static constexpr TriggerType NONE =
    LevelTriggerParam_TriggerType_NONE;
  static constexpr TriggerType LEVEL =
    LevelTriggerParam_TriggerType_LEVEL;
  static constexpr TriggerType RISING =
    LevelTriggerParam_TriggerType_RISING;
  static constexpr TriggerType FALLING =
    LevelTriggerParam_TriggerType_FALLING;
  static inline bool TriggerType_IsValid(int value) {
    return LevelTriggerParam_TriggerType_IsValid(value);
  }
  static constexpr TriggerType TriggerType_MIN =
    LevelTriggerParam_TriggerType_TriggerType_MIN;
  static constexpr TriggerType TriggerType_MAX =
    LevelTriggerParam_TriggerType_TriggerType_MAX;
  static constexpr int TriggerType_ARRAYSIZE =
    LevelTriggerParam_TriggerType_TriggerType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TriggerType_descriptor() {
    return LevelTriggerParam_TriggerType_descriptor();
  }
  template<typename T>
  static inline const std::string& TriggerType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TriggerType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TriggerType_Name.");
    return LevelTriggerParam_TriggerType_Name(enum_t_value);
  }
  static inline bool TriggerType_Parse(const std::string& name,
      TriggerType* value) {
    return LevelTriggerParam_TriggerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerTypeFieldNumber = 1,
    kTriggerValueFieldNumber = 2,
  };
  // .zb.dcts.source.kh.LevelTriggerParam.TriggerType trigger_type = 1;
  void clear_trigger_type();
  ::zb::dcts::source::kh::LevelTriggerParam_TriggerType trigger_type() const;
  void set_trigger_type(::zb::dcts::source::kh::LevelTriggerParam_TriggerType value);
  private:
  ::zb::dcts::source::kh::LevelTriggerParam_TriggerType _internal_trigger_type() const;
  void _internal_set_trigger_type(::zb::dcts::source::kh::LevelTriggerParam_TriggerType value);
  public:

  // float trigger_value = 2;
  void clear_trigger_value();
  float trigger_value() const;
  void set_trigger_value(float value);
  private:
  float _internal_trigger_value() const;
  void _internal_set_trigger_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.source.kh.LevelTriggerParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int trigger_type_;
  float trigger_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_source_2fkh_2fKhContext_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StaticSelfTestResult

// .zb.dcts.source.SourceId source_id = 1;
inline bool StaticSelfTestResult::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool StaticSelfTestResult::has_source_id() const {
  return _internal_has_source_id();
}
inline const ::zb::dcts::source::SourceId& StaticSelfTestResult::_internal_source_id() const {
  const ::zb::dcts::source::SourceId* p = source_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::SourceId*>(
      &::zb::dcts::source::_SourceId_default_instance_);
}
inline const ::zb::dcts::source::SourceId& StaticSelfTestResult::source_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.StaticSelfTestResult.source_id)
  return _internal_source_id();
}
inline void StaticSelfTestResult::unsafe_arena_set_allocated_source_id(
    ::zb::dcts::source::SourceId* source_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.StaticSelfTestResult.source_id)
}
inline ::zb::dcts::source::SourceId* StaticSelfTestResult::release_source_id() {
  auto temp = unsafe_arena_release_source_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::SourceId* StaticSelfTestResult::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.StaticSelfTestResult.source_id)
  
  ::zb::dcts::source::SourceId* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::SourceId* StaticSelfTestResult::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::SourceId>(GetArena());
    source_id_ = p;
  }
  return source_id_;
}
inline ::zb::dcts::source::SourceId* StaticSelfTestResult::mutable_source_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.StaticSelfTestResult.source_id)
  return _internal_mutable_source_id();
}
inline void StaticSelfTestResult::set_allocated_source_id(::zb::dcts::source::SourceId* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id)->GetArena();
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.StaticSelfTestResult.source_id)
}

// string status = 2;
inline void StaticSelfTestResult::clear_status() {
  status_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& StaticSelfTestResult::status() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.StaticSelfTestResult.status)
  return _internal_status();
}
inline void StaticSelfTestResult::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.StaticSelfTestResult.status)
}
inline std::string* StaticSelfTestResult::mutable_status() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.StaticSelfTestResult.status)
  return _internal_mutable_status();
}
inline const std::string& StaticSelfTestResult::_internal_status() const {
  return status_.Get();
}
inline void StaticSelfTestResult::_internal_set_status(const std::string& value) {
  
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StaticSelfTestResult::set_status(std::string&& value) {
  
  status_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.source.kh.StaticSelfTestResult.status)
}
inline void StaticSelfTestResult::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.source.kh.StaticSelfTestResult.status)
}
inline void StaticSelfTestResult::set_status(const char* value,
    size_t size) {
  
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.source.kh.StaticSelfTestResult.status)
}
inline std::string* StaticSelfTestResult::_internal_mutable_status() {
  
  return status_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StaticSelfTestResult::release_status() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.StaticSelfTestResult.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StaticSelfTestResult::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.StaticSelfTestResult.status)
}
inline std::string* StaticSelfTestResult::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.source.kh.StaticSelfTestResult.status)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return status_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void StaticSelfTestResult::unsafe_arena_set_allocated_status(
    std::string* status) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (status != nullptr) {
    
  } else {
    
  }
  status_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      status, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.StaticSelfTestResult.status)
}

// -------------------------------------------------------------------

// WindowParams

// .zb.dcts.source.kh.WindowType type = 1;
inline void WindowParams::clear_type() {
  type_ = 0;
}
inline ::zb::dcts::source::kh::WindowType WindowParams::_internal_type() const {
  return static_cast< ::zb::dcts::source::kh::WindowType >(type_);
}
inline ::zb::dcts::source::kh::WindowType WindowParams::type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.WindowParams.type)
  return _internal_type();
}
inline void WindowParams::_internal_set_type(::zb::dcts::source::kh::WindowType value) {
  
  type_ = value;
}
inline void WindowParams::set_type(::zb::dcts::source::kh::WindowType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.WindowParams.type)
}

// double param = 2;
inline void WindowParams::clear_param() {
  param_ = 0;
}
inline double WindowParams::_internal_param() const {
  return param_;
}
inline double WindowParams::param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.WindowParams.param)
  return _internal_param();
}
inline void WindowParams::_internal_set_param(double value) {
  
  param_ = value;
}
inline void WindowParams::set_param(double value) {
  _internal_set_param(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.WindowParams.param)
}

// -------------------------------------------------------------------

// GainControlParam

// float hold_time = 1;
inline void GainControlParam::clear_hold_time() {
  hold_time_ = 0;
}
inline float GainControlParam::_internal_hold_time() const {
  return hold_time_;
}
inline float GainControlParam::hold_time() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.GainControlParam.hold_time)
  return _internal_hold_time();
}
inline void GainControlParam::_internal_set_hold_time(float value) {
  
  hold_time_ = value;
}
inline void GainControlParam::set_hold_time(float value) {
  _internal_set_hold_time(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.GainControlParam.hold_time)
}

// float inc = 2;
inline void GainControlParam::clear_inc() {
  inc_ = 0;
}
inline float GainControlParam::_internal_inc() const {
  return inc_;
}
inline float GainControlParam::inc() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.GainControlParam.inc)
  return _internal_inc();
}
inline void GainControlParam::_internal_set_inc(float value) {
  
  inc_ = value;
}
inline void GainControlParam::set_inc(float value) {
  _internal_set_inc(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.GainControlParam.inc)
}

// -------------------------------------------------------------------

// OperationStatus

// .zb.dcts.TimeSpan time_span = 1;
inline bool OperationStatus::_internal_has_time_span() const {
  return this != internal_default_instance() && time_span_ != nullptr;
}
inline bool OperationStatus::has_time_span() const {
  return _internal_has_time_span();
}
inline const ::zb::dcts::TimeSpan& OperationStatus::_internal_time_span() const {
  const ::zb::dcts::TimeSpan* p = time_span_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::TimeSpan*>(
      &::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& OperationStatus::time_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.OperationStatus.time_span)
  return _internal_time_span();
}
inline void OperationStatus::unsafe_arena_set_allocated_time_span(
    ::zb::dcts::TimeSpan* time_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  time_span_ = time_span;
  if (time_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.OperationStatus.time_span)
}
inline ::zb::dcts::TimeSpan* OperationStatus::release_time_span() {
  auto temp = unsafe_arena_release_time_span();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* OperationStatus::unsafe_arena_release_time_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.OperationStatus.time_span)
  
  ::zb::dcts::TimeSpan* temp = time_span_;
  time_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* OperationStatus::_internal_mutable_time_span() {
  
  if (time_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    time_span_ = p;
  }
  return time_span_;
}
inline ::zb::dcts::TimeSpan* OperationStatus::mutable_time_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.OperationStatus.time_span)
  return _internal_mutable_time_span();
}
inline void OperationStatus::set_allocated_time_span(::zb::dcts::TimeSpan* time_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  if (time_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span)->GetArena();
    if (message_arena != submessage_arena) {
      time_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_span, submessage_arena);
    }
    
  } else {
    
  }
  time_span_ = time_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.OperationStatus.time_span)
}

// uint64 total_sweep_count = 2;
inline void OperationStatus::clear_total_sweep_count() {
  total_sweep_count_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OperationStatus::_internal_total_sweep_count() const {
  return total_sweep_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OperationStatus::total_sweep_count() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.OperationStatus.total_sweep_count)
  return _internal_total_sweep_count();
}
inline void OperationStatus::_internal_set_total_sweep_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  total_sweep_count_ = value;
}
inline void OperationStatus::set_total_sweep_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_total_sweep_count(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.OperationStatus.total_sweep_count)
}

// uint64 record_count = 3;
inline void OperationStatus::clear_record_count() {
  record_count_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OperationStatus::_internal_record_count() const {
  return record_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OperationStatus::record_count() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.OperationStatus.record_count)
  return _internal_record_count();
}
inline void OperationStatus::_internal_set_record_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  record_count_ = value;
}
inline void OperationStatus::set_record_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_record_count(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.OperationStatus.record_count)
}

// -------------------------------------------------------------------

// TargetDirection

// double center_frequency = 1;
inline void TargetDirection::clear_center_frequency() {
  center_frequency_ = 0;
}
inline double TargetDirection::_internal_center_frequency() const {
  return center_frequency_;
}
inline double TargetDirection::center_frequency() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TargetDirection.center_frequency)
  return _internal_center_frequency();
}
inline void TargetDirection::_internal_set_center_frequency(double value) {
  
  center_frequency_ = value;
}
inline void TargetDirection::set_center_frequency(double value) {
  _internal_set_center_frequency(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TargetDirection.center_frequency)
}

// double direction = 2;
inline void TargetDirection::clear_direction() {
  direction_ = 0;
}
inline double TargetDirection::_internal_direction() const {
  return direction_;
}
inline double TargetDirection::direction() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TargetDirection.direction)
  return _internal_direction();
}
inline void TargetDirection::_internal_set_direction(double value) {
  
  direction_ = value;
}
inline void TargetDirection::set_direction(double value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TargetDirection.direction)
}

// int32 confidence = 3;
inline void TargetDirection::clear_confidence() {
  confidence_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TargetDirection::_internal_confidence() const {
  return confidence_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TargetDirection::confidence() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TargetDirection.confidence)
  return _internal_confidence();
}
inline void TargetDirection::_internal_set_confidence(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  confidence_ = value;
}
inline void TargetDirection::set_confidence(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TargetDirection.confidence)
}

// float amplitude = 4;
inline void TargetDirection::clear_amplitude() {
  amplitude_ = 0;
}
inline float TargetDirection::_internal_amplitude() const {
  return amplitude_;
}
inline float TargetDirection::amplitude() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TargetDirection.amplitude)
  return _internal_amplitude();
}
inline void TargetDirection::_internal_set_amplitude(float value) {
  
  amplitude_ = value;
}
inline void TargetDirection::set_amplitude(float value) {
  _internal_set_amplitude(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TargetDirection.amplitude)
}

// .zb.dcts.Timestamp time_stamp = 5;
inline bool TargetDirection::_internal_has_time_stamp() const {
  return this != internal_default_instance() && time_stamp_ != nullptr;
}
inline bool TargetDirection::has_time_stamp() const {
  return _internal_has_time_stamp();
}
inline const ::zb::dcts::Timestamp& TargetDirection::_internal_time_stamp() const {
  const ::zb::dcts::Timestamp* p = time_stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Timestamp*>(
      &::zb::dcts::_Timestamp_default_instance_);
}
inline const ::zb::dcts::Timestamp& TargetDirection::time_stamp() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TargetDirection.time_stamp)
  return _internal_time_stamp();
}
inline void TargetDirection::unsafe_arena_set_allocated_time_stamp(
    ::zb::dcts::Timestamp* time_stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_stamp_);
  }
  time_stamp_ = time_stamp;
  if (time_stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.TargetDirection.time_stamp)
}
inline ::zb::dcts::Timestamp* TargetDirection::release_time_stamp() {
  auto temp = unsafe_arena_release_time_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Timestamp* TargetDirection::unsafe_arena_release_time_stamp() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.TargetDirection.time_stamp)
  
  ::zb::dcts::Timestamp* temp = time_stamp_;
  time_stamp_ = nullptr;
  return temp;
}
inline ::zb::dcts::Timestamp* TargetDirection::_internal_mutable_time_stamp() {
  
  if (time_stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Timestamp>(GetArena());
    time_stamp_ = p;
  }
  return time_stamp_;
}
inline ::zb::dcts::Timestamp* TargetDirection::mutable_time_stamp() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.TargetDirection.time_stamp)
  return _internal_mutable_time_stamp();
}
inline void TargetDirection::set_allocated_time_stamp(::zb::dcts::Timestamp* time_stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_stamp_);
  }
  if (time_stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_stamp)->GetArena();
    if (message_arena != submessage_arena) {
      time_stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_stamp, submessage_arena);
    }
    
  } else {
    
  }
  time_stamp_ = time_stamp;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.TargetDirection.time_stamp)
}

// double pitch_angle = 6;
inline void TargetDirection::clear_pitch_angle() {
  pitch_angle_ = 0;
}
inline double TargetDirection::_internal_pitch_angle() const {
  return pitch_angle_;
}
inline double TargetDirection::pitch_angle() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TargetDirection.pitch_angle)
  return _internal_pitch_angle();
}
inline void TargetDirection::_internal_set_pitch_angle(double value) {
  
  pitch_angle_ = value;
}
inline void TargetDirection::set_pitch_angle(double value) {
  _internal_set_pitch_angle(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TargetDirection.pitch_angle)
}

// -------------------------------------------------------------------

// PulseSample

// double carrier_freq = 1;
inline void PulseSample::clear_carrier_freq() {
  carrier_freq_ = 0;
}
inline double PulseSample::_internal_carrier_freq() const {
  return carrier_freq_;
}
inline double PulseSample::carrier_freq() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseSample.carrier_freq)
  return _internal_carrier_freq();
}
inline void PulseSample::_internal_set_carrier_freq(double value) {
  
  carrier_freq_ = value;
}
inline void PulseSample::set_carrier_freq(double value) {
  _internal_set_carrier_freq(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PulseSample.carrier_freq)
}

// float pulse_width = 2;
inline void PulseSample::clear_pulse_width() {
  pulse_width_ = 0;
}
inline float PulseSample::_internal_pulse_width() const {
  return pulse_width_;
}
inline float PulseSample::pulse_width() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseSample.pulse_width)
  return _internal_pulse_width();
}
inline void PulseSample::_internal_set_pulse_width(float value) {
  
  pulse_width_ = value;
}
inline void PulseSample::set_pulse_width(float value) {
  _internal_set_pulse_width(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PulseSample.pulse_width)
}

// float repeat_period = 3;
inline void PulseSample::clear_repeat_period() {
  repeat_period_ = 0;
}
inline float PulseSample::_internal_repeat_period() const {
  return repeat_period_;
}
inline float PulseSample::repeat_period() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseSample.repeat_period)
  return _internal_repeat_period();
}
inline void PulseSample::_internal_set_repeat_period(float value) {
  
  repeat_period_ = value;
}
inline void PulseSample::set_repeat_period(float value) {
  _internal_set_repeat_period(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PulseSample.repeat_period)
}

// uint32 repeat_period_type = 4;
inline void PulseSample::clear_repeat_period_type() {
  repeat_period_type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PulseSample::_internal_repeat_period_type() const {
  return repeat_period_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PulseSample::repeat_period_type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseSample.repeat_period_type)
  return _internal_repeat_period_type();
}
inline void PulseSample::_internal_set_repeat_period_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  repeat_period_type_ = value;
}
inline void PulseSample::set_repeat_period_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_repeat_period_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PulseSample.repeat_period_type)
}

// uint32 freq_type = 5;
inline void PulseSample::clear_freq_type() {
  freq_type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PulseSample::_internal_freq_type() const {
  return freq_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PulseSample::freq_type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseSample.freq_type)
  return _internal_freq_type();
}
inline void PulseSample::_internal_set_freq_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  freq_type_ = value;
}
inline void PulseSample::set_freq_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_freq_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PulseSample.freq_type)
}

// uint32 pw_type = 6;
inline void PulseSample::clear_pw_type() {
  pw_type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PulseSample::_internal_pw_type() const {
  return pw_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PulseSample::pw_type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseSample.pw_type)
  return _internal_pw_type();
}
inline void PulseSample::_internal_set_pw_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  pw_type_ = value;
}
inline void PulseSample::set_pw_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pw_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PulseSample.pw_type)
}

// -------------------------------------------------------------------

// PulseCluster

// float freq = 1;
inline void PulseCluster::clear_freq() {
  freq_ = 0;
}
inline float PulseCluster::_internal_freq() const {
  return freq_;
}
inline float PulseCluster::freq() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseCluster.freq)
  return _internal_freq();
}
inline void PulseCluster::_internal_set_freq(float value) {
  
  freq_ = value;
}
inline void PulseCluster::set_freq(float value) {
  _internal_set_freq(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PulseCluster.freq)
}

// float bw = 2;
inline void PulseCluster::clear_bw() {
  bw_ = 0;
}
inline float PulseCluster::_internal_bw() const {
  return bw_;
}
inline float PulseCluster::bw() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseCluster.bw)
  return _internal_bw();
}
inline void PulseCluster::_internal_set_bw(float value) {
  
  bw_ = value;
}
inline void PulseCluster::set_bw(float value) {
  _internal_set_bw(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PulseCluster.bw)
}

// uint32 type = 3;
inline void PulseCluster::clear_type() {
  type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PulseCluster::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PulseCluster::type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseCluster.type)
  return _internal_type();
}
inline void PulseCluster::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  type_ = value;
}
inline void PulseCluster::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PulseCluster.type)
}

// .zb.dcts.StatisticVal ampt = 4;
inline bool PulseCluster::_internal_has_ampt() const {
  return this != internal_default_instance() && ampt_ != nullptr;
}
inline bool PulseCluster::has_ampt() const {
  return _internal_has_ampt();
}
inline const ::zb::dcts::StatisticVal& PulseCluster::_internal_ampt() const {
  const ::zb::dcts::StatisticVal* p = ampt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::StatisticVal*>(
      &::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& PulseCluster::ampt() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseCluster.ampt)
  return _internal_ampt();
}
inline void PulseCluster::unsafe_arena_set_allocated_ampt(
    ::zb::dcts::StatisticVal* ampt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ampt_);
  }
  ampt_ = ampt;
  if (ampt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.PulseCluster.ampt)
}
inline ::zb::dcts::StatisticVal* PulseCluster::release_ampt() {
  auto temp = unsafe_arena_release_ampt();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* PulseCluster::unsafe_arena_release_ampt() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.PulseCluster.ampt)
  
  ::zb::dcts::StatisticVal* temp = ampt_;
  ampt_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* PulseCluster::_internal_mutable_ampt() {
  
  if (ampt_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    ampt_ = p;
  }
  return ampt_;
}
inline ::zb::dcts::StatisticVal* PulseCluster::mutable_ampt() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.PulseCluster.ampt)
  return _internal_mutable_ampt();
}
inline void PulseCluster::set_allocated_ampt(::zb::dcts::StatisticVal* ampt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ampt_);
  }
  if (ampt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ampt)->GetArena();
    if (message_arena != submessage_arena) {
      ampt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ampt, submessage_arena);
    }
    
  } else {
    
  }
  ampt_ = ampt;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.PulseCluster.ampt)
}

// repeated .zb.dcts.source.kh.PulseSample pulse_samples = 5;
inline int PulseCluster::_internal_pulse_samples_size() const {
  return pulse_samples_.size();
}
inline int PulseCluster::pulse_samples_size() const {
  return _internal_pulse_samples_size();
}
inline void PulseCluster::clear_pulse_samples() {
  pulse_samples_.Clear();
}
inline ::zb::dcts::source::kh::PulseSample* PulseCluster::mutable_pulse_samples(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.PulseCluster.pulse_samples)
  return pulse_samples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::PulseSample >*
PulseCluster::mutable_pulse_samples() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.source.kh.PulseCluster.pulse_samples)
  return &pulse_samples_;
}
inline const ::zb::dcts::source::kh::PulseSample& PulseCluster::_internal_pulse_samples(int index) const {
  return pulse_samples_.Get(index);
}
inline const ::zb::dcts::source::kh::PulseSample& PulseCluster::pulse_samples(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseCluster.pulse_samples)
  return _internal_pulse_samples(index);
}
inline ::zb::dcts::source::kh::PulseSample* PulseCluster::_internal_add_pulse_samples() {
  return pulse_samples_.Add();
}
inline ::zb::dcts::source::kh::PulseSample* PulseCluster::add_pulse_samples() {
  // @@protoc_insertion_point(field_add:zb.dcts.source.kh.PulseCluster.pulse_samples)
  return _internal_add_pulse_samples();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::PulseSample >&
PulseCluster::pulse_samples() const {
  // @@protoc_insertion_point(field_list:zb.dcts.source.kh.PulseCluster.pulse_samples)
  return pulse_samples_;
}

// .zb.dcts.TimeSpan time_span = 6;
inline bool PulseCluster::_internal_has_time_span() const {
  return this != internal_default_instance() && time_span_ != nullptr;
}
inline bool PulseCluster::has_time_span() const {
  return _internal_has_time_span();
}
inline const ::zb::dcts::TimeSpan& PulseCluster::_internal_time_span() const {
  const ::zb::dcts::TimeSpan* p = time_span_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::TimeSpan*>(
      &::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& PulseCluster::time_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PulseCluster.time_span)
  return _internal_time_span();
}
inline void PulseCluster::unsafe_arena_set_allocated_time_span(
    ::zb::dcts::TimeSpan* time_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  time_span_ = time_span;
  if (time_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.PulseCluster.time_span)
}
inline ::zb::dcts::TimeSpan* PulseCluster::release_time_span() {
  auto temp = unsafe_arena_release_time_span();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* PulseCluster::unsafe_arena_release_time_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.PulseCluster.time_span)
  
  ::zb::dcts::TimeSpan* temp = time_span_;
  time_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* PulseCluster::_internal_mutable_time_span() {
  
  if (time_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    time_span_ = p;
  }
  return time_span_;
}
inline ::zb::dcts::TimeSpan* PulseCluster::mutable_time_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.PulseCluster.time_span)
  return _internal_mutable_time_span();
}
inline void PulseCluster::set_allocated_time_span(::zb::dcts::TimeSpan* time_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  if (time_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span)->GetArena();
    if (message_arena != submessage_arena) {
      time_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_span, submessage_arena);
    }
    
  } else {
    
  }
  time_span_ = time_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.PulseCluster.time_span)
}

// -------------------------------------------------------------------

// DataSource

// uint32 task_id = 1;
inline void DataSource::clear_task_id() {
  task_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataSource::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataSource::task_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.DataSource.task_id)
  return _internal_task_id();
}
inline void DataSource::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  task_id_ = value;
}
inline void DataSource::set_task_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.DataSource.task_id)
}

// .zb.dcts.source.SourceId source_id = 2;
inline bool DataSource::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool DataSource::has_source_id() const {
  return _internal_has_source_id();
}
inline const ::zb::dcts::source::SourceId& DataSource::_internal_source_id() const {
  const ::zb::dcts::source::SourceId* p = source_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::SourceId*>(
      &::zb::dcts::source::_SourceId_default_instance_);
}
inline const ::zb::dcts::source::SourceId& DataSource::source_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.DataSource.source_id)
  return _internal_source_id();
}
inline void DataSource::unsafe_arena_set_allocated_source_id(
    ::zb::dcts::source::SourceId* source_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.DataSource.source_id)
}
inline ::zb::dcts::source::SourceId* DataSource::release_source_id() {
  auto temp = unsafe_arena_release_source_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::SourceId* DataSource::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.DataSource.source_id)
  
  ::zb::dcts::source::SourceId* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::SourceId* DataSource::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::SourceId>(GetArena());
    source_id_ = p;
  }
  return source_id_;
}
inline ::zb::dcts::source::SourceId* DataSource::mutable_source_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.DataSource.source_id)
  return _internal_mutable_source_id();
}
inline void DataSource::set_allocated_source_id(::zb::dcts::source::SourceId* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id)->GetArena();
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.DataSource.source_id)
}

// .zb.dcts.Position position = 3;
inline bool DataSource::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool DataSource::has_position() const {
  return _internal_has_position();
}
inline const ::zb::dcts::Position& DataSource::_internal_position() const {
  const ::zb::dcts::Position* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Position*>(
      &::zb::dcts::_Position_default_instance_);
}
inline const ::zb::dcts::Position& DataSource::position() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.DataSource.position)
  return _internal_position();
}
inline void DataSource::unsafe_arena_set_allocated_position(
    ::zb::dcts::Position* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.DataSource.position)
}
inline ::zb::dcts::Position* DataSource::release_position() {
  auto temp = unsafe_arena_release_position();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Position* DataSource::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.DataSource.position)
  
  ::zb::dcts::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::zb::dcts::Position* DataSource::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Position>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::zb::dcts::Position* DataSource::mutable_position() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.DataSource.position)
  return _internal_mutable_position();
}
inline void DataSource::set_allocated_position(::zb::dcts::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position)->GetArena();
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.DataSource.position)
}

// -------------------------------------------------------------------

// PositionDataSource

// uint32 task_id = 1;
inline void PositionDataSource::clear_task_id() {
  task_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PositionDataSource::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PositionDataSource::task_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PositionDataSource.task_id)
  return _internal_task_id();
}
inline void PositionDataSource::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  task_id_ = value;
}
inline void PositionDataSource::set_task_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PositionDataSource.task_id)
}

// repeated .zb.dcts.source.SourceId task_runner = 2;
inline int PositionDataSource::_internal_task_runner_size() const {
  return task_runner_.size();
}
inline int PositionDataSource::task_runner_size() const {
  return _internal_task_runner_size();
}
inline ::zb::dcts::source::SourceId* PositionDataSource::mutable_task_runner(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.PositionDataSource.task_runner)
  return task_runner_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::SourceId >*
PositionDataSource::mutable_task_runner() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.source.kh.PositionDataSource.task_runner)
  return &task_runner_;
}
inline const ::zb::dcts::source::SourceId& PositionDataSource::_internal_task_runner(int index) const {
  return task_runner_.Get(index);
}
inline const ::zb::dcts::source::SourceId& PositionDataSource::task_runner(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PositionDataSource.task_runner)
  return _internal_task_runner(index);
}
inline ::zb::dcts::source::SourceId* PositionDataSource::_internal_add_task_runner() {
  return task_runner_.Add();
}
inline ::zb::dcts::source::SourceId* PositionDataSource::add_task_runner() {
  // @@protoc_insertion_point(field_add:zb.dcts.source.kh.PositionDataSource.task_runner)
  return _internal_add_task_runner();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::SourceId >&
PositionDataSource::task_runner() const {
  // @@protoc_insertion_point(field_list:zb.dcts.source.kh.PositionDataSource.task_runner)
  return task_runner_;
}

// -------------------------------------------------------------------

// OnLinePositionParam

// .zb.dcts.source.kh.PositionDataSource data_source = 1;
inline bool OnLinePositionParam::_internal_has_data_source() const {
  return this != internal_default_instance() && data_source_ != nullptr;
}
inline bool OnLinePositionParam::has_data_source() const {
  return _internal_has_data_source();
}
inline void OnLinePositionParam::clear_data_source() {
  if (GetArena() == nullptr && data_source_ != nullptr) {
    delete data_source_;
  }
  data_source_ = nullptr;
}
inline const ::zb::dcts::source::kh::PositionDataSource& OnLinePositionParam::_internal_data_source() const {
  const ::zb::dcts::source::kh::PositionDataSource* p = data_source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::kh::PositionDataSource*>(
      &::zb::dcts::source::kh::_PositionDataSource_default_instance_);
}
inline const ::zb::dcts::source::kh::PositionDataSource& OnLinePositionParam::data_source() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.OnLinePositionParam.data_source)
  return _internal_data_source();
}
inline void OnLinePositionParam::unsafe_arena_set_allocated_data_source(
    ::zb::dcts::source::kh::PositionDataSource* data_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_source_);
  }
  data_source_ = data_source;
  if (data_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.OnLinePositionParam.data_source)
}
inline ::zb::dcts::source::kh::PositionDataSource* OnLinePositionParam::release_data_source() {
  auto temp = unsafe_arena_release_data_source();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::kh::PositionDataSource* OnLinePositionParam::unsafe_arena_release_data_source() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.OnLinePositionParam.data_source)
  
  ::zb::dcts::source::kh::PositionDataSource* temp = data_source_;
  data_source_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::kh::PositionDataSource* OnLinePositionParam::_internal_mutable_data_source() {
  
  if (data_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::kh::PositionDataSource>(GetArena());
    data_source_ = p;
  }
  return data_source_;
}
inline ::zb::dcts::source::kh::PositionDataSource* OnLinePositionParam::mutable_data_source() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.OnLinePositionParam.data_source)
  return _internal_mutable_data_source();
}
inline void OnLinePositionParam::set_allocated_data_source(::zb::dcts::source::kh::PositionDataSource* data_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete data_source_;
  }
  if (data_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(data_source);
    if (message_arena != submessage_arena) {
      data_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_source, submessage_arena);
    }
    
  } else {
    
  }
  data_source_ = data_source;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.OnLinePositionParam.data_source)
}

// -------------------------------------------------------------------

// OffLinePositionParam

// repeated .zb.dcts.source.kh.PositionDataSource data_source = 1;
inline int OffLinePositionParam::_internal_data_source_size() const {
  return data_source_.size();
}
inline int OffLinePositionParam::data_source_size() const {
  return _internal_data_source_size();
}
inline void OffLinePositionParam::clear_data_source() {
  data_source_.Clear();
}
inline ::zb::dcts::source::kh::PositionDataSource* OffLinePositionParam::mutable_data_source(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.OffLinePositionParam.data_source)
  return data_source_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::PositionDataSource >*
OffLinePositionParam::mutable_data_source() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.source.kh.OffLinePositionParam.data_source)
  return &data_source_;
}
inline const ::zb::dcts::source::kh::PositionDataSource& OffLinePositionParam::_internal_data_source(int index) const {
  return data_source_.Get(index);
}
inline const ::zb::dcts::source::kh::PositionDataSource& OffLinePositionParam::data_source(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.OffLinePositionParam.data_source)
  return _internal_data_source(index);
}
inline ::zb::dcts::source::kh::PositionDataSource* OffLinePositionParam::_internal_add_data_source() {
  return data_source_.Add();
}
inline ::zb::dcts::source::kh::PositionDataSource* OffLinePositionParam::add_data_source() {
  // @@protoc_insertion_point(field_add:zb.dcts.source.kh.OffLinePositionParam.data_source)
  return _internal_add_data_source();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::PositionDataSource >&
OffLinePositionParam::data_source() const {
  // @@protoc_insertion_point(field_list:zb.dcts.source.kh.OffLinePositionParam.data_source)
  return data_source_;
}

// -------------------------------------------------------------------

// StartPositionRequest

// .zb.dcts.source.kh.OnLinePositionParam online_param = 1;
inline bool StartPositionRequest::_internal_has_online_param() const {
  return this != internal_default_instance() && online_param_ != nullptr;
}
inline bool StartPositionRequest::has_online_param() const {
  return _internal_has_online_param();
}
inline void StartPositionRequest::clear_online_param() {
  if (GetArena() == nullptr && online_param_ != nullptr) {
    delete online_param_;
  }
  online_param_ = nullptr;
}
inline const ::zb::dcts::source::kh::OnLinePositionParam& StartPositionRequest::_internal_online_param() const {
  const ::zb::dcts::source::kh::OnLinePositionParam* p = online_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::kh::OnLinePositionParam*>(
      &::zb::dcts::source::kh::_OnLinePositionParam_default_instance_);
}
inline const ::zb::dcts::source::kh::OnLinePositionParam& StartPositionRequest::online_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.StartPositionRequest.online_param)
  return _internal_online_param();
}
inline void StartPositionRequest::unsafe_arena_set_allocated_online_param(
    ::zb::dcts::source::kh::OnLinePositionParam* online_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(online_param_);
  }
  online_param_ = online_param;
  if (online_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.StartPositionRequest.online_param)
}
inline ::zb::dcts::source::kh::OnLinePositionParam* StartPositionRequest::release_online_param() {
  auto temp = unsafe_arena_release_online_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::kh::OnLinePositionParam* StartPositionRequest::unsafe_arena_release_online_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.StartPositionRequest.online_param)
  
  ::zb::dcts::source::kh::OnLinePositionParam* temp = online_param_;
  online_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::kh::OnLinePositionParam* StartPositionRequest::_internal_mutable_online_param() {
  
  if (online_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::kh::OnLinePositionParam>(GetArena());
    online_param_ = p;
  }
  return online_param_;
}
inline ::zb::dcts::source::kh::OnLinePositionParam* StartPositionRequest::mutable_online_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.StartPositionRequest.online_param)
  return _internal_mutable_online_param();
}
inline void StartPositionRequest::set_allocated_online_param(::zb::dcts::source::kh::OnLinePositionParam* online_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete online_param_;
  }
  if (online_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(online_param);
    if (message_arena != submessage_arena) {
      online_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, online_param, submessage_arena);
    }
    
  } else {
    
  }
  online_param_ = online_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.StartPositionRequest.online_param)
}

// .zb.dcts.source.kh.OffLinePositionParam offline_param = 2;
inline bool StartPositionRequest::_internal_has_offline_param() const {
  return this != internal_default_instance() && offline_param_ != nullptr;
}
inline bool StartPositionRequest::has_offline_param() const {
  return _internal_has_offline_param();
}
inline void StartPositionRequest::clear_offline_param() {
  if (GetArena() == nullptr && offline_param_ != nullptr) {
    delete offline_param_;
  }
  offline_param_ = nullptr;
}
inline const ::zb::dcts::source::kh::OffLinePositionParam& StartPositionRequest::_internal_offline_param() const {
  const ::zb::dcts::source::kh::OffLinePositionParam* p = offline_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::kh::OffLinePositionParam*>(
      &::zb::dcts::source::kh::_OffLinePositionParam_default_instance_);
}
inline const ::zb::dcts::source::kh::OffLinePositionParam& StartPositionRequest::offline_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.StartPositionRequest.offline_param)
  return _internal_offline_param();
}
inline void StartPositionRequest::unsafe_arena_set_allocated_offline_param(
    ::zb::dcts::source::kh::OffLinePositionParam* offline_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offline_param_);
  }
  offline_param_ = offline_param;
  if (offline_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.StartPositionRequest.offline_param)
}
inline ::zb::dcts::source::kh::OffLinePositionParam* StartPositionRequest::release_offline_param() {
  auto temp = unsafe_arena_release_offline_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::kh::OffLinePositionParam* StartPositionRequest::unsafe_arena_release_offline_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.StartPositionRequest.offline_param)
  
  ::zb::dcts::source::kh::OffLinePositionParam* temp = offline_param_;
  offline_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::kh::OffLinePositionParam* StartPositionRequest::_internal_mutable_offline_param() {
  
  if (offline_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::kh::OffLinePositionParam>(GetArena());
    offline_param_ = p;
  }
  return offline_param_;
}
inline ::zb::dcts::source::kh::OffLinePositionParam* StartPositionRequest::mutable_offline_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.StartPositionRequest.offline_param)
  return _internal_mutable_offline_param();
}
inline void StartPositionRequest::set_allocated_offline_param(::zb::dcts::source::kh::OffLinePositionParam* offline_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete offline_param_;
  }
  if (offline_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(offline_param);
    if (message_arena != submessage_arena) {
      offline_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offline_param, submessage_arena);
    }
    
  } else {
    
  }
  offline_param_ = offline_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.StartPositionRequest.offline_param)
}

// string task_describe = 3;
inline void StartPositionRequest::clear_task_describe() {
  task_describe_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& StartPositionRequest::task_describe() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.StartPositionRequest.task_describe)
  return _internal_task_describe();
}
inline void StartPositionRequest::set_task_describe(const std::string& value) {
  _internal_set_task_describe(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.StartPositionRequest.task_describe)
}
inline std::string* StartPositionRequest::mutable_task_describe() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.StartPositionRequest.task_describe)
  return _internal_mutable_task_describe();
}
inline const std::string& StartPositionRequest::_internal_task_describe() const {
  return task_describe_.Get();
}
inline void StartPositionRequest::_internal_set_task_describe(const std::string& value) {
  
  task_describe_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StartPositionRequest::set_task_describe(std::string&& value) {
  
  task_describe_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.source.kh.StartPositionRequest.task_describe)
}
inline void StartPositionRequest::set_task_describe(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_describe_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.source.kh.StartPositionRequest.task_describe)
}
inline void StartPositionRequest::set_task_describe(const char* value,
    size_t size) {
  
  task_describe_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.source.kh.StartPositionRequest.task_describe)
}
inline std::string* StartPositionRequest::_internal_mutable_task_describe() {
  
  return task_describe_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StartPositionRequest::release_task_describe() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.StartPositionRequest.task_describe)
  return task_describe_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StartPositionRequest::set_allocated_task_describe(std::string* task_describe) {
  if (task_describe != nullptr) {
    
  } else {
    
  }
  task_describe_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_describe,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.StartPositionRequest.task_describe)
}
inline std::string* StartPositionRequest::unsafe_arena_release_task_describe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.source.kh.StartPositionRequest.task_describe)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return task_describe_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void StartPositionRequest::unsafe_arena_set_allocated_task_describe(
    std::string* task_describe) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (task_describe != nullptr) {
    
  } else {
    
  }
  task_describe_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      task_describe, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.StartPositionRequest.task_describe)
}

// double pos_freq = 4;
inline void StartPositionRequest::clear_pos_freq() {
  pos_freq_ = 0;
}
inline double StartPositionRequest::_internal_pos_freq() const {
  return pos_freq_;
}
inline double StartPositionRequest::pos_freq() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.StartPositionRequest.pos_freq)
  return _internal_pos_freq();
}
inline void StartPositionRequest::_internal_set_pos_freq(double value) {
  
  pos_freq_ = value;
}
inline void StartPositionRequest::set_pos_freq(double value) {
  _internal_set_pos_freq(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.StartPositionRequest.pos_freq)
}

// -------------------------------------------------------------------

// TargetSpeed

// double ln_speed = 1;
inline void TargetSpeed::clear_ln_speed() {
  ln_speed_ = 0;
}
inline double TargetSpeed::_internal_ln_speed() const {
  return ln_speed_;
}
inline double TargetSpeed::ln_speed() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TargetSpeed.ln_speed)
  return _internal_ln_speed();
}
inline void TargetSpeed::_internal_set_ln_speed(double value) {
  
  ln_speed_ = value;
}
inline void TargetSpeed::set_ln_speed(double value) {
  _internal_set_ln_speed(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TargetSpeed.ln_speed)
}

// double lt_speed = 2;
inline void TargetSpeed::clear_lt_speed() {
  lt_speed_ = 0;
}
inline double TargetSpeed::_internal_lt_speed() const {
  return lt_speed_;
}
inline double TargetSpeed::lt_speed() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TargetSpeed.lt_speed)
  return _internal_lt_speed();
}
inline void TargetSpeed::_internal_set_lt_speed(double value) {
  
  lt_speed_ = value;
}
inline void TargetSpeed::set_lt_speed(double value) {
  _internal_set_lt_speed(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TargetSpeed.lt_speed)
}

// double alt_speed = 3;
inline void TargetSpeed::clear_alt_speed() {
  alt_speed_ = 0;
}
inline double TargetSpeed::_internal_alt_speed() const {
  return alt_speed_;
}
inline double TargetSpeed::alt_speed() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TargetSpeed.alt_speed)
  return _internal_alt_speed();
}
inline void TargetSpeed::_internal_set_alt_speed(double value) {
  
  alt_speed_ = value;
}
inline void TargetSpeed::set_alt_speed(double value) {
  _internal_set_alt_speed(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TargetSpeed.alt_speed)
}

// -------------------------------------------------------------------

// PositionTargetDescriptor

// uint32 target_id = 1;
inline void PositionTargetDescriptor::clear_target_id() {
  target_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PositionTargetDescriptor::_internal_target_id() const {
  return target_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PositionTargetDescriptor::target_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PositionTargetDescriptor.target_id)
  return _internal_target_id();
}
inline void PositionTargetDescriptor::_internal_set_target_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  target_id_ = value;
}
inline void PositionTargetDescriptor::set_target_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_target_id(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PositionTargetDescriptor.target_id)
}

// .zb.dcts.Position target_position = 2;
inline bool PositionTargetDescriptor::_internal_has_target_position() const {
  return this != internal_default_instance() && target_position_ != nullptr;
}
inline bool PositionTargetDescriptor::has_target_position() const {
  return _internal_has_target_position();
}
inline const ::zb::dcts::Position& PositionTargetDescriptor::_internal_target_position() const {
  const ::zb::dcts::Position* p = target_position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Position*>(
      &::zb::dcts::_Position_default_instance_);
}
inline const ::zb::dcts::Position& PositionTargetDescriptor::target_position() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PositionTargetDescriptor.target_position)
  return _internal_target_position();
}
inline void PositionTargetDescriptor::unsafe_arena_set_allocated_target_position(
    ::zb::dcts::Position* target_position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_position_);
  }
  target_position_ = target_position;
  if (target_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.PositionTargetDescriptor.target_position)
}
inline ::zb::dcts::Position* PositionTargetDescriptor::release_target_position() {
  auto temp = unsafe_arena_release_target_position();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Position* PositionTargetDescriptor::unsafe_arena_release_target_position() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.PositionTargetDescriptor.target_position)
  
  ::zb::dcts::Position* temp = target_position_;
  target_position_ = nullptr;
  return temp;
}
inline ::zb::dcts::Position* PositionTargetDescriptor::_internal_mutable_target_position() {
  
  if (target_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Position>(GetArena());
    target_position_ = p;
  }
  return target_position_;
}
inline ::zb::dcts::Position* PositionTargetDescriptor::mutable_target_position() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.PositionTargetDescriptor.target_position)
  return _internal_mutable_target_position();
}
inline void PositionTargetDescriptor::set_allocated_target_position(::zb::dcts::Position* target_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_position_);
  }
  if (target_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_position)->GetArena();
    if (message_arena != submessage_arena) {
      target_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_position, submessage_arena);
    }
    
  } else {
    
  }
  target_position_ = target_position;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.PositionTargetDescriptor.target_position)
}

// .zb.dcts.source.kh.TargetSpeed target_speed = 3;
inline bool PositionTargetDescriptor::_internal_has_target_speed() const {
  return this != internal_default_instance() && target_speed_ != nullptr;
}
inline bool PositionTargetDescriptor::has_target_speed() const {
  return _internal_has_target_speed();
}
inline void PositionTargetDescriptor::clear_target_speed() {
  if (GetArena() == nullptr && target_speed_ != nullptr) {
    delete target_speed_;
  }
  target_speed_ = nullptr;
}
inline const ::zb::dcts::source::kh::TargetSpeed& PositionTargetDescriptor::_internal_target_speed() const {
  const ::zb::dcts::source::kh::TargetSpeed* p = target_speed_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::kh::TargetSpeed*>(
      &::zb::dcts::source::kh::_TargetSpeed_default_instance_);
}
inline const ::zb::dcts::source::kh::TargetSpeed& PositionTargetDescriptor::target_speed() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PositionTargetDescriptor.target_speed)
  return _internal_target_speed();
}
inline void PositionTargetDescriptor::unsafe_arena_set_allocated_target_speed(
    ::zb::dcts::source::kh::TargetSpeed* target_speed) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_speed_);
  }
  target_speed_ = target_speed;
  if (target_speed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.PositionTargetDescriptor.target_speed)
}
inline ::zb::dcts::source::kh::TargetSpeed* PositionTargetDescriptor::release_target_speed() {
  auto temp = unsafe_arena_release_target_speed();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::kh::TargetSpeed* PositionTargetDescriptor::unsafe_arena_release_target_speed() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.PositionTargetDescriptor.target_speed)
  
  ::zb::dcts::source::kh::TargetSpeed* temp = target_speed_;
  target_speed_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::kh::TargetSpeed* PositionTargetDescriptor::_internal_mutable_target_speed() {
  
  if (target_speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::kh::TargetSpeed>(GetArena());
    target_speed_ = p;
  }
  return target_speed_;
}
inline ::zb::dcts::source::kh::TargetSpeed* PositionTargetDescriptor::mutable_target_speed() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.PositionTargetDescriptor.target_speed)
  return _internal_mutable_target_speed();
}
inline void PositionTargetDescriptor::set_allocated_target_speed(::zb::dcts::source::kh::TargetSpeed* target_speed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete target_speed_;
  }
  if (target_speed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(target_speed);
    if (message_arena != submessage_arena) {
      target_speed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_speed, submessage_arena);
    }
    
  } else {
    
  }
  target_speed_ = target_speed;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.PositionTargetDescriptor.target_speed)
}

// double confidence_interval = 4;
inline void PositionTargetDescriptor::clear_confidence_interval() {
  confidence_interval_ = 0;
}
inline double PositionTargetDescriptor::_internal_confidence_interval() const {
  return confidence_interval_;
}
inline double PositionTargetDescriptor::confidence_interval() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PositionTargetDescriptor.confidence_interval)
  return _internal_confidence_interval();
}
inline void PositionTargetDescriptor::_internal_set_confidence_interval(double value) {
  
  confidence_interval_ = value;
}
inline void PositionTargetDescriptor::set_confidence_interval(double value) {
  _internal_set_confidence_interval(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.PositionTargetDescriptor.confidence_interval)
}

// .zb.dcts.Timestamp time = 5;
inline bool PositionTargetDescriptor::_internal_has_time() const {
  return this != internal_default_instance() && time_ != nullptr;
}
inline bool PositionTargetDescriptor::has_time() const {
  return _internal_has_time();
}
inline const ::zb::dcts::Timestamp& PositionTargetDescriptor::_internal_time() const {
  const ::zb::dcts::Timestamp* p = time_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Timestamp*>(
      &::zb::dcts::_Timestamp_default_instance_);
}
inline const ::zb::dcts::Timestamp& PositionTargetDescriptor::time() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PositionTargetDescriptor.time)
  return _internal_time();
}
inline void PositionTargetDescriptor::unsafe_arena_set_allocated_time(
    ::zb::dcts::Timestamp* time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.PositionTargetDescriptor.time)
}
inline ::zb::dcts::Timestamp* PositionTargetDescriptor::release_time() {
  auto temp = unsafe_arena_release_time();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Timestamp* PositionTargetDescriptor::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.PositionTargetDescriptor.time)
  
  ::zb::dcts::Timestamp* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::zb::dcts::Timestamp* PositionTargetDescriptor::_internal_mutable_time() {
  
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Timestamp>(GetArena());
    time_ = p;
  }
  return time_;
}
inline ::zb::dcts::Timestamp* PositionTargetDescriptor::mutable_time() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.PositionTargetDescriptor.time)
  return _internal_mutable_time();
}
inline void PositionTargetDescriptor::set_allocated_time(::zb::dcts::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time)->GetArena();
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.PositionTargetDescriptor.time)
}

// repeated .zb.dcts.source.kh.DataSource data_source = 7;
inline int PositionTargetDescriptor::_internal_data_source_size() const {
  return data_source_.size();
}
inline int PositionTargetDescriptor::data_source_size() const {
  return _internal_data_source_size();
}
inline void PositionTargetDescriptor::clear_data_source() {
  data_source_.Clear();
}
inline ::zb::dcts::source::kh::DataSource* PositionTargetDescriptor::mutable_data_source(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.PositionTargetDescriptor.data_source)
  return data_source_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::DataSource >*
PositionTargetDescriptor::mutable_data_source() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.source.kh.PositionTargetDescriptor.data_source)
  return &data_source_;
}
inline const ::zb::dcts::source::kh::DataSource& PositionTargetDescriptor::_internal_data_source(int index) const {
  return data_source_.Get(index);
}
inline const ::zb::dcts::source::kh::DataSource& PositionTargetDescriptor::data_source(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.PositionTargetDescriptor.data_source)
  return _internal_data_source(index);
}
inline ::zb::dcts::source::kh::DataSource* PositionTargetDescriptor::_internal_add_data_source() {
  return data_source_.Add();
}
inline ::zb::dcts::source::kh::DataSource* PositionTargetDescriptor::add_data_source() {
  // @@protoc_insertion_point(field_add:zb.dcts.source.kh.PositionTargetDescriptor.data_source)
  return _internal_add_data_source();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::source::kh::DataSource >&
PositionTargetDescriptor::data_source() const {
  // @@protoc_insertion_point(field_list:zb.dcts.source.kh.PositionTargetDescriptor.data_source)
  return data_source_;
}

// -------------------------------------------------------------------

// TimeTriggerParam

// .zb.dcts.source.kh.TimeTriggerParam.TriggerType trigger_type = 1;
inline void TimeTriggerParam::clear_trigger_type() {
  trigger_type_ = 0;
}
inline ::zb::dcts::source::kh::TimeTriggerParam_TriggerType TimeTriggerParam::_internal_trigger_type() const {
  return static_cast< ::zb::dcts::source::kh::TimeTriggerParam_TriggerType >(trigger_type_);
}
inline ::zb::dcts::source::kh::TimeTriggerParam_TriggerType TimeTriggerParam::trigger_type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TimeTriggerParam.trigger_type)
  return _internal_trigger_type();
}
inline void TimeTriggerParam::_internal_set_trigger_type(::zb::dcts::source::kh::TimeTriggerParam_TriggerType value) {
  
  trigger_type_ = value;
}
inline void TimeTriggerParam::set_trigger_type(::zb::dcts::source::kh::TimeTriggerParam_TriggerType value) {
  _internal_set_trigger_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TimeTriggerParam.trigger_type)
}

// .zb.dcts.Timestamp trigger_time = 2;
inline bool TimeTriggerParam::_internal_has_trigger_time() const {
  return this != internal_default_instance() && trigger_time_ != nullptr;
}
inline bool TimeTriggerParam::has_trigger_time() const {
  return _internal_has_trigger_time();
}
inline const ::zb::dcts::Timestamp& TimeTriggerParam::_internal_trigger_time() const {
  const ::zb::dcts::Timestamp* p = trigger_time_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Timestamp*>(
      &::zb::dcts::_Timestamp_default_instance_);
}
inline const ::zb::dcts::Timestamp& TimeTriggerParam::trigger_time() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TimeTriggerParam.trigger_time)
  return _internal_trigger_time();
}
inline void TimeTriggerParam::unsafe_arena_set_allocated_trigger_time(
    ::zb::dcts::Timestamp* trigger_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trigger_time_);
  }
  trigger_time_ = trigger_time;
  if (trigger_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.source.kh.TimeTriggerParam.trigger_time)
}
inline ::zb::dcts::Timestamp* TimeTriggerParam::release_trigger_time() {
  auto temp = unsafe_arena_release_trigger_time();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Timestamp* TimeTriggerParam::unsafe_arena_release_trigger_time() {
  // @@protoc_insertion_point(field_release:zb.dcts.source.kh.TimeTriggerParam.trigger_time)
  
  ::zb::dcts::Timestamp* temp = trigger_time_;
  trigger_time_ = nullptr;
  return temp;
}
inline ::zb::dcts::Timestamp* TimeTriggerParam::_internal_mutable_trigger_time() {
  
  if (trigger_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Timestamp>(GetArena());
    trigger_time_ = p;
  }
  return trigger_time_;
}
inline ::zb::dcts::Timestamp* TimeTriggerParam::mutable_trigger_time() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.source.kh.TimeTriggerParam.trigger_time)
  return _internal_mutable_trigger_time();
}
inline void TimeTriggerParam::set_allocated_trigger_time(::zb::dcts::Timestamp* trigger_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(trigger_time_);
  }
  if (trigger_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trigger_time)->GetArena();
    if (message_arena != submessage_arena) {
      trigger_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trigger_time, submessage_arena);
    }
    
  } else {
    
  }
  trigger_time_ = trigger_time;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.source.kh.TimeTriggerParam.trigger_time)
}

// uint32 sweep_interval = 3;
inline void TimeTriggerParam::clear_sweep_interval() {
  sweep_interval_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TimeTriggerParam::_internal_sweep_interval() const {
  return sweep_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TimeTriggerParam::sweep_interval() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TimeTriggerParam.sweep_interval)
  return _internal_sweep_interval();
}
inline void TimeTriggerParam::_internal_set_sweep_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sweep_interval_ = value;
}
inline void TimeTriggerParam::set_sweep_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sweep_interval(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TimeTriggerParam.sweep_interval)
}

// uint32 segment_interval = 4;
inline void TimeTriggerParam::clear_segment_interval() {
  segment_interval_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TimeTriggerParam::_internal_segment_interval() const {
  return segment_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TimeTriggerParam::segment_interval() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.TimeTriggerParam.segment_interval)
  return _internal_segment_interval();
}
inline void TimeTriggerParam::_internal_set_segment_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  segment_interval_ = value;
}
inline void TimeTriggerParam::set_segment_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_segment_interval(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.TimeTriggerParam.segment_interval)
}

// -------------------------------------------------------------------

// FreqTriggerParam

// .zb.dcts.source.kh.FreqTriggerParam.TriggerType trigger_type = 1;
inline void FreqTriggerParam::clear_trigger_type() {
  trigger_type_ = 0;
}
inline ::zb::dcts::source::kh::FreqTriggerParam_TriggerType FreqTriggerParam::_internal_trigger_type() const {
  return static_cast< ::zb::dcts::source::kh::FreqTriggerParam_TriggerType >(trigger_type_);
}
inline ::zb::dcts::source::kh::FreqTriggerParam_TriggerType FreqTriggerParam::trigger_type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.FreqTriggerParam.trigger_type)
  return _internal_trigger_type();
}
inline void FreqTriggerParam::_internal_set_trigger_type(::zb::dcts::source::kh::FreqTriggerParam_TriggerType value) {
  
  trigger_type_ = value;
}
inline void FreqTriggerParam::set_trigger_type(::zb::dcts::source::kh::FreqTriggerParam_TriggerType value) {
  _internal_set_trigger_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.FreqTriggerParam.trigger_type)
}

// float trigger_value = 2;
inline void FreqTriggerParam::clear_trigger_value() {
  trigger_value_ = 0;
}
inline float FreqTriggerParam::_internal_trigger_value() const {
  return trigger_value_;
}
inline float FreqTriggerParam::trigger_value() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.FreqTriggerParam.trigger_value)
  return _internal_trigger_value();
}
inline void FreqTriggerParam::_internal_set_trigger_value(float value) {
  
  trigger_value_ = value;
}
inline void FreqTriggerParam::set_trigger_value(float value) {
  _internal_set_trigger_value(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.FreqTriggerParam.trigger_value)
}

// -------------------------------------------------------------------

// LevelTriggerParam

// .zb.dcts.source.kh.LevelTriggerParam.TriggerType trigger_type = 1;
inline void LevelTriggerParam::clear_trigger_type() {
  trigger_type_ = 0;
}
inline ::zb::dcts::source::kh::LevelTriggerParam_TriggerType LevelTriggerParam::_internal_trigger_type() const {
  return static_cast< ::zb::dcts::source::kh::LevelTriggerParam_TriggerType >(trigger_type_);
}
inline ::zb::dcts::source::kh::LevelTriggerParam_TriggerType LevelTriggerParam::trigger_type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.LevelTriggerParam.trigger_type)
  return _internal_trigger_type();
}
inline void LevelTriggerParam::_internal_set_trigger_type(::zb::dcts::source::kh::LevelTriggerParam_TriggerType value) {
  
  trigger_type_ = value;
}
inline void LevelTriggerParam::set_trigger_type(::zb::dcts::source::kh::LevelTriggerParam_TriggerType value) {
  _internal_set_trigger_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.LevelTriggerParam.trigger_type)
}

// float trigger_value = 2;
inline void LevelTriggerParam::clear_trigger_value() {
  trigger_value_ = 0;
}
inline float LevelTriggerParam::_internal_trigger_value() const {
  return trigger_value_;
}
inline float LevelTriggerParam::trigger_value() const {
  // @@protoc_insertion_point(field_get:zb.dcts.source.kh.LevelTriggerParam.trigger_value)
  return _internal_trigger_value();
}
inline void LevelTriggerParam::_internal_set_trigger_value(float value) {
  
  trigger_value_ = value;
}
inline void LevelTriggerParam::set_trigger_value(float value) {
  _internal_set_trigger_value(value);
  // @@protoc_insertion_point(field_set:zb.dcts.source.kh.LevelTriggerParam.trigger_value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kh
}  // namespace source
}  // namespace dcts
}  // namespace zb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zb::dcts::source::kh::TimeTriggerParam_TriggerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::TimeTriggerParam_TriggerType>() {
  return ::zb::dcts::source::kh::TimeTriggerParam_TriggerType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::FreqTriggerParam_TriggerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::FreqTriggerParam_TriggerType>() {
  return ::zb::dcts::source::kh::FreqTriggerParam_TriggerType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::LevelTriggerParam_TriggerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::LevelTriggerParam_TriggerType>() {
  return ::zb::dcts::source::kh::LevelTriggerParam_TriggerType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::SourceControlCmd> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::SourceControlCmd>() {
  return ::zb::dcts::source::kh::SourceControlCmd_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::DetectMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::DetectMode>() {
  return ::zb::dcts::source::kh::DetectMode_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::FFTDetectMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::FFTDetectMode>() {
  return ::zb::dcts::source::kh::FFTDetectMode_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::ChannelMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::ChannelMode>() {
  return ::zb::dcts::source::kh::ChannelMode_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::WindowType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::WindowType>() {
  return ::zb::dcts::source::kh::WindowType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::AntennaControlMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::AntennaControlMode>() {
  return ::zb::dcts::source::kh::AntennaControlMode_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::GainControlMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::GainControlMode>() {
  return ::zb::dcts::source::kh::GainControlMode_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::ThresholdMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::ThresholdMode>() {
  return ::zb::dcts::source::kh::ThresholdMode_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::DataType>() {
  return ::zb::dcts::source::kh::DataType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::source::kh::LinkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::source::kh::LinkType>() {
  return ::zb::dcts::source::kh::LinkType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_source_2fkh_2fKhContext_2eproto
