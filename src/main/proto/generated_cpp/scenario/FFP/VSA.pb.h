// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scenario/FFP/VSA.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scenario_2fFFP_2fVSA_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scenario_2fFFP_2fVSA_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dcts.pb.h"
#include "source/source.pb.h"
#include "scenario/scenario.pb.h"
#include "scenario/spectrum.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scenario_2fFFP_2fVSA_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scenario_2fFFP_2fVSA_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scenario_2fFFP_2fVSA_2eproto;
namespace zb {
namespace dcts {
namespace scenario {
namespace FFP {
class BaseParam;
class BaseParamDefaultTypeInternal;
extern BaseParamDefaultTypeInternal _BaseParam_default_instance_;
class ChannelizerParam;
class ChannelizerParamDefaultTypeInternal;
extern ChannelizerParamDefaultTypeInternal _ChannelizerParam_default_instance_;
class FSKParam;
class FSKParamDefaultTypeInternal;
extern FSKParamDefaultTypeInternal _FSKParam_default_instance_;
class IQData;
class IQDataDefaultTypeInternal;
extern IQDataDefaultTypeInternal _IQData_default_instance_;
class OOKParam;
class OOKParamDefaultTypeInternal;
extern OOKParamDefaultTypeInternal _OOKParam_default_instance_;
class PSKParam;
class PSKParamDefaultTypeInternal;
extern PSKParamDefaultTypeInternal _PSKParam_default_instance_;
class PulseShapingFilter;
class PulseShapingFilterDefaultTypeInternal;
extern PulseShapingFilterDefaultTypeInternal _PulseShapingFilter_default_instance_;
class VSAParam;
class VSAParamDefaultTypeInternal;
extern VSAParamDefaultTypeInternal _VSAParam_default_instance_;
class VSARequest;
class VSARequestDefaultTypeInternal;
extern VSARequestDefaultTypeInternal _VSARequest_default_instance_;
class VSAResult;
class VSAResultDefaultTypeInternal;
extern VSAResultDefaultTypeInternal _VSAResult_default_instance_;
class VSAResult_Header;
class VSAResult_HeaderDefaultTypeInternal;
extern VSAResult_HeaderDefaultTypeInternal _VSAResult_Header_default_instance_;
class VSASource;
class VSASourceDefaultTypeInternal;
extern VSASourceDefaultTypeInternal _VSASource_default_instance_;
}  // namespace FFP
}  // namespace scenario
}  // namespace dcts
}  // namespace zb
PROTOBUF_NAMESPACE_OPEN
template<> ::zb::dcts::scenario::FFP::BaseParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::BaseParam>(Arena*);
template<> ::zb::dcts::scenario::FFP::ChannelizerParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::ChannelizerParam>(Arena*);
template<> ::zb::dcts::scenario::FFP::FSKParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::FSKParam>(Arena*);
template<> ::zb::dcts::scenario::FFP::IQData* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::IQData>(Arena*);
template<> ::zb::dcts::scenario::FFP::OOKParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::OOKParam>(Arena*);
template<> ::zb::dcts::scenario::FFP::PSKParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::PSKParam>(Arena*);
template<> ::zb::dcts::scenario::FFP::PulseShapingFilter* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::PulseShapingFilter>(Arena*);
template<> ::zb::dcts::scenario::FFP::VSAParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::VSAParam>(Arena*);
template<> ::zb::dcts::scenario::FFP::VSARequest* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::VSARequest>(Arena*);
template<> ::zb::dcts::scenario::FFP::VSAResult* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::VSAResult>(Arena*);
template<> ::zb::dcts::scenario::FFP::VSAResult_Header* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::VSAResult_Header>(Arena*);
template<> ::zb::dcts::scenario::FFP::VSASource* Arena::CreateMaybeMessage<::zb::dcts::scenario::FFP::VSASource>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zb {
namespace dcts {
namespace scenario {
namespace FFP {

enum PulseShapingFilter_Type : int {
  PulseShapingFilter_Type_NONE = 0,
  PulseShapingFilter_Type_RRC = 1,
  PulseShapingFilter_Type_PulseShapingFilter_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PulseShapingFilter_Type_PulseShapingFilter_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PulseShapingFilter_Type_IsValid(int value);
constexpr PulseShapingFilter_Type PulseShapingFilter_Type_Type_MIN = PulseShapingFilter_Type_NONE;
constexpr PulseShapingFilter_Type PulseShapingFilter_Type_Type_MAX = PulseShapingFilter_Type_RRC;
constexpr int PulseShapingFilter_Type_Type_ARRAYSIZE = PulseShapingFilter_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PulseShapingFilter_Type_descriptor();
template<typename T>
inline const std::string& PulseShapingFilter_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PulseShapingFilter_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PulseShapingFilter_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PulseShapingFilter_Type_descriptor(), enum_t_value);
}
inline bool PulseShapingFilter_Type_Parse(
    const std::string& name, PulseShapingFilter_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PulseShapingFilter_Type>(
    PulseShapingFilter_Type_descriptor(), name, value);
}
enum DigitalDemodType : int {
  OOK = 0,
  FSK2 = 1,
  FSK4 = 2,
  FSK8 = 3,
  FSK16 = 4,
  MSK = 5,
  BPSK = 6,
  QPSK = 7,
  CQPSK = 8,
  PSK8 = 9,
  PSK16 = 10,
  PI4QPSK = 11,
  PI4DQPSK = 12,
  QAM16 = 16,
  QAM32 = 17,
  QAM64 = 18,
  ASK = 21,
  ASK2 = 22,
  ASK4 = 23,
  DigitalDemodType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DigitalDemodType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DigitalDemodType_IsValid(int value);
constexpr DigitalDemodType DigitalDemodType_MIN = OOK;
constexpr DigitalDemodType DigitalDemodType_MAX = ASK4;
constexpr int DigitalDemodType_ARRAYSIZE = DigitalDemodType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DigitalDemodType_descriptor();
template<typename T>
inline const std::string& DigitalDemodType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DigitalDemodType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DigitalDemodType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DigitalDemodType_descriptor(), enum_t_value);
}
inline bool DigitalDemodType_Parse(
    const std::string& name, DigitalDemodType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DigitalDemodType>(
    DigitalDemodType_descriptor(), name, value);
}
enum DataType : int {
  COMPLEX_F32 = 0,
  COMPLEX_I32 = 1,
  COMPLEX_I16 = 2,
  REAL_I16 = 3,
  REAL_F32 = 4,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = COMPLEX_F32;
constexpr DataType DataType_MAX = REAL_F32;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    const std::string& name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class VSASource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.VSASource) */ {
 public:
  inline VSASource() : VSASource(nullptr) {};
  virtual ~VSASource();

  VSASource(const VSASource& from);
  VSASource(VSASource&& from) noexcept
    : VSASource() {
    *this = ::std::move(from);
  }

  inline VSASource& operator=(const VSASource& from) {
    CopyFrom(from);
    return *this;
  }
  inline VSASource& operator=(VSASource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VSASource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VSASource* internal_default_instance() {
    return reinterpret_cast<const VSASource*>(
               &_VSASource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VSASource& a, VSASource& b) {
    a.Swap(&b);
  }
  inline void Swap(VSASource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VSASource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VSASource* New() const final {
    return CreateMaybeMessage<VSASource>(nullptr);
  }

  VSASource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VSASource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VSASource& from);
  void MergeFrom(const VSASource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VSASource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.VSASource";
  }
  protected:
  explicit VSASource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 2,
    kIdFieldNumber = 1,
    kAttenuationGainFieldNumber = 3,
    kAntennaFieldNumber = 4,
  };
  // string address = 2;
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_address(
      std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // .zb.dcts.source.SourceId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::zb::dcts::source::SourceId& id() const;
  ::zb::dcts::source::SourceId* release_id();
  ::zb::dcts::source::SourceId* mutable_id();
  void set_allocated_id(::zb::dcts::source::SourceId* id);
  private:
  const ::zb::dcts::source::SourceId& _internal_id() const;
  ::zb::dcts::source::SourceId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::zb::dcts::source::SourceId* id);
  ::zb::dcts::source::SourceId* unsafe_arena_release_id();

  // int32 attenuation_gain = 3;
  void clear_attenuation_gain();
  ::PROTOBUF_NAMESPACE_ID::int32 attenuation_gain() const;
  void set_attenuation_gain(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attenuation_gain() const;
  void _internal_set_attenuation_gain(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 antenna = 4;
  void clear_antenna();
  ::PROTOBUF_NAMESPACE_ID::int32 antenna() const;
  void set_antenna(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_antenna() const;
  void _internal_set_antenna(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.VSASource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::zb::dcts::source::SourceId* id_;
  ::PROTOBUF_NAMESPACE_ID::int32 attenuation_gain_;
  ::PROTOBUF_NAMESPACE_ID::int32 antenna_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class ChannelizerParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.ChannelizerParam) */ {
 public:
  inline ChannelizerParam() : ChannelizerParam(nullptr) {};
  virtual ~ChannelizerParam();

  ChannelizerParam(const ChannelizerParam& from);
  ChannelizerParam(ChannelizerParam&& from) noexcept
    : ChannelizerParam() {
    *this = ::std::move(from);
  }

  inline ChannelizerParam& operator=(const ChannelizerParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelizerParam& operator=(ChannelizerParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelizerParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelizerParam* internal_default_instance() {
    return reinterpret_cast<const ChannelizerParam*>(
               &_ChannelizerParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChannelizerParam& a, ChannelizerParam& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelizerParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelizerParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelizerParam* New() const final {
    return CreateMaybeMessage<ChannelizerParam>(nullptr);
  }

  ChannelizerParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelizerParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelizerParam& from);
  void MergeFrom(const ChannelizerParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelizerParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.ChannelizerParam";
  }
  protected:
  explicit ChannelizerParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBankSampleRateFieldNumber = 1,
    kChFrequencyFieldNumber = 2,
    kChSampleRateFieldNumber = 3,
    kChBandwidthFieldNumber = 4,
    kDecimationFieldNumber = 5,
  };
  // double bankSampleRate = 1;
  void clear_banksamplerate();
  double banksamplerate() const;
  void set_banksamplerate(double value);
  private:
  double _internal_banksamplerate() const;
  void _internal_set_banksamplerate(double value);
  public:

  // double chFrequency = 2;
  void clear_chfrequency();
  double chfrequency() const;
  void set_chfrequency(double value);
  private:
  double _internal_chfrequency() const;
  void _internal_set_chfrequency(double value);
  public:

  // double chSampleRate = 3;
  void clear_chsamplerate();
  double chsamplerate() const;
  void set_chsamplerate(double value);
  private:
  double _internal_chsamplerate() const;
  void _internal_set_chsamplerate(double value);
  public:

  // double chBandwidth = 4;
  void clear_chbandwidth();
  double chbandwidth() const;
  void set_chbandwidth(double value);
  private:
  double _internal_chbandwidth() const;
  void _internal_set_chbandwidth(double value);
  public:

  // uint32 decimation = 5;
  void clear_decimation();
  ::PROTOBUF_NAMESPACE_ID::uint32 decimation() const;
  void set_decimation(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_decimation() const;
  void _internal_set_decimation(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.ChannelizerParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double banksamplerate_;
  double chfrequency_;
  double chsamplerate_;
  double chbandwidth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 decimation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class PulseShapingFilter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.PulseShapingFilter) */ {
 public:
  inline PulseShapingFilter() : PulseShapingFilter(nullptr) {};
  virtual ~PulseShapingFilter();

  PulseShapingFilter(const PulseShapingFilter& from);
  PulseShapingFilter(PulseShapingFilter&& from) noexcept
    : PulseShapingFilter() {
    *this = ::std::move(from);
  }

  inline PulseShapingFilter& operator=(const PulseShapingFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline PulseShapingFilter& operator=(PulseShapingFilter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PulseShapingFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PulseShapingFilter* internal_default_instance() {
    return reinterpret_cast<const PulseShapingFilter*>(
               &_PulseShapingFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PulseShapingFilter& a, PulseShapingFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(PulseShapingFilter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PulseShapingFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PulseShapingFilter* New() const final {
    return CreateMaybeMessage<PulseShapingFilter>(nullptr);
  }

  PulseShapingFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PulseShapingFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PulseShapingFilter& from);
  void MergeFrom(const PulseShapingFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PulseShapingFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.PulseShapingFilter";
  }
  protected:
  explicit PulseShapingFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PulseShapingFilter_Type Type;
  static constexpr Type NONE =
    PulseShapingFilter_Type_NONE;
  static constexpr Type RRC =
    PulseShapingFilter_Type_RRC;
  static inline bool Type_IsValid(int value) {
    return PulseShapingFilter_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    PulseShapingFilter_Type_Type_MIN;
  static constexpr Type Type_MAX =
    PulseShapingFilter_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    PulseShapingFilter_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return PulseShapingFilter_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return PulseShapingFilter_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return PulseShapingFilter_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kExceedBwFieldNumber = 2,
  };
  // .zb.dcts.scenario.FFP.PulseShapingFilter.Type type = 1;
  void clear_type();
  ::zb::dcts::scenario::FFP::PulseShapingFilter_Type type() const;
  void set_type(::zb::dcts::scenario::FFP::PulseShapingFilter_Type value);
  private:
  ::zb::dcts::scenario::FFP::PulseShapingFilter_Type _internal_type() const;
  void _internal_set_type(::zb::dcts::scenario::FFP::PulseShapingFilter_Type value);
  public:

  // float exceedBw = 2;
  void clear_exceedbw();
  float exceedbw() const;
  void set_exceedbw(float value);
  private:
  float _internal_exceedbw() const;
  void _internal_set_exceedbw(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.PulseShapingFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  float exceedbw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class BaseParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.BaseParam) */ {
 public:
  inline BaseParam() : BaseParam(nullptr) {};
  virtual ~BaseParam();

  BaseParam(const BaseParam& from);
  BaseParam(BaseParam&& from) noexcept
    : BaseParam() {
    *this = ::std::move(from);
  }

  inline BaseParam& operator=(const BaseParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseParam& operator=(BaseParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BaseParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BaseParam* internal_default_instance() {
    return reinterpret_cast<const BaseParam*>(
               &_BaseParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BaseParam& a, BaseParam& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaseParam* New() const final {
    return CreateMaybeMessage<BaseParam>(nullptr);
  }

  BaseParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaseParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BaseParam& from);
  void MergeFrom(const BaseParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.BaseParam";
  }
  protected:
  explicit BaseParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChParamFieldNumber = 3,
    kFilterFieldNumber = 4,
    kDataTypeFieldNumber = 2,
    kSamplesPerSymbolFieldNumber = 5,
    kMinOutputSizeFieldNumber = 6,
  };
  // .zb.dcts.scenario.FFP.ChannelizerParam chParam = 3;
  bool has_chparam() const;
  private:
  bool _internal_has_chparam() const;
  public:
  void clear_chparam();
  const ::zb::dcts::scenario::FFP::ChannelizerParam& chparam() const;
  ::zb::dcts::scenario::FFP::ChannelizerParam* release_chparam();
  ::zb::dcts::scenario::FFP::ChannelizerParam* mutable_chparam();
  void set_allocated_chparam(::zb::dcts::scenario::FFP::ChannelizerParam* chparam);
  private:
  const ::zb::dcts::scenario::FFP::ChannelizerParam& _internal_chparam() const;
  ::zb::dcts::scenario::FFP::ChannelizerParam* _internal_mutable_chparam();
  public:
  void unsafe_arena_set_allocated_chparam(
      ::zb::dcts::scenario::FFP::ChannelizerParam* chparam);
  ::zb::dcts::scenario::FFP::ChannelizerParam* unsafe_arena_release_chparam();

  // .zb.dcts.scenario.FFP.PulseShapingFilter filter = 4;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::zb::dcts::scenario::FFP::PulseShapingFilter& filter() const;
  ::zb::dcts::scenario::FFP::PulseShapingFilter* release_filter();
  ::zb::dcts::scenario::FFP::PulseShapingFilter* mutable_filter();
  void set_allocated_filter(::zb::dcts::scenario::FFP::PulseShapingFilter* filter);
  private:
  const ::zb::dcts::scenario::FFP::PulseShapingFilter& _internal_filter() const;
  ::zb::dcts::scenario::FFP::PulseShapingFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::zb::dcts::scenario::FFP::PulseShapingFilter* filter);
  ::zb::dcts::scenario::FFP::PulseShapingFilter* unsafe_arena_release_filter();

  // .zb.dcts.scenario.FFP.DataType dataType = 2;
  void clear_datatype();
  ::zb::dcts::scenario::FFP::DataType datatype() const;
  void set_datatype(::zb::dcts::scenario::FFP::DataType value);
  private:
  ::zb::dcts::scenario::FFP::DataType _internal_datatype() const;
  void _internal_set_datatype(::zb::dcts::scenario::FFP::DataType value);
  public:

  // float samplesPerSymbol = 5;
  void clear_samplespersymbol();
  float samplespersymbol() const;
  void set_samplespersymbol(float value);
  private:
  float _internal_samplespersymbol() const;
  void _internal_set_samplespersymbol(float value);
  public:

  // uint32 minOutputSize = 6;
  void clear_minoutputsize();
  ::PROTOBUF_NAMESPACE_ID::uint32 minoutputsize() const;
  void set_minoutputsize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_minoutputsize() const;
  void _internal_set_minoutputsize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.BaseParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::FFP::ChannelizerParam* chparam_;
  ::zb::dcts::scenario::FFP::PulseShapingFilter* filter_;
  int datatype_;
  float samplespersymbol_;
  ::PROTOBUF_NAMESPACE_ID::uint32 minoutputsize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class OOKParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.OOKParam) */ {
 public:
  inline OOKParam() : OOKParam(nullptr) {};
  virtual ~OOKParam();

  OOKParam(const OOKParam& from);
  OOKParam(OOKParam&& from) noexcept
    : OOKParam() {
    *this = ::std::move(from);
  }

  inline OOKParam& operator=(const OOKParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline OOKParam& operator=(OOKParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OOKParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OOKParam* internal_default_instance() {
    return reinterpret_cast<const OOKParam*>(
               &_OOKParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OOKParam& a, OOKParam& b) {
    a.Swap(&b);
  }
  inline void Swap(OOKParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OOKParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OOKParam* New() const final {
    return CreateMaybeMessage<OOKParam>(nullptr);
  }

  OOKParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OOKParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OOKParam& from);
  void MergeFrom(const OOKParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OOKParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.OOKParam";
  }
  protected:
  explicit OOKParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseParamFieldNumber = 1,
    kThresholdFieldNumber = 2,
  };
  // .zb.dcts.scenario.FFP.BaseParam baseParam = 1;
  bool has_baseparam() const;
  private:
  bool _internal_has_baseparam() const;
  public:
  void clear_baseparam();
  const ::zb::dcts::scenario::FFP::BaseParam& baseparam() const;
  ::zb::dcts::scenario::FFP::BaseParam* release_baseparam();
  ::zb::dcts::scenario::FFP::BaseParam* mutable_baseparam();
  void set_allocated_baseparam(::zb::dcts::scenario::FFP::BaseParam* baseparam);
  private:
  const ::zb::dcts::scenario::FFP::BaseParam& _internal_baseparam() const;
  ::zb::dcts::scenario::FFP::BaseParam* _internal_mutable_baseparam();
  public:
  void unsafe_arena_set_allocated_baseparam(
      ::zb::dcts::scenario::FFP::BaseParam* baseparam);
  ::zb::dcts::scenario::FFP::BaseParam* unsafe_arena_release_baseparam();

  // float threshold = 2;
  void clear_threshold();
  float threshold() const;
  void set_threshold(float value);
  private:
  float _internal_threshold() const;
  void _internal_set_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.OOKParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::FFP::BaseParam* baseparam_;
  float threshold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class FSKParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.FSKParam) */ {
 public:
  inline FSKParam() : FSKParam(nullptr) {};
  virtual ~FSKParam();

  FSKParam(const FSKParam& from);
  FSKParam(FSKParam&& from) noexcept
    : FSKParam() {
    *this = ::std::move(from);
  }

  inline FSKParam& operator=(const FSKParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline FSKParam& operator=(FSKParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FSKParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FSKParam* internal_default_instance() {
    return reinterpret_cast<const FSKParam*>(
               &_FSKParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FSKParam& a, FSKParam& b) {
    a.Swap(&b);
  }
  inline void Swap(FSKParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FSKParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FSKParam* New() const final {
    return CreateMaybeMessage<FSKParam>(nullptr);
  }

  FSKParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FSKParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FSKParam& from);
  void MergeFrom(const FSKParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FSKParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.FSKParam";
  }
  protected:
  explicit FSKParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseParamFieldNumber = 1,
    kMaxDevFieldNumber = 2,
  };
  // .zb.dcts.scenario.FFP.BaseParam baseParam = 1;
  bool has_baseparam() const;
  private:
  bool _internal_has_baseparam() const;
  public:
  void clear_baseparam();
  const ::zb::dcts::scenario::FFP::BaseParam& baseparam() const;
  ::zb::dcts::scenario::FFP::BaseParam* release_baseparam();
  ::zb::dcts::scenario::FFP::BaseParam* mutable_baseparam();
  void set_allocated_baseparam(::zb::dcts::scenario::FFP::BaseParam* baseparam);
  private:
  const ::zb::dcts::scenario::FFP::BaseParam& _internal_baseparam() const;
  ::zb::dcts::scenario::FFP::BaseParam* _internal_mutable_baseparam();
  public:
  void unsafe_arena_set_allocated_baseparam(
      ::zb::dcts::scenario::FFP::BaseParam* baseparam);
  ::zb::dcts::scenario::FFP::BaseParam* unsafe_arena_release_baseparam();

  // float maxDev = 2;
  void clear_maxdev();
  float maxdev() const;
  void set_maxdev(float value);
  private:
  float _internal_maxdev() const;
  void _internal_set_maxdev(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.FSKParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::FFP::BaseParam* baseparam_;
  float maxdev_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class PSKParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.PSKParam) */ {
 public:
  inline PSKParam() : PSKParam(nullptr) {};
  virtual ~PSKParam();

  PSKParam(const PSKParam& from);
  PSKParam(PSKParam&& from) noexcept
    : PSKParam() {
    *this = ::std::move(from);
  }

  inline PSKParam& operator=(const PSKParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline PSKParam& operator=(PSKParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PSKParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PSKParam* internal_default_instance() {
    return reinterpret_cast<const PSKParam*>(
               &_PSKParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PSKParam& a, PSKParam& b) {
    a.Swap(&b);
  }
  inline void Swap(PSKParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PSKParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PSKParam* New() const final {
    return CreateMaybeMessage<PSKParam>(nullptr);
  }

  PSKParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PSKParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PSKParam& from);
  void MergeFrom(const PSKParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PSKParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.PSKParam";
  }
  protected:
  explicit PSKParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseParamFieldNumber = 1,
  };
  // .zb.dcts.scenario.FFP.BaseParam baseParam = 1;
  bool has_baseparam() const;
  private:
  bool _internal_has_baseparam() const;
  public:
  void clear_baseparam();
  const ::zb::dcts::scenario::FFP::BaseParam& baseparam() const;
  ::zb::dcts::scenario::FFP::BaseParam* release_baseparam();
  ::zb::dcts::scenario::FFP::BaseParam* mutable_baseparam();
  void set_allocated_baseparam(::zb::dcts::scenario::FFP::BaseParam* baseparam);
  private:
  const ::zb::dcts::scenario::FFP::BaseParam& _internal_baseparam() const;
  ::zb::dcts::scenario::FFP::BaseParam* _internal_mutable_baseparam();
  public:
  void unsafe_arena_set_allocated_baseparam(
      ::zb::dcts::scenario::FFP::BaseParam* baseparam);
  ::zb::dcts::scenario::FFP::BaseParam* unsafe_arena_release_baseparam();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.PSKParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::FFP::BaseParam* baseparam_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class IQData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.IQData) */ {
 public:
  inline IQData() : IQData(nullptr) {};
  virtual ~IQData();

  IQData(const IQData& from);
  IQData(IQData&& from) noexcept
    : IQData() {
    *this = ::std::move(from);
  }

  inline IQData& operator=(const IQData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IQData& operator=(IQData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IQData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IQData* internal_default_instance() {
    return reinterpret_cast<const IQData*>(
               &_IQData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(IQData& a, IQData& b) {
    a.Swap(&b);
  }
  inline void Swap(IQData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IQData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IQData* New() const final {
    return CreateMaybeMessage<IQData>(nullptr);
  }

  IQData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IQData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IQData& from);
  void MergeFrom(const IQData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IQData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.IQData";
  }
  protected:
  explicit IQData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataIFieldNumber = 1,
    kDataQFieldNumber = 2,
  };
  // repeated float data_i = 1;
  int data_i_size() const;
  private:
  int _internal_data_i_size() const;
  public:
  void clear_data_i();
  private:
  float _internal_data_i(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data_i() const;
  void _internal_add_data_i(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data_i();
  public:
  float data_i(int index) const;
  void set_data_i(int index, float value);
  void add_data_i(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data_i() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data_i();

  // repeated float data_q = 2;
  int data_q_size() const;
  private:
  int _internal_data_q_size() const;
  public:
  void clear_data_q();
  private:
  float _internal_data_q(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data_q() const;
  void _internal_add_data_q(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data_q();
  public:
  float data_q(int index) const;
  void set_data_q(int index, float value);
  void add_data_q(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data_q() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data_q();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.IQData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_i_;
  mutable std::atomic<int> _data_i_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_q_;
  mutable std::atomic<int> _data_q_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class VSAParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.VSAParam) */ {
 public:
  inline VSAParam() : VSAParam(nullptr) {};
  virtual ~VSAParam();

  VSAParam(const VSAParam& from);
  VSAParam(VSAParam&& from) noexcept
    : VSAParam() {
    *this = ::std::move(from);
  }

  inline VSAParam& operator=(const VSAParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline VSAParam& operator=(VSAParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VSAParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VSAParam* internal_default_instance() {
    return reinterpret_cast<const VSAParam*>(
               &_VSAParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VSAParam& a, VSAParam& b) {
    a.Swap(&b);
  }
  inline void Swap(VSAParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VSAParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VSAParam* New() const final {
    return CreateMaybeMessage<VSAParam>(nullptr);
  }

  VSAParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VSAParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VSAParam& from);
  void MergeFrom(const VSAParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VSAParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.VSAParam";
  }
  protected:
  explicit VSAParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBankFieldNumber = 1,
    kOokParamFieldNumber = 3,
    kFskParamFieldNumber = 4,
    kPskParamFieldNumber = 5,
    kTypeFieldNumber = 2,
  };
  // .zb.dcts.scenario.spectrum.DDCBank bank = 1;
  bool has_bank() const;
  private:
  bool _internal_has_bank() const;
  public:
  void clear_bank();
  const ::zb::dcts::scenario::spectrum::DDCBank& bank() const;
  ::zb::dcts::scenario::spectrum::DDCBank* release_bank();
  ::zb::dcts::scenario::spectrum::DDCBank* mutable_bank();
  void set_allocated_bank(::zb::dcts::scenario::spectrum::DDCBank* bank);
  private:
  const ::zb::dcts::scenario::spectrum::DDCBank& _internal_bank() const;
  ::zb::dcts::scenario::spectrum::DDCBank* _internal_mutable_bank();
  public:
  void unsafe_arena_set_allocated_bank(
      ::zb::dcts::scenario::spectrum::DDCBank* bank);
  ::zb::dcts::scenario::spectrum::DDCBank* unsafe_arena_release_bank();

  // .zb.dcts.scenario.FFP.OOKParam ook_param = 3;
  bool has_ook_param() const;
  private:
  bool _internal_has_ook_param() const;
  public:
  void clear_ook_param();
  const ::zb::dcts::scenario::FFP::OOKParam& ook_param() const;
  ::zb::dcts::scenario::FFP::OOKParam* release_ook_param();
  ::zb::dcts::scenario::FFP::OOKParam* mutable_ook_param();
  void set_allocated_ook_param(::zb::dcts::scenario::FFP::OOKParam* ook_param);
  private:
  const ::zb::dcts::scenario::FFP::OOKParam& _internal_ook_param() const;
  ::zb::dcts::scenario::FFP::OOKParam* _internal_mutable_ook_param();
  public:
  void unsafe_arena_set_allocated_ook_param(
      ::zb::dcts::scenario::FFP::OOKParam* ook_param);
  ::zb::dcts::scenario::FFP::OOKParam* unsafe_arena_release_ook_param();

  // .zb.dcts.scenario.FFP.FSKParam fsk_param = 4;
  bool has_fsk_param() const;
  private:
  bool _internal_has_fsk_param() const;
  public:
  void clear_fsk_param();
  const ::zb::dcts::scenario::FFP::FSKParam& fsk_param() const;
  ::zb::dcts::scenario::FFP::FSKParam* release_fsk_param();
  ::zb::dcts::scenario::FFP::FSKParam* mutable_fsk_param();
  void set_allocated_fsk_param(::zb::dcts::scenario::FFP::FSKParam* fsk_param);
  private:
  const ::zb::dcts::scenario::FFP::FSKParam& _internal_fsk_param() const;
  ::zb::dcts::scenario::FFP::FSKParam* _internal_mutable_fsk_param();
  public:
  void unsafe_arena_set_allocated_fsk_param(
      ::zb::dcts::scenario::FFP::FSKParam* fsk_param);
  ::zb::dcts::scenario::FFP::FSKParam* unsafe_arena_release_fsk_param();

  // .zb.dcts.scenario.FFP.PSKParam psk_param = 5;
  bool has_psk_param() const;
  private:
  bool _internal_has_psk_param() const;
  public:
  void clear_psk_param();
  const ::zb::dcts::scenario::FFP::PSKParam& psk_param() const;
  ::zb::dcts::scenario::FFP::PSKParam* release_psk_param();
  ::zb::dcts::scenario::FFP::PSKParam* mutable_psk_param();
  void set_allocated_psk_param(::zb::dcts::scenario::FFP::PSKParam* psk_param);
  private:
  const ::zb::dcts::scenario::FFP::PSKParam& _internal_psk_param() const;
  ::zb::dcts::scenario::FFP::PSKParam* _internal_mutable_psk_param();
  public:
  void unsafe_arena_set_allocated_psk_param(
      ::zb::dcts::scenario::FFP::PSKParam* psk_param);
  ::zb::dcts::scenario::FFP::PSKParam* unsafe_arena_release_psk_param();

  // .zb.dcts.scenario.FFP.DigitalDemodType type = 2;
  void clear_type();
  ::zb::dcts::scenario::FFP::DigitalDemodType type() const;
  void set_type(::zb::dcts::scenario::FFP::DigitalDemodType value);
  private:
  ::zb::dcts::scenario::FFP::DigitalDemodType _internal_type() const;
  void _internal_set_type(::zb::dcts::scenario::FFP::DigitalDemodType value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.VSAParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::spectrum::DDCBank* bank_;
  ::zb::dcts::scenario::FFP::OOKParam* ook_param_;
  ::zb::dcts::scenario::FFP::FSKParam* fsk_param_;
  ::zb::dcts::scenario::FFP::PSKParam* psk_param_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class VSARequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.VSARequest) */ {
 public:
  inline VSARequest() : VSARequest(nullptr) {};
  virtual ~VSARequest();

  VSARequest(const VSARequest& from);
  VSARequest(VSARequest&& from) noexcept
    : VSARequest() {
    *this = ::std::move(from);
  }

  inline VSARequest& operator=(const VSARequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VSARequest& operator=(VSARequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VSARequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VSARequest* internal_default_instance() {
    return reinterpret_cast<const VSARequest*>(
               &_VSARequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(VSARequest& a, VSARequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VSARequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VSARequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VSARequest* New() const final {
    return CreateMaybeMessage<VSARequest>(nullptr);
  }

  VSARequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VSARequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VSARequest& from);
  void MergeFrom(const VSARequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VSARequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.VSARequest";
  }
  protected:
  explicit VSARequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScenarioFieldNumber = 1,
    kSourceFieldNumber = 2,
    kParamFieldNumber = 3,
  };
  // .zb.dcts.scenario.ScenarioId scenario = 1;
  bool has_scenario() const;
  private:
  bool _internal_has_scenario() const;
  public:
  void clear_scenario();
  const ::zb::dcts::scenario::ScenarioId& scenario() const;
  ::zb::dcts::scenario::ScenarioId* release_scenario();
  ::zb::dcts::scenario::ScenarioId* mutable_scenario();
  void set_allocated_scenario(::zb::dcts::scenario::ScenarioId* scenario);
  private:
  const ::zb::dcts::scenario::ScenarioId& _internal_scenario() const;
  ::zb::dcts::scenario::ScenarioId* _internal_mutable_scenario();
  public:
  void unsafe_arena_set_allocated_scenario(
      ::zb::dcts::scenario::ScenarioId* scenario);
  ::zb::dcts::scenario::ScenarioId* unsafe_arena_release_scenario();

  // .zb.dcts.scenario.FFP.VSASource source = 2;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::zb::dcts::scenario::FFP::VSASource& source() const;
  ::zb::dcts::scenario::FFP::VSASource* release_source();
  ::zb::dcts::scenario::FFP::VSASource* mutable_source();
  void set_allocated_source(::zb::dcts::scenario::FFP::VSASource* source);
  private:
  const ::zb::dcts::scenario::FFP::VSASource& _internal_source() const;
  ::zb::dcts::scenario::FFP::VSASource* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::zb::dcts::scenario::FFP::VSASource* source);
  ::zb::dcts::scenario::FFP::VSASource* unsafe_arena_release_source();

  // .zb.dcts.scenario.FFP.VSAParam param = 3;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const ::zb::dcts::scenario::FFP::VSAParam& param() const;
  ::zb::dcts::scenario::FFP::VSAParam* release_param();
  ::zb::dcts::scenario::FFP::VSAParam* mutable_param();
  void set_allocated_param(::zb::dcts::scenario::FFP::VSAParam* param);
  private:
  const ::zb::dcts::scenario::FFP::VSAParam& _internal_param() const;
  ::zb::dcts::scenario::FFP::VSAParam* _internal_mutable_param();
  public:
  void unsafe_arena_set_allocated_param(
      ::zb::dcts::scenario::FFP::VSAParam* param);
  ::zb::dcts::scenario::FFP::VSAParam* unsafe_arena_release_param();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.VSARequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::ScenarioId* scenario_;
  ::zb::dcts::scenario::FFP::VSASource* source_;
  ::zb::dcts::scenario::FFP::VSAParam* param_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class VSAResult_Header PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.VSAResult.Header) */ {
 public:
  inline VSAResult_Header() : VSAResult_Header(nullptr) {};
  virtual ~VSAResult_Header();

  VSAResult_Header(const VSAResult_Header& from);
  VSAResult_Header(VSAResult_Header&& from) noexcept
    : VSAResult_Header() {
    *this = ::std::move(from);
  }

  inline VSAResult_Header& operator=(const VSAResult_Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline VSAResult_Header& operator=(VSAResult_Header&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VSAResult_Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VSAResult_Header* internal_default_instance() {
    return reinterpret_cast<const VSAResult_Header*>(
               &_VSAResult_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VSAResult_Header& a, VSAResult_Header& b) {
    a.Swap(&b);
  }
  inline void Swap(VSAResult_Header* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VSAResult_Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VSAResult_Header* New() const final {
    return CreateMaybeMessage<VSAResult_Header>(nullptr);
  }

  VSAResult_Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VSAResult_Header>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VSAResult_Header& from);
  void MergeFrom(const VSAResult_Header& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VSAResult_Header* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.VSAResult.Header";
  }
  protected:
  explicit VSAResult_Header(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFromFieldNumber = 1,
    kTimeSpanFieldNumber = 3,
    kDevicePositionFieldNumber = 4,
    kSequenceNumberFieldNumber = 2,
  };
  // .zb.dcts.source.SourceId result_from = 1;
  bool has_result_from() const;
  private:
  bool _internal_has_result_from() const;
  public:
  void clear_result_from();
  const ::zb::dcts::source::SourceId& result_from() const;
  ::zb::dcts::source::SourceId* release_result_from();
  ::zb::dcts::source::SourceId* mutable_result_from();
  void set_allocated_result_from(::zb::dcts::source::SourceId* result_from);
  private:
  const ::zb::dcts::source::SourceId& _internal_result_from() const;
  ::zb::dcts::source::SourceId* _internal_mutable_result_from();
  public:
  void unsafe_arena_set_allocated_result_from(
      ::zb::dcts::source::SourceId* result_from);
  ::zb::dcts::source::SourceId* unsafe_arena_release_result_from();

  // .zb.dcts.TimeSpan time_span = 3;
  bool has_time_span() const;
  private:
  bool _internal_has_time_span() const;
  public:
  void clear_time_span();
  const ::zb::dcts::TimeSpan& time_span() const;
  ::zb::dcts::TimeSpan* release_time_span();
  ::zb::dcts::TimeSpan* mutable_time_span();
  void set_allocated_time_span(::zb::dcts::TimeSpan* time_span);
  private:
  const ::zb::dcts::TimeSpan& _internal_time_span() const;
  ::zb::dcts::TimeSpan* _internal_mutable_time_span();
  public:
  void unsafe_arena_set_allocated_time_span(
      ::zb::dcts::TimeSpan* time_span);
  ::zb::dcts::TimeSpan* unsafe_arena_release_time_span();

  // .zb.dcts.Position device_position = 4;
  bool has_device_position() const;
  private:
  bool _internal_has_device_position() const;
  public:
  void clear_device_position();
  const ::zb::dcts::Position& device_position() const;
  ::zb::dcts::Position* release_device_position();
  ::zb::dcts::Position* mutable_device_position();
  void set_allocated_device_position(::zb::dcts::Position* device_position);
  private:
  const ::zb::dcts::Position& _internal_device_position() const;
  ::zb::dcts::Position* _internal_mutable_device_position();
  public:
  void unsafe_arena_set_allocated_device_position(
      ::zb::dcts::Position* device_position);
  ::zb::dcts::Position* unsafe_arena_release_device_position();

  // uint32 sequence_number = 2;
  void clear_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_number() const;
  void set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sequence_number() const;
  void _internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.VSAResult.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::source::SourceId* result_from_;
  ::zb::dcts::TimeSpan* time_span_;
  ::zb::dcts::Position* device_position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// -------------------------------------------------------------------

class VSAResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.FFP.VSAResult) */ {
 public:
  inline VSAResult() : VSAResult(nullptr) {};
  virtual ~VSAResult();

  VSAResult(const VSAResult& from);
  VSAResult(VSAResult&& from) noexcept
    : VSAResult() {
    *this = ::std::move(from);
  }

  inline VSAResult& operator=(const VSAResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline VSAResult& operator=(VSAResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VSAResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VSAResult* internal_default_instance() {
    return reinterpret_cast<const VSAResult*>(
               &_VSAResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VSAResult& a, VSAResult& b) {
    a.Swap(&b);
  }
  inline void Swap(VSAResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VSAResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VSAResult* New() const final {
    return CreateMaybeMessage<VSAResult>(nullptr);
  }

  VSAResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VSAResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VSAResult& from);
  void MergeFrom(const VSAResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VSAResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.FFP.VSAResult";
  }
  protected:
  explicit VSAResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fFFP_2fVSA_2eproto);
    return ::descriptor_table_scenario_2fFFP_2fVSA_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VSAResult_Header Header;

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kDemodResultFieldNumber = 2,
  };
  // bytes symbols = 3;
  void clear_symbols();
  const std::string& symbols() const;
  void set_symbols(const std::string& value);
  void set_symbols(std::string&& value);
  void set_symbols(const char* value);
  void set_symbols(const void* value, size_t size);
  std::string* mutable_symbols();
  std::string* release_symbols();
  void set_allocated_symbols(std::string* symbols);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_symbols();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_symbols(
      std::string* symbols);
  private:
  const std::string& _internal_symbols() const;
  void _internal_set_symbols(const std::string& value);
  std::string* _internal_mutable_symbols();
  public:

  // .zb.dcts.scenario.FFP.VSAResult.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::zb::dcts::scenario::FFP::VSAResult_Header& header() const;
  ::zb::dcts::scenario::FFP::VSAResult_Header* release_header();
  ::zb::dcts::scenario::FFP::VSAResult_Header* mutable_header();
  void set_allocated_header(::zb::dcts::scenario::FFP::VSAResult_Header* header);
  private:
  const ::zb::dcts::scenario::FFP::VSAResult_Header& _internal_header() const;
  ::zb::dcts::scenario::FFP::VSAResult_Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::zb::dcts::scenario::FFP::VSAResult_Header* header);
  ::zb::dcts::scenario::FFP::VSAResult_Header* unsafe_arena_release_header();

  // .zb.dcts.scenario.FFP.IQData demod_result = 2;
  bool has_demod_result() const;
  private:
  bool _internal_has_demod_result() const;
  public:
  void clear_demod_result();
  const ::zb::dcts::scenario::FFP::IQData& demod_result() const;
  ::zb::dcts::scenario::FFP::IQData* release_demod_result();
  ::zb::dcts::scenario::FFP::IQData* mutable_demod_result();
  void set_allocated_demod_result(::zb::dcts::scenario::FFP::IQData* demod_result);
  private:
  const ::zb::dcts::scenario::FFP::IQData& _internal_demod_result() const;
  ::zb::dcts::scenario::FFP::IQData* _internal_mutable_demod_result();
  public:
  void unsafe_arena_set_allocated_demod_result(
      ::zb::dcts::scenario::FFP::IQData* demod_result);
  ::zb::dcts::scenario::FFP::IQData* unsafe_arena_release_demod_result();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.FFP.VSAResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbols_;
  ::zb::dcts::scenario::FFP::VSAResult_Header* header_;
  ::zb::dcts::scenario::FFP::IQData* demod_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fFFP_2fVSA_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VSASource

// .zb.dcts.source.SourceId id = 1;
inline bool VSASource::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool VSASource::has_id() const {
  return _internal_has_id();
}
inline const ::zb::dcts::source::SourceId& VSASource::_internal_id() const {
  const ::zb::dcts::source::SourceId* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::SourceId*>(
      &::zb::dcts::source::_SourceId_default_instance_);
}
inline const ::zb::dcts::source::SourceId& VSASource::id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSASource.id)
  return _internal_id();
}
inline void VSASource::unsafe_arena_set_allocated_id(
    ::zb::dcts::source::SourceId* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSASource.id)
}
inline ::zb::dcts::source::SourceId* VSASource::release_id() {
  auto temp = unsafe_arena_release_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::SourceId* VSASource::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSASource.id)
  
  ::zb::dcts::source::SourceId* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::SourceId* VSASource::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::SourceId>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::zb::dcts::source::SourceId* VSASource::mutable_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSASource.id)
  return _internal_mutable_id();
}
inline void VSASource::set_allocated_id(::zb::dcts::source::SourceId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSASource.id)
}

// string address = 2;
inline void VSASource::clear_address() {
  address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VSASource::address() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSASource.address)
  return _internal_address();
}
inline void VSASource::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.VSASource.address)
}
inline std::string* VSASource::mutable_address() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSASource.address)
  return _internal_mutable_address();
}
inline const std::string& VSASource::_internal_address() const {
  return address_.Get();
}
inline void VSASource::_internal_set_address(const std::string& value) {
  
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VSASource::set_address(std::string&& value) {
  
  address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.scenario.FFP.VSASource.address)
}
inline void VSASource::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.scenario.FFP.VSASource.address)
}
inline void VSASource::set_address(const char* value,
    size_t size) {
  
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.scenario.FFP.VSASource.address)
}
inline std::string* VSASource::_internal_mutable_address() {
  
  return address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VSASource::release_address() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSASource.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VSASource::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSASource.address)
}
inline std::string* VSASource::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.scenario.FFP.VSASource.address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VSASource::unsafe_arena_set_allocated_address(
    std::string* address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (address != nullptr) {
    
  } else {
    
  }
  address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSASource.address)
}

// int32 attenuation_gain = 3;
inline void VSASource::clear_attenuation_gain() {
  attenuation_gain_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VSASource::_internal_attenuation_gain() const {
  return attenuation_gain_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VSASource::attenuation_gain() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSASource.attenuation_gain)
  return _internal_attenuation_gain();
}
inline void VSASource::_internal_set_attenuation_gain(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attenuation_gain_ = value;
}
inline void VSASource::set_attenuation_gain(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attenuation_gain(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.VSASource.attenuation_gain)
}

// int32 antenna = 4;
inline void VSASource::clear_antenna() {
  antenna_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VSASource::_internal_antenna() const {
  return antenna_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VSASource::antenna() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSASource.antenna)
  return _internal_antenna();
}
inline void VSASource::_internal_set_antenna(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  antenna_ = value;
}
inline void VSASource::set_antenna(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_antenna(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.VSASource.antenna)
}

// -------------------------------------------------------------------

// ChannelizerParam

// double bankSampleRate = 1;
inline void ChannelizerParam::clear_banksamplerate() {
  banksamplerate_ = 0;
}
inline double ChannelizerParam::_internal_banksamplerate() const {
  return banksamplerate_;
}
inline double ChannelizerParam::banksamplerate() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.ChannelizerParam.bankSampleRate)
  return _internal_banksamplerate();
}
inline void ChannelizerParam::_internal_set_banksamplerate(double value) {
  
  banksamplerate_ = value;
}
inline void ChannelizerParam::set_banksamplerate(double value) {
  _internal_set_banksamplerate(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.ChannelizerParam.bankSampleRate)
}

// double chFrequency = 2;
inline void ChannelizerParam::clear_chfrequency() {
  chfrequency_ = 0;
}
inline double ChannelizerParam::_internal_chfrequency() const {
  return chfrequency_;
}
inline double ChannelizerParam::chfrequency() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.ChannelizerParam.chFrequency)
  return _internal_chfrequency();
}
inline void ChannelizerParam::_internal_set_chfrequency(double value) {
  
  chfrequency_ = value;
}
inline void ChannelizerParam::set_chfrequency(double value) {
  _internal_set_chfrequency(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.ChannelizerParam.chFrequency)
}

// double chSampleRate = 3;
inline void ChannelizerParam::clear_chsamplerate() {
  chsamplerate_ = 0;
}
inline double ChannelizerParam::_internal_chsamplerate() const {
  return chsamplerate_;
}
inline double ChannelizerParam::chsamplerate() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.ChannelizerParam.chSampleRate)
  return _internal_chsamplerate();
}
inline void ChannelizerParam::_internal_set_chsamplerate(double value) {
  
  chsamplerate_ = value;
}
inline void ChannelizerParam::set_chsamplerate(double value) {
  _internal_set_chsamplerate(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.ChannelizerParam.chSampleRate)
}

// double chBandwidth = 4;
inline void ChannelizerParam::clear_chbandwidth() {
  chbandwidth_ = 0;
}
inline double ChannelizerParam::_internal_chbandwidth() const {
  return chbandwidth_;
}
inline double ChannelizerParam::chbandwidth() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.ChannelizerParam.chBandwidth)
  return _internal_chbandwidth();
}
inline void ChannelizerParam::_internal_set_chbandwidth(double value) {
  
  chbandwidth_ = value;
}
inline void ChannelizerParam::set_chbandwidth(double value) {
  _internal_set_chbandwidth(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.ChannelizerParam.chBandwidth)
}

// uint32 decimation = 5;
inline void ChannelizerParam::clear_decimation() {
  decimation_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelizerParam::_internal_decimation() const {
  return decimation_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelizerParam::decimation() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.ChannelizerParam.decimation)
  return _internal_decimation();
}
inline void ChannelizerParam::_internal_set_decimation(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  decimation_ = value;
}
inline void ChannelizerParam::set_decimation(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_decimation(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.ChannelizerParam.decimation)
}

// -------------------------------------------------------------------

// PulseShapingFilter

// .zb.dcts.scenario.FFP.PulseShapingFilter.Type type = 1;
inline void PulseShapingFilter::clear_type() {
  type_ = 0;
}
inline ::zb::dcts::scenario::FFP::PulseShapingFilter_Type PulseShapingFilter::_internal_type() const {
  return static_cast< ::zb::dcts::scenario::FFP::PulseShapingFilter_Type >(type_);
}
inline ::zb::dcts::scenario::FFP::PulseShapingFilter_Type PulseShapingFilter::type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.PulseShapingFilter.type)
  return _internal_type();
}
inline void PulseShapingFilter::_internal_set_type(::zb::dcts::scenario::FFP::PulseShapingFilter_Type value) {
  
  type_ = value;
}
inline void PulseShapingFilter::set_type(::zb::dcts::scenario::FFP::PulseShapingFilter_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.PulseShapingFilter.type)
}

// float exceedBw = 2;
inline void PulseShapingFilter::clear_exceedbw() {
  exceedbw_ = 0;
}
inline float PulseShapingFilter::_internal_exceedbw() const {
  return exceedbw_;
}
inline float PulseShapingFilter::exceedbw() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.PulseShapingFilter.exceedBw)
  return _internal_exceedbw();
}
inline void PulseShapingFilter::_internal_set_exceedbw(float value) {
  
  exceedbw_ = value;
}
inline void PulseShapingFilter::set_exceedbw(float value) {
  _internal_set_exceedbw(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.PulseShapingFilter.exceedBw)
}

// -------------------------------------------------------------------

// BaseParam

// .zb.dcts.scenario.FFP.DataType dataType = 2;
inline void BaseParam::clear_datatype() {
  datatype_ = 0;
}
inline ::zb::dcts::scenario::FFP::DataType BaseParam::_internal_datatype() const {
  return static_cast< ::zb::dcts::scenario::FFP::DataType >(datatype_);
}
inline ::zb::dcts::scenario::FFP::DataType BaseParam::datatype() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.BaseParam.dataType)
  return _internal_datatype();
}
inline void BaseParam::_internal_set_datatype(::zb::dcts::scenario::FFP::DataType value) {
  
  datatype_ = value;
}
inline void BaseParam::set_datatype(::zb::dcts::scenario::FFP::DataType value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.BaseParam.dataType)
}

// .zb.dcts.scenario.FFP.ChannelizerParam chParam = 3;
inline bool BaseParam::_internal_has_chparam() const {
  return this != internal_default_instance() && chparam_ != nullptr;
}
inline bool BaseParam::has_chparam() const {
  return _internal_has_chparam();
}
inline void BaseParam::clear_chparam() {
  if (GetArena() == nullptr && chparam_ != nullptr) {
    delete chparam_;
  }
  chparam_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::ChannelizerParam& BaseParam::_internal_chparam() const {
  const ::zb::dcts::scenario::FFP::ChannelizerParam* p = chparam_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::ChannelizerParam*>(
      &::zb::dcts::scenario::FFP::_ChannelizerParam_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::ChannelizerParam& BaseParam::chparam() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.BaseParam.chParam)
  return _internal_chparam();
}
inline void BaseParam::unsafe_arena_set_allocated_chparam(
    ::zb::dcts::scenario::FFP::ChannelizerParam* chparam) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chparam_);
  }
  chparam_ = chparam;
  if (chparam) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.BaseParam.chParam)
}
inline ::zb::dcts::scenario::FFP::ChannelizerParam* BaseParam::release_chparam() {
  auto temp = unsafe_arena_release_chparam();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::ChannelizerParam* BaseParam::unsafe_arena_release_chparam() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.BaseParam.chParam)
  
  ::zb::dcts::scenario::FFP::ChannelizerParam* temp = chparam_;
  chparam_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::ChannelizerParam* BaseParam::_internal_mutable_chparam() {
  
  if (chparam_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::ChannelizerParam>(GetArena());
    chparam_ = p;
  }
  return chparam_;
}
inline ::zb::dcts::scenario::FFP::ChannelizerParam* BaseParam::mutable_chparam() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.BaseParam.chParam)
  return _internal_mutable_chparam();
}
inline void BaseParam::set_allocated_chparam(::zb::dcts::scenario::FFP::ChannelizerParam* chparam) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete chparam_;
  }
  if (chparam) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(chparam);
    if (message_arena != submessage_arena) {
      chparam = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chparam, submessage_arena);
    }
    
  } else {
    
  }
  chparam_ = chparam;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.BaseParam.chParam)
}

// .zb.dcts.scenario.FFP.PulseShapingFilter filter = 4;
inline bool BaseParam::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool BaseParam::has_filter() const {
  return _internal_has_filter();
}
inline void BaseParam::clear_filter() {
  if (GetArena() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::PulseShapingFilter& BaseParam::_internal_filter() const {
  const ::zb::dcts::scenario::FFP::PulseShapingFilter* p = filter_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::PulseShapingFilter*>(
      &::zb::dcts::scenario::FFP::_PulseShapingFilter_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::PulseShapingFilter& BaseParam::filter() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.BaseParam.filter)
  return _internal_filter();
}
inline void BaseParam::unsafe_arena_set_allocated_filter(
    ::zb::dcts::scenario::FFP::PulseShapingFilter* filter) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.BaseParam.filter)
}
inline ::zb::dcts::scenario::FFP::PulseShapingFilter* BaseParam::release_filter() {
  auto temp = unsafe_arena_release_filter();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::PulseShapingFilter* BaseParam::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.BaseParam.filter)
  
  ::zb::dcts::scenario::FFP::PulseShapingFilter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::PulseShapingFilter* BaseParam::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::PulseShapingFilter>(GetArena());
    filter_ = p;
  }
  return filter_;
}
inline ::zb::dcts::scenario::FFP::PulseShapingFilter* BaseParam::mutable_filter() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.BaseParam.filter)
  return _internal_mutable_filter();
}
inline void BaseParam::set_allocated_filter(::zb::dcts::scenario::FFP::PulseShapingFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.BaseParam.filter)
}

// float samplesPerSymbol = 5;
inline void BaseParam::clear_samplespersymbol() {
  samplespersymbol_ = 0;
}
inline float BaseParam::_internal_samplespersymbol() const {
  return samplespersymbol_;
}
inline float BaseParam::samplespersymbol() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.BaseParam.samplesPerSymbol)
  return _internal_samplespersymbol();
}
inline void BaseParam::_internal_set_samplespersymbol(float value) {
  
  samplespersymbol_ = value;
}
inline void BaseParam::set_samplespersymbol(float value) {
  _internal_set_samplespersymbol(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.BaseParam.samplesPerSymbol)
}

// uint32 minOutputSize = 6;
inline void BaseParam::clear_minoutputsize() {
  minoutputsize_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BaseParam::_internal_minoutputsize() const {
  return minoutputsize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BaseParam::minoutputsize() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.BaseParam.minOutputSize)
  return _internal_minoutputsize();
}
inline void BaseParam::_internal_set_minoutputsize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  minoutputsize_ = value;
}
inline void BaseParam::set_minoutputsize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_minoutputsize(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.BaseParam.minOutputSize)
}

// -------------------------------------------------------------------

// OOKParam

// .zb.dcts.scenario.FFP.BaseParam baseParam = 1;
inline bool OOKParam::_internal_has_baseparam() const {
  return this != internal_default_instance() && baseparam_ != nullptr;
}
inline bool OOKParam::has_baseparam() const {
  return _internal_has_baseparam();
}
inline void OOKParam::clear_baseparam() {
  if (GetArena() == nullptr && baseparam_ != nullptr) {
    delete baseparam_;
  }
  baseparam_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::BaseParam& OOKParam::_internal_baseparam() const {
  const ::zb::dcts::scenario::FFP::BaseParam* p = baseparam_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::BaseParam*>(
      &::zb::dcts::scenario::FFP::_BaseParam_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::BaseParam& OOKParam::baseparam() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.OOKParam.baseParam)
  return _internal_baseparam();
}
inline void OOKParam::unsafe_arena_set_allocated_baseparam(
    ::zb::dcts::scenario::FFP::BaseParam* baseparam) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(baseparam_);
  }
  baseparam_ = baseparam;
  if (baseparam) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.OOKParam.baseParam)
}
inline ::zb::dcts::scenario::FFP::BaseParam* OOKParam::release_baseparam() {
  auto temp = unsafe_arena_release_baseparam();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::BaseParam* OOKParam::unsafe_arena_release_baseparam() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.OOKParam.baseParam)
  
  ::zb::dcts::scenario::FFP::BaseParam* temp = baseparam_;
  baseparam_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::BaseParam* OOKParam::_internal_mutable_baseparam() {
  
  if (baseparam_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::BaseParam>(GetArena());
    baseparam_ = p;
  }
  return baseparam_;
}
inline ::zb::dcts::scenario::FFP::BaseParam* OOKParam::mutable_baseparam() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.OOKParam.baseParam)
  return _internal_mutable_baseparam();
}
inline void OOKParam::set_allocated_baseparam(::zb::dcts::scenario::FFP::BaseParam* baseparam) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete baseparam_;
  }
  if (baseparam) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(baseparam);
    if (message_arena != submessage_arena) {
      baseparam = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, baseparam, submessage_arena);
    }
    
  } else {
    
  }
  baseparam_ = baseparam;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.OOKParam.baseParam)
}

// float threshold = 2;
inline void OOKParam::clear_threshold() {
  threshold_ = 0;
}
inline float OOKParam::_internal_threshold() const {
  return threshold_;
}
inline float OOKParam::threshold() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.OOKParam.threshold)
  return _internal_threshold();
}
inline void OOKParam::_internal_set_threshold(float value) {
  
  threshold_ = value;
}
inline void OOKParam::set_threshold(float value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.OOKParam.threshold)
}

// -------------------------------------------------------------------

// FSKParam

// .zb.dcts.scenario.FFP.BaseParam baseParam = 1;
inline bool FSKParam::_internal_has_baseparam() const {
  return this != internal_default_instance() && baseparam_ != nullptr;
}
inline bool FSKParam::has_baseparam() const {
  return _internal_has_baseparam();
}
inline void FSKParam::clear_baseparam() {
  if (GetArena() == nullptr && baseparam_ != nullptr) {
    delete baseparam_;
  }
  baseparam_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::BaseParam& FSKParam::_internal_baseparam() const {
  const ::zb::dcts::scenario::FFP::BaseParam* p = baseparam_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::BaseParam*>(
      &::zb::dcts::scenario::FFP::_BaseParam_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::BaseParam& FSKParam::baseparam() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.FSKParam.baseParam)
  return _internal_baseparam();
}
inline void FSKParam::unsafe_arena_set_allocated_baseparam(
    ::zb::dcts::scenario::FFP::BaseParam* baseparam) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(baseparam_);
  }
  baseparam_ = baseparam;
  if (baseparam) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.FSKParam.baseParam)
}
inline ::zb::dcts::scenario::FFP::BaseParam* FSKParam::release_baseparam() {
  auto temp = unsafe_arena_release_baseparam();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::BaseParam* FSKParam::unsafe_arena_release_baseparam() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.FSKParam.baseParam)
  
  ::zb::dcts::scenario::FFP::BaseParam* temp = baseparam_;
  baseparam_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::BaseParam* FSKParam::_internal_mutable_baseparam() {
  
  if (baseparam_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::BaseParam>(GetArena());
    baseparam_ = p;
  }
  return baseparam_;
}
inline ::zb::dcts::scenario::FFP::BaseParam* FSKParam::mutable_baseparam() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.FSKParam.baseParam)
  return _internal_mutable_baseparam();
}
inline void FSKParam::set_allocated_baseparam(::zb::dcts::scenario::FFP::BaseParam* baseparam) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete baseparam_;
  }
  if (baseparam) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(baseparam);
    if (message_arena != submessage_arena) {
      baseparam = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, baseparam, submessage_arena);
    }
    
  } else {
    
  }
  baseparam_ = baseparam;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.FSKParam.baseParam)
}

// float maxDev = 2;
inline void FSKParam::clear_maxdev() {
  maxdev_ = 0;
}
inline float FSKParam::_internal_maxdev() const {
  return maxdev_;
}
inline float FSKParam::maxdev() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.FSKParam.maxDev)
  return _internal_maxdev();
}
inline void FSKParam::_internal_set_maxdev(float value) {
  
  maxdev_ = value;
}
inline void FSKParam::set_maxdev(float value) {
  _internal_set_maxdev(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.FSKParam.maxDev)
}

// -------------------------------------------------------------------

// PSKParam

// .zb.dcts.scenario.FFP.BaseParam baseParam = 1;
inline bool PSKParam::_internal_has_baseparam() const {
  return this != internal_default_instance() && baseparam_ != nullptr;
}
inline bool PSKParam::has_baseparam() const {
  return _internal_has_baseparam();
}
inline void PSKParam::clear_baseparam() {
  if (GetArena() == nullptr && baseparam_ != nullptr) {
    delete baseparam_;
  }
  baseparam_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::BaseParam& PSKParam::_internal_baseparam() const {
  const ::zb::dcts::scenario::FFP::BaseParam* p = baseparam_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::BaseParam*>(
      &::zb::dcts::scenario::FFP::_BaseParam_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::BaseParam& PSKParam::baseparam() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.PSKParam.baseParam)
  return _internal_baseparam();
}
inline void PSKParam::unsafe_arena_set_allocated_baseparam(
    ::zb::dcts::scenario::FFP::BaseParam* baseparam) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(baseparam_);
  }
  baseparam_ = baseparam;
  if (baseparam) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.PSKParam.baseParam)
}
inline ::zb::dcts::scenario::FFP::BaseParam* PSKParam::release_baseparam() {
  auto temp = unsafe_arena_release_baseparam();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::BaseParam* PSKParam::unsafe_arena_release_baseparam() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.PSKParam.baseParam)
  
  ::zb::dcts::scenario::FFP::BaseParam* temp = baseparam_;
  baseparam_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::BaseParam* PSKParam::_internal_mutable_baseparam() {
  
  if (baseparam_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::BaseParam>(GetArena());
    baseparam_ = p;
  }
  return baseparam_;
}
inline ::zb::dcts::scenario::FFP::BaseParam* PSKParam::mutable_baseparam() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.PSKParam.baseParam)
  return _internal_mutable_baseparam();
}
inline void PSKParam::set_allocated_baseparam(::zb::dcts::scenario::FFP::BaseParam* baseparam) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete baseparam_;
  }
  if (baseparam) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(baseparam);
    if (message_arena != submessage_arena) {
      baseparam = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, baseparam, submessage_arena);
    }
    
  } else {
    
  }
  baseparam_ = baseparam;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.PSKParam.baseParam)
}

// -------------------------------------------------------------------

// IQData

// repeated float data_i = 1;
inline int IQData::_internal_data_i_size() const {
  return data_i_.size();
}
inline int IQData::data_i_size() const {
  return _internal_data_i_size();
}
inline void IQData::clear_data_i() {
  data_i_.Clear();
}
inline float IQData::_internal_data_i(int index) const {
  return data_i_.Get(index);
}
inline float IQData::data_i(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.IQData.data_i)
  return _internal_data_i(index);
}
inline void IQData::set_data_i(int index, float value) {
  data_i_.Set(index, value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.IQData.data_i)
}
inline void IQData::_internal_add_data_i(float value) {
  data_i_.Add(value);
}
inline void IQData::add_data_i(float value) {
  _internal_add_data_i(value);
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.FFP.IQData.data_i)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
IQData::_internal_data_i() const {
  return data_i_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
IQData::data_i() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.FFP.IQData.data_i)
  return _internal_data_i();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
IQData::_internal_mutable_data_i() {
  return &data_i_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
IQData::mutable_data_i() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.FFP.IQData.data_i)
  return _internal_mutable_data_i();
}

// repeated float data_q = 2;
inline int IQData::_internal_data_q_size() const {
  return data_q_.size();
}
inline int IQData::data_q_size() const {
  return _internal_data_q_size();
}
inline void IQData::clear_data_q() {
  data_q_.Clear();
}
inline float IQData::_internal_data_q(int index) const {
  return data_q_.Get(index);
}
inline float IQData::data_q(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.IQData.data_q)
  return _internal_data_q(index);
}
inline void IQData::set_data_q(int index, float value) {
  data_q_.Set(index, value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.IQData.data_q)
}
inline void IQData::_internal_add_data_q(float value) {
  data_q_.Add(value);
}
inline void IQData::add_data_q(float value) {
  _internal_add_data_q(value);
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.FFP.IQData.data_q)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
IQData::_internal_data_q() const {
  return data_q_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
IQData::data_q() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.FFP.IQData.data_q)
  return _internal_data_q();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
IQData::_internal_mutable_data_q() {
  return &data_q_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
IQData::mutable_data_q() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.FFP.IQData.data_q)
  return _internal_mutable_data_q();
}

// -------------------------------------------------------------------

// VSAParam

// .zb.dcts.scenario.spectrum.DDCBank bank = 1;
inline bool VSAParam::_internal_has_bank() const {
  return this != internal_default_instance() && bank_ != nullptr;
}
inline bool VSAParam::has_bank() const {
  return _internal_has_bank();
}
inline const ::zb::dcts::scenario::spectrum::DDCBank& VSAParam::_internal_bank() const {
  const ::zb::dcts::scenario::spectrum::DDCBank* p = bank_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::spectrum::DDCBank*>(
      &::zb::dcts::scenario::spectrum::_DDCBank_default_instance_);
}
inline const ::zb::dcts::scenario::spectrum::DDCBank& VSAParam::bank() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAParam.bank)
  return _internal_bank();
}
inline void VSAParam::unsafe_arena_set_allocated_bank(
    ::zb::dcts::scenario::spectrum::DDCBank* bank) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bank_);
  }
  bank_ = bank;
  if (bank) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSAParam.bank)
}
inline ::zb::dcts::scenario::spectrum::DDCBank* VSAParam::release_bank() {
  auto temp = unsafe_arena_release_bank();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::spectrum::DDCBank* VSAParam::unsafe_arena_release_bank() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSAParam.bank)
  
  ::zb::dcts::scenario::spectrum::DDCBank* temp = bank_;
  bank_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::spectrum::DDCBank* VSAParam::_internal_mutable_bank() {
  
  if (bank_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::spectrum::DDCBank>(GetArena());
    bank_ = p;
  }
  return bank_;
}
inline ::zb::dcts::scenario::spectrum::DDCBank* VSAParam::mutable_bank() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSAParam.bank)
  return _internal_mutable_bank();
}
inline void VSAParam::set_allocated_bank(::zb::dcts::scenario::spectrum::DDCBank* bank) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bank_);
  }
  if (bank) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bank)->GetArena();
    if (message_arena != submessage_arena) {
      bank = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bank, submessage_arena);
    }
    
  } else {
    
  }
  bank_ = bank;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSAParam.bank)
}

// .zb.dcts.scenario.FFP.DigitalDemodType type = 2;
inline void VSAParam::clear_type() {
  type_ = 0;
}
inline ::zb::dcts::scenario::FFP::DigitalDemodType VSAParam::_internal_type() const {
  return static_cast< ::zb::dcts::scenario::FFP::DigitalDemodType >(type_);
}
inline ::zb::dcts::scenario::FFP::DigitalDemodType VSAParam::type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAParam.type)
  return _internal_type();
}
inline void VSAParam::_internal_set_type(::zb::dcts::scenario::FFP::DigitalDemodType value) {
  
  type_ = value;
}
inline void VSAParam::set_type(::zb::dcts::scenario::FFP::DigitalDemodType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.VSAParam.type)
}

// .zb.dcts.scenario.FFP.OOKParam ook_param = 3;
inline bool VSAParam::_internal_has_ook_param() const {
  return this != internal_default_instance() && ook_param_ != nullptr;
}
inline bool VSAParam::has_ook_param() const {
  return _internal_has_ook_param();
}
inline void VSAParam::clear_ook_param() {
  if (GetArena() == nullptr && ook_param_ != nullptr) {
    delete ook_param_;
  }
  ook_param_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::OOKParam& VSAParam::_internal_ook_param() const {
  const ::zb::dcts::scenario::FFP::OOKParam* p = ook_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::OOKParam*>(
      &::zb::dcts::scenario::FFP::_OOKParam_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::OOKParam& VSAParam::ook_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAParam.ook_param)
  return _internal_ook_param();
}
inline void VSAParam::unsafe_arena_set_allocated_ook_param(
    ::zb::dcts::scenario::FFP::OOKParam* ook_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ook_param_);
  }
  ook_param_ = ook_param;
  if (ook_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSAParam.ook_param)
}
inline ::zb::dcts::scenario::FFP::OOKParam* VSAParam::release_ook_param() {
  auto temp = unsafe_arena_release_ook_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::OOKParam* VSAParam::unsafe_arena_release_ook_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSAParam.ook_param)
  
  ::zb::dcts::scenario::FFP::OOKParam* temp = ook_param_;
  ook_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::OOKParam* VSAParam::_internal_mutable_ook_param() {
  
  if (ook_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::OOKParam>(GetArena());
    ook_param_ = p;
  }
  return ook_param_;
}
inline ::zb::dcts::scenario::FFP::OOKParam* VSAParam::mutable_ook_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSAParam.ook_param)
  return _internal_mutable_ook_param();
}
inline void VSAParam::set_allocated_ook_param(::zb::dcts::scenario::FFP::OOKParam* ook_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ook_param_;
  }
  if (ook_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ook_param);
    if (message_arena != submessage_arena) {
      ook_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ook_param, submessage_arena);
    }
    
  } else {
    
  }
  ook_param_ = ook_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSAParam.ook_param)
}

// .zb.dcts.scenario.FFP.FSKParam fsk_param = 4;
inline bool VSAParam::_internal_has_fsk_param() const {
  return this != internal_default_instance() && fsk_param_ != nullptr;
}
inline bool VSAParam::has_fsk_param() const {
  return _internal_has_fsk_param();
}
inline void VSAParam::clear_fsk_param() {
  if (GetArena() == nullptr && fsk_param_ != nullptr) {
    delete fsk_param_;
  }
  fsk_param_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::FSKParam& VSAParam::_internal_fsk_param() const {
  const ::zb::dcts::scenario::FFP::FSKParam* p = fsk_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::FSKParam*>(
      &::zb::dcts::scenario::FFP::_FSKParam_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::FSKParam& VSAParam::fsk_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAParam.fsk_param)
  return _internal_fsk_param();
}
inline void VSAParam::unsafe_arena_set_allocated_fsk_param(
    ::zb::dcts::scenario::FFP::FSKParam* fsk_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fsk_param_);
  }
  fsk_param_ = fsk_param;
  if (fsk_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSAParam.fsk_param)
}
inline ::zb::dcts::scenario::FFP::FSKParam* VSAParam::release_fsk_param() {
  auto temp = unsafe_arena_release_fsk_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::FSKParam* VSAParam::unsafe_arena_release_fsk_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSAParam.fsk_param)
  
  ::zb::dcts::scenario::FFP::FSKParam* temp = fsk_param_;
  fsk_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::FSKParam* VSAParam::_internal_mutable_fsk_param() {
  
  if (fsk_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::FSKParam>(GetArena());
    fsk_param_ = p;
  }
  return fsk_param_;
}
inline ::zb::dcts::scenario::FFP::FSKParam* VSAParam::mutable_fsk_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSAParam.fsk_param)
  return _internal_mutable_fsk_param();
}
inline void VSAParam::set_allocated_fsk_param(::zb::dcts::scenario::FFP::FSKParam* fsk_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fsk_param_;
  }
  if (fsk_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fsk_param);
    if (message_arena != submessage_arena) {
      fsk_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fsk_param, submessage_arena);
    }
    
  } else {
    
  }
  fsk_param_ = fsk_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSAParam.fsk_param)
}

// .zb.dcts.scenario.FFP.PSKParam psk_param = 5;
inline bool VSAParam::_internal_has_psk_param() const {
  return this != internal_default_instance() && psk_param_ != nullptr;
}
inline bool VSAParam::has_psk_param() const {
  return _internal_has_psk_param();
}
inline void VSAParam::clear_psk_param() {
  if (GetArena() == nullptr && psk_param_ != nullptr) {
    delete psk_param_;
  }
  psk_param_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::PSKParam& VSAParam::_internal_psk_param() const {
  const ::zb::dcts::scenario::FFP::PSKParam* p = psk_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::PSKParam*>(
      &::zb::dcts::scenario::FFP::_PSKParam_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::PSKParam& VSAParam::psk_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAParam.psk_param)
  return _internal_psk_param();
}
inline void VSAParam::unsafe_arena_set_allocated_psk_param(
    ::zb::dcts::scenario::FFP::PSKParam* psk_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(psk_param_);
  }
  psk_param_ = psk_param;
  if (psk_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSAParam.psk_param)
}
inline ::zb::dcts::scenario::FFP::PSKParam* VSAParam::release_psk_param() {
  auto temp = unsafe_arena_release_psk_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::PSKParam* VSAParam::unsafe_arena_release_psk_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSAParam.psk_param)
  
  ::zb::dcts::scenario::FFP::PSKParam* temp = psk_param_;
  psk_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::PSKParam* VSAParam::_internal_mutable_psk_param() {
  
  if (psk_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::PSKParam>(GetArena());
    psk_param_ = p;
  }
  return psk_param_;
}
inline ::zb::dcts::scenario::FFP::PSKParam* VSAParam::mutable_psk_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSAParam.psk_param)
  return _internal_mutable_psk_param();
}
inline void VSAParam::set_allocated_psk_param(::zb::dcts::scenario::FFP::PSKParam* psk_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete psk_param_;
  }
  if (psk_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(psk_param);
    if (message_arena != submessage_arena) {
      psk_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, psk_param, submessage_arena);
    }
    
  } else {
    
  }
  psk_param_ = psk_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSAParam.psk_param)
}

// -------------------------------------------------------------------

// VSARequest

// .zb.dcts.scenario.ScenarioId scenario = 1;
inline bool VSARequest::_internal_has_scenario() const {
  return this != internal_default_instance() && scenario_ != nullptr;
}
inline bool VSARequest::has_scenario() const {
  return _internal_has_scenario();
}
inline const ::zb::dcts::scenario::ScenarioId& VSARequest::_internal_scenario() const {
  const ::zb::dcts::scenario::ScenarioId* p = scenario_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::ScenarioId*>(
      &::zb::dcts::scenario::_ScenarioId_default_instance_);
}
inline const ::zb::dcts::scenario::ScenarioId& VSARequest::scenario() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSARequest.scenario)
  return _internal_scenario();
}
inline void VSARequest::unsafe_arena_set_allocated_scenario(
    ::zb::dcts::scenario::ScenarioId* scenario) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scenario_);
  }
  scenario_ = scenario;
  if (scenario) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSARequest.scenario)
}
inline ::zb::dcts::scenario::ScenarioId* VSARequest::release_scenario() {
  auto temp = unsafe_arena_release_scenario();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::ScenarioId* VSARequest::unsafe_arena_release_scenario() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSARequest.scenario)
  
  ::zb::dcts::scenario::ScenarioId* temp = scenario_;
  scenario_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::ScenarioId* VSARequest::_internal_mutable_scenario() {
  
  if (scenario_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::ScenarioId>(GetArena());
    scenario_ = p;
  }
  return scenario_;
}
inline ::zb::dcts::scenario::ScenarioId* VSARequest::mutable_scenario() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSARequest.scenario)
  return _internal_mutable_scenario();
}
inline void VSARequest::set_allocated_scenario(::zb::dcts::scenario::ScenarioId* scenario) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(scenario_);
  }
  if (scenario) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scenario)->GetArena();
    if (message_arena != submessage_arena) {
      scenario = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scenario, submessage_arena);
    }
    
  } else {
    
  }
  scenario_ = scenario;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSARequest.scenario)
}

// .zb.dcts.scenario.FFP.VSASource source = 2;
inline bool VSARequest::_internal_has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline bool VSARequest::has_source() const {
  return _internal_has_source();
}
inline void VSARequest::clear_source() {
  if (GetArena() == nullptr && source_ != nullptr) {
    delete source_;
  }
  source_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::VSASource& VSARequest::_internal_source() const {
  const ::zb::dcts::scenario::FFP::VSASource* p = source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::VSASource*>(
      &::zb::dcts::scenario::FFP::_VSASource_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::VSASource& VSARequest::source() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSARequest.source)
  return _internal_source();
}
inline void VSARequest::unsafe_arena_set_allocated_source(
    ::zb::dcts::scenario::FFP::VSASource* source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSARequest.source)
}
inline ::zb::dcts::scenario::FFP::VSASource* VSARequest::release_source() {
  auto temp = unsafe_arena_release_source();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::VSASource* VSARequest::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSARequest.source)
  
  ::zb::dcts::scenario::FFP::VSASource* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::VSASource* VSARequest::_internal_mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::VSASource>(GetArena());
    source_ = p;
  }
  return source_;
}
inline ::zb::dcts::scenario::FFP::VSASource* VSARequest::mutable_source() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSARequest.source)
  return _internal_mutable_source();
}
inline void VSARequest::set_allocated_source(::zb::dcts::scenario::FFP::VSASource* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSARequest.source)
}

// .zb.dcts.scenario.FFP.VSAParam param = 3;
inline bool VSARequest::_internal_has_param() const {
  return this != internal_default_instance() && param_ != nullptr;
}
inline bool VSARequest::has_param() const {
  return _internal_has_param();
}
inline void VSARequest::clear_param() {
  if (GetArena() == nullptr && param_ != nullptr) {
    delete param_;
  }
  param_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::VSAParam& VSARequest::_internal_param() const {
  const ::zb::dcts::scenario::FFP::VSAParam* p = param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::VSAParam*>(
      &::zb::dcts::scenario::FFP::_VSAParam_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::VSAParam& VSARequest::param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSARequest.param)
  return _internal_param();
}
inline void VSARequest::unsafe_arena_set_allocated_param(
    ::zb::dcts::scenario::FFP::VSAParam* param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(param_);
  }
  param_ = param;
  if (param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSARequest.param)
}
inline ::zb::dcts::scenario::FFP::VSAParam* VSARequest::release_param() {
  auto temp = unsafe_arena_release_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::VSAParam* VSARequest::unsafe_arena_release_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSARequest.param)
  
  ::zb::dcts::scenario::FFP::VSAParam* temp = param_;
  param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::VSAParam* VSARequest::_internal_mutable_param() {
  
  if (param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::VSAParam>(GetArena());
    param_ = p;
  }
  return param_;
}
inline ::zb::dcts::scenario::FFP::VSAParam* VSARequest::mutable_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSARequest.param)
  return _internal_mutable_param();
}
inline void VSARequest::set_allocated_param(::zb::dcts::scenario::FFP::VSAParam* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete param_;
  }
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(param);
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    
  } else {
    
  }
  param_ = param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSARequest.param)
}

// -------------------------------------------------------------------

// VSAResult_Header

// .zb.dcts.source.SourceId result_from = 1;
inline bool VSAResult_Header::_internal_has_result_from() const {
  return this != internal_default_instance() && result_from_ != nullptr;
}
inline bool VSAResult_Header::has_result_from() const {
  return _internal_has_result_from();
}
inline const ::zb::dcts::source::SourceId& VSAResult_Header::_internal_result_from() const {
  const ::zb::dcts::source::SourceId* p = result_from_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::SourceId*>(
      &::zb::dcts::source::_SourceId_default_instance_);
}
inline const ::zb::dcts::source::SourceId& VSAResult_Header::result_from() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAResult.Header.result_from)
  return _internal_result_from();
}
inline void VSAResult_Header::unsafe_arena_set_allocated_result_from(
    ::zb::dcts::source::SourceId* result_from) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_from_);
  }
  result_from_ = result_from;
  if (result_from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSAResult.Header.result_from)
}
inline ::zb::dcts::source::SourceId* VSAResult_Header::release_result_from() {
  auto temp = unsafe_arena_release_result_from();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::SourceId* VSAResult_Header::unsafe_arena_release_result_from() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSAResult.Header.result_from)
  
  ::zb::dcts::source::SourceId* temp = result_from_;
  result_from_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::SourceId* VSAResult_Header::_internal_mutable_result_from() {
  
  if (result_from_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::SourceId>(GetArena());
    result_from_ = p;
  }
  return result_from_;
}
inline ::zb::dcts::source::SourceId* VSAResult_Header::mutable_result_from() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSAResult.Header.result_from)
  return _internal_mutable_result_from();
}
inline void VSAResult_Header::set_allocated_result_from(::zb::dcts::source::SourceId* result_from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_from_);
  }
  if (result_from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_from)->GetArena();
    if (message_arena != submessage_arena) {
      result_from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_from, submessage_arena);
    }
    
  } else {
    
  }
  result_from_ = result_from;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSAResult.Header.result_from)
}

// uint32 sequence_number = 2;
inline void VSAResult_Header::clear_sequence_number() {
  sequence_number_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VSAResult_Header::_internal_sequence_number() const {
  return sequence_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VSAResult_Header::sequence_number() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAResult.Header.sequence_number)
  return _internal_sequence_number();
}
inline void VSAResult_Header::_internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sequence_number_ = value;
}
inline void VSAResult_Header::set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.VSAResult.Header.sequence_number)
}

// .zb.dcts.TimeSpan time_span = 3;
inline bool VSAResult_Header::_internal_has_time_span() const {
  return this != internal_default_instance() && time_span_ != nullptr;
}
inline bool VSAResult_Header::has_time_span() const {
  return _internal_has_time_span();
}
inline const ::zb::dcts::TimeSpan& VSAResult_Header::_internal_time_span() const {
  const ::zb::dcts::TimeSpan* p = time_span_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::TimeSpan*>(
      &::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& VSAResult_Header::time_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAResult.Header.time_span)
  return _internal_time_span();
}
inline void VSAResult_Header::unsafe_arena_set_allocated_time_span(
    ::zb::dcts::TimeSpan* time_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  time_span_ = time_span;
  if (time_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSAResult.Header.time_span)
}
inline ::zb::dcts::TimeSpan* VSAResult_Header::release_time_span() {
  auto temp = unsafe_arena_release_time_span();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* VSAResult_Header::unsafe_arena_release_time_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSAResult.Header.time_span)
  
  ::zb::dcts::TimeSpan* temp = time_span_;
  time_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* VSAResult_Header::_internal_mutable_time_span() {
  
  if (time_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    time_span_ = p;
  }
  return time_span_;
}
inline ::zb::dcts::TimeSpan* VSAResult_Header::mutable_time_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSAResult.Header.time_span)
  return _internal_mutable_time_span();
}
inline void VSAResult_Header::set_allocated_time_span(::zb::dcts::TimeSpan* time_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  if (time_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span)->GetArena();
    if (message_arena != submessage_arena) {
      time_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_span, submessage_arena);
    }
    
  } else {
    
  }
  time_span_ = time_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSAResult.Header.time_span)
}

// .zb.dcts.Position device_position = 4;
inline bool VSAResult_Header::_internal_has_device_position() const {
  return this != internal_default_instance() && device_position_ != nullptr;
}
inline bool VSAResult_Header::has_device_position() const {
  return _internal_has_device_position();
}
inline const ::zb::dcts::Position& VSAResult_Header::_internal_device_position() const {
  const ::zb::dcts::Position* p = device_position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Position*>(
      &::zb::dcts::_Position_default_instance_);
}
inline const ::zb::dcts::Position& VSAResult_Header::device_position() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAResult.Header.device_position)
  return _internal_device_position();
}
inline void VSAResult_Header::unsafe_arena_set_allocated_device_position(
    ::zb::dcts::Position* device_position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_position_);
  }
  device_position_ = device_position;
  if (device_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSAResult.Header.device_position)
}
inline ::zb::dcts::Position* VSAResult_Header::release_device_position() {
  auto temp = unsafe_arena_release_device_position();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Position* VSAResult_Header::unsafe_arena_release_device_position() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSAResult.Header.device_position)
  
  ::zb::dcts::Position* temp = device_position_;
  device_position_ = nullptr;
  return temp;
}
inline ::zb::dcts::Position* VSAResult_Header::_internal_mutable_device_position() {
  
  if (device_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Position>(GetArena());
    device_position_ = p;
  }
  return device_position_;
}
inline ::zb::dcts::Position* VSAResult_Header::mutable_device_position() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSAResult.Header.device_position)
  return _internal_mutable_device_position();
}
inline void VSAResult_Header::set_allocated_device_position(::zb::dcts::Position* device_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_position_);
  }
  if (device_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_position)->GetArena();
    if (message_arena != submessage_arena) {
      device_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_position, submessage_arena);
    }
    
  } else {
    
  }
  device_position_ = device_position;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSAResult.Header.device_position)
}

// -------------------------------------------------------------------

// VSAResult

// .zb.dcts.scenario.FFP.VSAResult.Header header = 1;
inline bool VSAResult::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool VSAResult::has_header() const {
  return _internal_has_header();
}
inline void VSAResult::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::VSAResult_Header& VSAResult::_internal_header() const {
  const ::zb::dcts::scenario::FFP::VSAResult_Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::VSAResult_Header*>(
      &::zb::dcts::scenario::FFP::_VSAResult_Header_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::VSAResult_Header& VSAResult::header() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAResult.header)
  return _internal_header();
}
inline void VSAResult::unsafe_arena_set_allocated_header(
    ::zb::dcts::scenario::FFP::VSAResult_Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSAResult.header)
}
inline ::zb::dcts::scenario::FFP::VSAResult_Header* VSAResult::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::VSAResult_Header* VSAResult::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSAResult.header)
  
  ::zb::dcts::scenario::FFP::VSAResult_Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::VSAResult_Header* VSAResult::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::VSAResult_Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::zb::dcts::scenario::FFP::VSAResult_Header* VSAResult::mutable_header() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSAResult.header)
  return _internal_mutable_header();
}
inline void VSAResult::set_allocated_header(::zb::dcts::scenario::FFP::VSAResult_Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSAResult.header)
}

// .zb.dcts.scenario.FFP.IQData demod_result = 2;
inline bool VSAResult::_internal_has_demod_result() const {
  return this != internal_default_instance() && demod_result_ != nullptr;
}
inline bool VSAResult::has_demod_result() const {
  return _internal_has_demod_result();
}
inline void VSAResult::clear_demod_result() {
  if (GetArena() == nullptr && demod_result_ != nullptr) {
    delete demod_result_;
  }
  demod_result_ = nullptr;
}
inline const ::zb::dcts::scenario::FFP::IQData& VSAResult::_internal_demod_result() const {
  const ::zb::dcts::scenario::FFP::IQData* p = demod_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::FFP::IQData*>(
      &::zb::dcts::scenario::FFP::_IQData_default_instance_);
}
inline const ::zb::dcts::scenario::FFP::IQData& VSAResult::demod_result() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAResult.demod_result)
  return _internal_demod_result();
}
inline void VSAResult::unsafe_arena_set_allocated_demod_result(
    ::zb::dcts::scenario::FFP::IQData* demod_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(demod_result_);
  }
  demod_result_ = demod_result;
  if (demod_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSAResult.demod_result)
}
inline ::zb::dcts::scenario::FFP::IQData* VSAResult::release_demod_result() {
  auto temp = unsafe_arena_release_demod_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::FFP::IQData* VSAResult::unsafe_arena_release_demod_result() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSAResult.demod_result)
  
  ::zb::dcts::scenario::FFP::IQData* temp = demod_result_;
  demod_result_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::FFP::IQData* VSAResult::_internal_mutable_demod_result() {
  
  if (demod_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::FFP::IQData>(GetArena());
    demod_result_ = p;
  }
  return demod_result_;
}
inline ::zb::dcts::scenario::FFP::IQData* VSAResult::mutable_demod_result() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSAResult.demod_result)
  return _internal_mutable_demod_result();
}
inline void VSAResult::set_allocated_demod_result(::zb::dcts::scenario::FFP::IQData* demod_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete demod_result_;
  }
  if (demod_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(demod_result);
    if (message_arena != submessage_arena) {
      demod_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, demod_result, submessage_arena);
    }
    
  } else {
    
  }
  demod_result_ = demod_result;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSAResult.demod_result)
}

// bytes symbols = 3;
inline void VSAResult::clear_symbols() {
  symbols_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VSAResult::symbols() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.FFP.VSAResult.symbols)
  return _internal_symbols();
}
inline void VSAResult::set_symbols(const std::string& value) {
  _internal_set_symbols(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.FFP.VSAResult.symbols)
}
inline std::string* VSAResult::mutable_symbols() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.FFP.VSAResult.symbols)
  return _internal_mutable_symbols();
}
inline const std::string& VSAResult::_internal_symbols() const {
  return symbols_.Get();
}
inline void VSAResult::_internal_set_symbols(const std::string& value) {
  
  symbols_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VSAResult::set_symbols(std::string&& value) {
  
  symbols_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.scenario.FFP.VSAResult.symbols)
}
inline void VSAResult::set_symbols(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  symbols_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.scenario.FFP.VSAResult.symbols)
}
inline void VSAResult::set_symbols(const void* value,
    size_t size) {
  
  symbols_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.scenario.FFP.VSAResult.symbols)
}
inline std::string* VSAResult::_internal_mutable_symbols() {
  
  return symbols_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VSAResult::release_symbols() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.FFP.VSAResult.symbols)
  return symbols_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VSAResult::set_allocated_symbols(std::string* symbols) {
  if (symbols != nullptr) {
    
  } else {
    
  }
  symbols_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbols,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.FFP.VSAResult.symbols)
}
inline std::string* VSAResult::unsafe_arena_release_symbols() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.scenario.FFP.VSAResult.symbols)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return symbols_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VSAResult::unsafe_arena_set_allocated_symbols(
    std::string* symbols) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (symbols != nullptr) {
    
  } else {
    
  }
  symbols_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      symbols, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.FFP.VSAResult.symbols)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace FFP
}  // namespace scenario
}  // namespace dcts
}  // namespace zb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zb::dcts::scenario::FFP::PulseShapingFilter_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::scenario::FFP::PulseShapingFilter_Type>() {
  return ::zb::dcts::scenario::FFP::PulseShapingFilter_Type_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::scenario::FFP::DigitalDemodType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::scenario::FFP::DigitalDemodType>() {
  return ::zb::dcts::scenario::FFP::DigitalDemodType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::scenario::FFP::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::scenario::FFP::DataType>() {
  return ::zb::dcts::scenario::FFP::DataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scenario_2fFFP_2fVSA_2eproto
