// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scenario/scenario.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scenario_2fscenario_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scenario_2fscenario_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dcts.pb.h"
#include "source/source.pb.h"
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scenario_2fscenario_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scenario_2fscenario_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scenario_2fscenario_2eproto;
namespace zb {
namespace dcts {
namespace scenario {
class ScenarioId;
class ScenarioIdDefaultTypeInternal;
extern ScenarioIdDefaultTypeInternal _ScenarioId_default_instance_;
class ScenarioInfo;
class ScenarioInfoDefaultTypeInternal;
extern ScenarioInfoDefaultTypeInternal _ScenarioInfo_default_instance_;
class ScenarioReply;
class ScenarioReplyDefaultTypeInternal;
extern ScenarioReplyDefaultTypeInternal _ScenarioReply_default_instance_;
class ScenarioTaskId;
class ScenarioTaskIdDefaultTypeInternal;
extern ScenarioTaskIdDefaultTypeInternal _ScenarioTaskId_default_instance_;
class ScenariosInfo;
class ScenariosInfoDefaultTypeInternal;
extern ScenariosInfoDefaultTypeInternal _ScenariosInfo_default_instance_;
class SubscribeRequest;
class SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
class TaskId;
class TaskIdDefaultTypeInternal;
extern TaskIdDefaultTypeInternal _TaskId_default_instance_;
class TaskSummary;
class TaskSummaryDefaultTypeInternal;
extern TaskSummaryDefaultTypeInternal _TaskSummary_default_instance_;
}  // namespace scenario
}  // namespace dcts
}  // namespace zb
PROTOBUF_NAMESPACE_OPEN
template<> ::zb::dcts::scenario::ScenarioId* Arena::CreateMaybeMessage<::zb::dcts::scenario::ScenarioId>(Arena*);
template<> ::zb::dcts::scenario::ScenarioInfo* Arena::CreateMaybeMessage<::zb::dcts::scenario::ScenarioInfo>(Arena*);
template<> ::zb::dcts::scenario::ScenarioReply* Arena::CreateMaybeMessage<::zb::dcts::scenario::ScenarioReply>(Arena*);
template<> ::zb::dcts::scenario::ScenarioTaskId* Arena::CreateMaybeMessage<::zb::dcts::scenario::ScenarioTaskId>(Arena*);
template<> ::zb::dcts::scenario::ScenariosInfo* Arena::CreateMaybeMessage<::zb::dcts::scenario::ScenariosInfo>(Arena*);
template<> ::zb::dcts::scenario::SubscribeRequest* Arena::CreateMaybeMessage<::zb::dcts::scenario::SubscribeRequest>(Arena*);
template<> ::zb::dcts::scenario::TaskId* Arena::CreateMaybeMessage<::zb::dcts::scenario::TaskId>(Arena*);
template<> ::zb::dcts::scenario::TaskSummary* Arena::CreateMaybeMessage<::zb::dcts::scenario::TaskSummary>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zb {
namespace dcts {
namespace scenario {

enum TaskType : int {
  SELF_TEST = 0,
  CAL1 = 1,
  CAL2 = 2,
  EXAMPLE = 3,
  PSCAN = 16,
  IF_SCAN = 17,
  PULSE_ANALYSIS = 18,
  PULSE_ANALYSIS_2 = 19,
  OSCILLOSCOPE = 20,
  VECTOR_SIGNAL_ANALYSIS = 21,
  IQ_RECORDER = 22,
  SIGNAL_GENERATOR = 23,
  POSITION_TDOA = 32,
  DIRECTION_FINDING_AOA = 33,
  DIRECTION_FINDING_SPATIAL_SPECTRUM = 34,
  DEMODULATE_ANALOG = 48,
  CLASSIFY_MODULATE = 56,
  CLASSIFY_ENCODE = 58,
  CLASSIFY_COMM_SYS = 60,
  DECODE_ADS_B = 70,
  DECODE_ACARS = 71,
  DECODE_AIS = 72,
  IQ_ACQUIRE = 73,
  DEMO_DETECT = 80,
  REPLAY_PSCAN = 81,
  REPLAY_DECODE_ADS_B = 90,
  REPLAY_DECODE_ACARS = 91,
  REPLAY_DECODE_AIS = 92,
  REPLAY_IQ = 93,
  REPLAY_TDOA = 94,
  REPLAY_DEMODULATE_ANALOG = 95,
  TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskType_IsValid(int value);
constexpr TaskType TaskType_MIN = SELF_TEST;
constexpr TaskType TaskType_MAX = REPLAY_DEMODULATE_ANALOG;
constexpr int TaskType_ARRAYSIZE = TaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskType_descriptor();
template<typename T>
inline const std::string& TaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskType_descriptor(), enum_t_value);
}
inline bool TaskType_Parse(
    const std::string& name, TaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskType>(
    TaskType_descriptor(), name, value);
}
enum TaskStatus : int {
  T_READY = 0,
  T_RUN = 1,
  T_ABORT = 2,
  T_FINISH = 3,
  T_PAUSED = 4,
  TaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskStatus_IsValid(int value);
constexpr TaskStatus TaskStatus_MIN = T_READY;
constexpr TaskStatus TaskStatus_MAX = T_PAUSED;
constexpr int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskStatus_descriptor();
template<typename T>
inline const std::string& TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskStatus_descriptor(), enum_t_value);
}
inline bool TaskStatus_Parse(
    const std::string& name, TaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
// ===================================================================

class ScenarioId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.ScenarioId) */ {
 public:
  inline ScenarioId() : ScenarioId(nullptr) {};
  virtual ~ScenarioId();

  ScenarioId(const ScenarioId& from);
  ScenarioId(ScenarioId&& from) noexcept
    : ScenarioId() {
    *this = ::std::move(from);
  }

  inline ScenarioId& operator=(const ScenarioId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioId& operator=(ScenarioId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioId* internal_default_instance() {
    return reinterpret_cast<const ScenarioId*>(
               &_ScenarioId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ScenarioId& a, ScenarioId& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScenarioId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioId* New() const final {
    return CreateMaybeMessage<ScenarioId>(nullptr);
  }

  ScenarioId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioId& from);
  void MergeFrom(const ScenarioId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.ScenarioId";
  }
  protected:
  explicit ScenarioId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fscenario_2eproto);
    return ::descriptor_table_scenario_2fscenario_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.ScenarioId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fscenario_2eproto;
};
// -------------------------------------------------------------------

class TaskId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.TaskId) */ {
 public:
  inline TaskId() : TaskId(nullptr) {};
  virtual ~TaskId();

  TaskId(const TaskId& from);
  TaskId(TaskId&& from) noexcept
    : TaskId() {
    *this = ::std::move(from);
  }

  inline TaskId& operator=(const TaskId& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskId& operator=(TaskId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaskId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskId* internal_default_instance() {
    return reinterpret_cast<const TaskId*>(
               &_TaskId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TaskId& a, TaskId& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskId* New() const final {
    return CreateMaybeMessage<TaskId>(nullptr);
  }

  TaskId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaskId& from);
  void MergeFrom(const TaskId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.TaskId";
  }
  protected:
  explicit TaskId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fscenario_2eproto);
    return ::descriptor_table_scenario_2fscenario_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.TaskId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fscenario_2eproto;
};
// -------------------------------------------------------------------

class ScenarioTaskId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.ScenarioTaskId) */ {
 public:
  inline ScenarioTaskId() : ScenarioTaskId(nullptr) {};
  virtual ~ScenarioTaskId();

  ScenarioTaskId(const ScenarioTaskId& from);
  ScenarioTaskId(ScenarioTaskId&& from) noexcept
    : ScenarioTaskId() {
    *this = ::std::move(from);
  }

  inline ScenarioTaskId& operator=(const ScenarioTaskId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioTaskId& operator=(ScenarioTaskId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioTaskId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioTaskId* internal_default_instance() {
    return reinterpret_cast<const ScenarioTaskId*>(
               &_ScenarioTaskId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ScenarioTaskId& a, ScenarioTaskId& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioTaskId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScenarioTaskId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioTaskId* New() const final {
    return CreateMaybeMessage<ScenarioTaskId>(nullptr);
  }

  ScenarioTaskId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioTaskId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioTaskId& from);
  void MergeFrom(const ScenarioTaskId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioTaskId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.ScenarioTaskId";
  }
  protected:
  explicit ScenarioTaskId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fscenario_2eproto);
    return ::descriptor_table_scenario_2fscenario_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScenarioIdFieldNumber = 1,
    kTaskIdFieldNumber = 2,
  };
  // .zb.dcts.scenario.ScenarioId scenario_id = 1;
  bool has_scenario_id() const;
  private:
  bool _internal_has_scenario_id() const;
  public:
  void clear_scenario_id();
  const ::zb::dcts::scenario::ScenarioId& scenario_id() const;
  ::zb::dcts::scenario::ScenarioId* release_scenario_id();
  ::zb::dcts::scenario::ScenarioId* mutable_scenario_id();
  void set_allocated_scenario_id(::zb::dcts::scenario::ScenarioId* scenario_id);
  private:
  const ::zb::dcts::scenario::ScenarioId& _internal_scenario_id() const;
  ::zb::dcts::scenario::ScenarioId* _internal_mutable_scenario_id();
  public:
  void unsafe_arena_set_allocated_scenario_id(
      ::zb::dcts::scenario::ScenarioId* scenario_id);
  ::zb::dcts::scenario::ScenarioId* unsafe_arena_release_scenario_id();

  // .zb.dcts.scenario.TaskId task_id = 2;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  const ::zb::dcts::scenario::TaskId& task_id() const;
  ::zb::dcts::scenario::TaskId* release_task_id();
  ::zb::dcts::scenario::TaskId* mutable_task_id();
  void set_allocated_task_id(::zb::dcts::scenario::TaskId* task_id);
  private:
  const ::zb::dcts::scenario::TaskId& _internal_task_id() const;
  ::zb::dcts::scenario::TaskId* _internal_mutable_task_id();
  public:
  void unsafe_arena_set_allocated_task_id(
      ::zb::dcts::scenario::TaskId* task_id);
  ::zb::dcts::scenario::TaskId* unsafe_arena_release_task_id();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.ScenarioTaskId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::ScenarioId* scenario_id_;
  ::zb::dcts::scenario::TaskId* task_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fscenario_2eproto;
};
// -------------------------------------------------------------------

class TaskSummary PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.TaskSummary) */ {
 public:
  inline TaskSummary() : TaskSummary(nullptr) {};
  virtual ~TaskSummary();

  TaskSummary(const TaskSummary& from);
  TaskSummary(TaskSummary&& from) noexcept
    : TaskSummary() {
    *this = ::std::move(from);
  }

  inline TaskSummary& operator=(const TaskSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskSummary& operator=(TaskSummary&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaskSummary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskSummary* internal_default_instance() {
    return reinterpret_cast<const TaskSummary*>(
               &_TaskSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TaskSummary& a, TaskSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskSummary* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskSummary* New() const final {
    return CreateMaybeMessage<TaskSummary>(nullptr);
  }

  TaskSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskSummary>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaskSummary& from);
  void MergeFrom(const TaskSummary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskSummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.TaskSummary";
  }
  protected:
  explicit TaskSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fscenario_2eproto);
    return ::descriptor_table_scenario_2fscenario_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicsFieldNumber = 6,
    kIdFieldNumber = 1,
    kStartTimeFieldNumber = 5,
    kTypeFieldNumber = 2,
    kStatusFieldNumber = 4,
  };
  // repeated .zb.dcts.Topic topics = 6;
  int topics_size() const;
  private:
  int _internal_topics_size() const;
  public:
  void clear_topics();
  ::zb::dcts::Topic* mutable_topics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::Topic >*
      mutable_topics();
  private:
  const ::zb::dcts::Topic& _internal_topics(int index) const;
  ::zb::dcts::Topic* _internal_add_topics();
  public:
  const ::zb::dcts::Topic& topics(int index) const;
  ::zb::dcts::Topic* add_topics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::Topic >&
      topics() const;

  // .zb.dcts.scenario.TaskId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::zb::dcts::scenario::TaskId& id() const;
  ::zb::dcts::scenario::TaskId* release_id();
  ::zb::dcts::scenario::TaskId* mutable_id();
  void set_allocated_id(::zb::dcts::scenario::TaskId* id);
  private:
  const ::zb::dcts::scenario::TaskId& _internal_id() const;
  ::zb::dcts::scenario::TaskId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::zb::dcts::scenario::TaskId* id);
  ::zb::dcts::scenario::TaskId* unsafe_arena_release_id();

  // .zb.dcts.Timestamp start_time = 5;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const ::zb::dcts::Timestamp& start_time() const;
  ::zb::dcts::Timestamp* release_start_time();
  ::zb::dcts::Timestamp* mutable_start_time();
  void set_allocated_start_time(::zb::dcts::Timestamp* start_time);
  private:
  const ::zb::dcts::Timestamp& _internal_start_time() const;
  ::zb::dcts::Timestamp* _internal_mutable_start_time();
  public:
  void unsafe_arena_set_allocated_start_time(
      ::zb::dcts::Timestamp* start_time);
  ::zb::dcts::Timestamp* unsafe_arena_release_start_time();

  // .zb.dcts.scenario.TaskType type = 2;
  void clear_type();
  ::zb::dcts::scenario::TaskType type() const;
  void set_type(::zb::dcts::scenario::TaskType value);
  private:
  ::zb::dcts::scenario::TaskType _internal_type() const;
  void _internal_set_type(::zb::dcts::scenario::TaskType value);
  public:

  // .zb.dcts.scenario.TaskStatus status = 4;
  void clear_status();
  ::zb::dcts::scenario::TaskStatus status() const;
  void set_status(::zb::dcts::scenario::TaskStatus value);
  private:
  ::zb::dcts::scenario::TaskStatus _internal_status() const;
  void _internal_set_status(::zb::dcts::scenario::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.TaskSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::Topic > topics_;
  ::zb::dcts::scenario::TaskId* id_;
  ::zb::dcts::Timestamp* start_time_;
  int type_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fscenario_2eproto;
};
// -------------------------------------------------------------------

class ScenarioInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.ScenarioInfo) */ {
 public:
  inline ScenarioInfo() : ScenarioInfo(nullptr) {};
  virtual ~ScenarioInfo();

  ScenarioInfo(const ScenarioInfo& from);
  ScenarioInfo(ScenarioInfo&& from) noexcept
    : ScenarioInfo() {
    *this = ::std::move(from);
  }

  inline ScenarioInfo& operator=(const ScenarioInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioInfo& operator=(ScenarioInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioInfo* internal_default_instance() {
    return reinterpret_cast<const ScenarioInfo*>(
               &_ScenarioInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ScenarioInfo& a, ScenarioInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScenarioInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioInfo* New() const final {
    return CreateMaybeMessage<ScenarioInfo>(nullptr);
  }

  ScenarioInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioInfo& from);
  void MergeFrom(const ScenarioInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.ScenarioInfo";
  }
  protected:
  explicit ScenarioInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fscenario_2eproto);
    return ::descriptor_table_scenario_2fscenario_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 6,
    kIdFieldNumber = 1,
    kUsingSourcesFieldNumber = 7,
  };
  // repeated .zb.dcts.scenario.TaskSummary tasks = 6;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;
  public:
  void clear_tasks();
  ::zb::dcts::scenario::TaskSummary* mutable_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::TaskSummary >*
      mutable_tasks();
  private:
  const ::zb::dcts::scenario::TaskSummary& _internal_tasks(int index) const;
  ::zb::dcts::scenario::TaskSummary* _internal_add_tasks();
  public:
  const ::zb::dcts::scenario::TaskSummary& tasks(int index) const;
  ::zb::dcts::scenario::TaskSummary* add_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::TaskSummary >&
      tasks() const;

  // .zb.dcts.scenario.ScenarioId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::zb::dcts::scenario::ScenarioId& id() const;
  ::zb::dcts::scenario::ScenarioId* release_id();
  ::zb::dcts::scenario::ScenarioId* mutable_id();
  void set_allocated_id(::zb::dcts::scenario::ScenarioId* id);
  private:
  const ::zb::dcts::scenario::ScenarioId& _internal_id() const;
  ::zb::dcts::scenario::ScenarioId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::zb::dcts::scenario::ScenarioId* id);
  ::zb::dcts::scenario::ScenarioId* unsafe_arena_release_id();

  // .zb.dcts.source.SourceSetInfo using_sources = 7;
  bool has_using_sources() const;
  private:
  bool _internal_has_using_sources() const;
  public:
  void clear_using_sources();
  const ::zb::dcts::source::SourceSetInfo& using_sources() const;
  ::zb::dcts::source::SourceSetInfo* release_using_sources();
  ::zb::dcts::source::SourceSetInfo* mutable_using_sources();
  void set_allocated_using_sources(::zb::dcts::source::SourceSetInfo* using_sources);
  private:
  const ::zb::dcts::source::SourceSetInfo& _internal_using_sources() const;
  ::zb::dcts::source::SourceSetInfo* _internal_mutable_using_sources();
  public:
  void unsafe_arena_set_allocated_using_sources(
      ::zb::dcts::source::SourceSetInfo* using_sources);
  ::zb::dcts::source::SourceSetInfo* unsafe_arena_release_using_sources();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.ScenarioInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::TaskSummary > tasks_;
  ::zb::dcts::scenario::ScenarioId* id_;
  ::zb::dcts::source::SourceSetInfo* using_sources_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fscenario_2eproto;
};
// -------------------------------------------------------------------

class ScenarioReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.ScenarioReply) */ {
 public:
  inline ScenarioReply() : ScenarioReply(nullptr) {};
  virtual ~ScenarioReply();

  ScenarioReply(const ScenarioReply& from);
  ScenarioReply(ScenarioReply&& from) noexcept
    : ScenarioReply() {
    *this = ::std::move(from);
  }

  inline ScenarioReply& operator=(const ScenarioReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenarioReply& operator=(ScenarioReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenarioReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioReply* internal_default_instance() {
    return reinterpret_cast<const ScenarioReply*>(
               &_ScenarioReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ScenarioReply& a, ScenarioReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenarioReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScenarioReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenarioReply* New() const final {
    return CreateMaybeMessage<ScenarioReply>(nullptr);
  }

  ScenarioReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenarioReply& from);
  void MergeFrom(const ScenarioReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.ScenarioReply";
  }
  protected:
  explicit ScenarioReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fscenario_2eproto);
    return ::descriptor_table_scenario_2fscenario_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponserFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // .zb.dcts.scenario.ScenarioTaskId responser = 1;
  bool has_responser() const;
  private:
  bool _internal_has_responser() const;
  public:
  void clear_responser();
  const ::zb::dcts::scenario::ScenarioTaskId& responser() const;
  ::zb::dcts::scenario::ScenarioTaskId* release_responser();
  ::zb::dcts::scenario::ScenarioTaskId* mutable_responser();
  void set_allocated_responser(::zb::dcts::scenario::ScenarioTaskId* responser);
  private:
  const ::zb::dcts::scenario::ScenarioTaskId& _internal_responser() const;
  ::zb::dcts::scenario::ScenarioTaskId* _internal_mutable_responser();
  public:
  void unsafe_arena_set_allocated_responser(
      ::zb::dcts::scenario::ScenarioTaskId* responser);
  ::zb::dcts::scenario::ScenarioTaskId* unsafe_arena_release_responser();

  // .zb.dcts.ErrorType error_code = 2;
  void clear_error_code();
  ::zb::dcts::ErrorType error_code() const;
  void set_error_code(::zb::dcts::ErrorType value);
  private:
  ::zb::dcts::ErrorType _internal_error_code() const;
  void _internal_set_error_code(::zb::dcts::ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.ScenarioReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::ScenarioTaskId* responser_;
  int error_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fscenario_2eproto;
};
// -------------------------------------------------------------------

class ScenariosInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.ScenariosInfo) */ {
 public:
  inline ScenariosInfo() : ScenariosInfo(nullptr) {};
  virtual ~ScenariosInfo();

  ScenariosInfo(const ScenariosInfo& from);
  ScenariosInfo(ScenariosInfo&& from) noexcept
    : ScenariosInfo() {
    *this = ::std::move(from);
  }

  inline ScenariosInfo& operator=(const ScenariosInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScenariosInfo& operator=(ScenariosInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScenariosInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenariosInfo* internal_default_instance() {
    return reinterpret_cast<const ScenariosInfo*>(
               &_ScenariosInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ScenariosInfo& a, ScenariosInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ScenariosInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScenariosInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScenariosInfo* New() const final {
    return CreateMaybeMessage<ScenariosInfo>(nullptr);
  }

  ScenariosInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScenariosInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScenariosInfo& from);
  void MergeFrom(const ScenariosInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenariosInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.ScenariosInfo";
  }
  protected:
  explicit ScenariosInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fscenario_2eproto);
    return ::descriptor_table_scenario_2fscenario_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScenarioInfoFieldNumber = 1,
  };
  // repeated .zb.dcts.scenario.ScenarioInfo scenario_info = 1;
  int scenario_info_size() const;
  private:
  int _internal_scenario_info_size() const;
  public:
  void clear_scenario_info();
  ::zb::dcts::scenario::ScenarioInfo* mutable_scenario_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::ScenarioInfo >*
      mutable_scenario_info();
  private:
  const ::zb::dcts::scenario::ScenarioInfo& _internal_scenario_info(int index) const;
  ::zb::dcts::scenario::ScenarioInfo* _internal_add_scenario_info();
  public:
  const ::zb::dcts::scenario::ScenarioInfo& scenario_info(int index) const;
  ::zb::dcts::scenario::ScenarioInfo* add_scenario_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::ScenarioInfo >&
      scenario_info() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.ScenariosInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::ScenarioInfo > scenario_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fscenario_2eproto;
};
// -------------------------------------------------------------------

class SubscribeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.SubscribeRequest) */ {
 public:
  inline SubscribeRequest() : SubscribeRequest(nullptr) {};
  virtual ~SubscribeRequest();

  SubscribeRequest(const SubscribeRequest& from);
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubscribeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SubscribeRequest* New() const final {
    return CreateMaybeMessage<SubscribeRequest>(nullptr);
  }

  SubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubscribeRequest& from);
  void MergeFrom(const SubscribeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.SubscribeRequest";
  }
  protected:
  explicit SubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fscenario_2eproto);
    return ::descriptor_table_scenario_2fscenario_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScenarioTaskFieldNumber = 1,
    kTopicFieldNumber = 2,
  };
  // .zb.dcts.scenario.ScenarioTaskId scenario_task = 1;
  bool has_scenario_task() const;
  private:
  bool _internal_has_scenario_task() const;
  public:
  void clear_scenario_task();
  const ::zb::dcts::scenario::ScenarioTaskId& scenario_task() const;
  ::zb::dcts::scenario::ScenarioTaskId* release_scenario_task();
  ::zb::dcts::scenario::ScenarioTaskId* mutable_scenario_task();
  void set_allocated_scenario_task(::zb::dcts::scenario::ScenarioTaskId* scenario_task);
  private:
  const ::zb::dcts::scenario::ScenarioTaskId& _internal_scenario_task() const;
  ::zb::dcts::scenario::ScenarioTaskId* _internal_mutable_scenario_task();
  public:
  void unsafe_arena_set_allocated_scenario_task(
      ::zb::dcts::scenario::ScenarioTaskId* scenario_task);
  ::zb::dcts::scenario::ScenarioTaskId* unsafe_arena_release_scenario_task();

  // .zb.dcts.Topic topic = 2;
  bool has_topic() const;
  private:
  bool _internal_has_topic() const;
  public:
  void clear_topic();
  const ::zb::dcts::Topic& topic() const;
  ::zb::dcts::Topic* release_topic();
  ::zb::dcts::Topic* mutable_topic();
  void set_allocated_topic(::zb::dcts::Topic* topic);
  private:
  const ::zb::dcts::Topic& _internal_topic() const;
  ::zb::dcts::Topic* _internal_mutable_topic();
  public:
  void unsafe_arena_set_allocated_topic(
      ::zb::dcts::Topic* topic);
  ::zb::dcts::Topic* unsafe_arena_release_topic();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.SubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::ScenarioTaskId* scenario_task_;
  ::zb::dcts::Topic* topic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fscenario_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ScenarioId

// uint32 value = 1;
inline void ScenarioId::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ScenarioId::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ScenarioId::value() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.ScenarioId.value)
  return _internal_value();
}
inline void ScenarioId::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void ScenarioId::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.ScenarioId.value)
}

// -------------------------------------------------------------------

// TaskId

// uint32 value = 1;
inline void TaskId::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TaskId::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TaskId::value() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.TaskId.value)
  return _internal_value();
}
inline void TaskId::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void TaskId::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.TaskId.value)
}

// -------------------------------------------------------------------

// ScenarioTaskId

// .zb.dcts.scenario.ScenarioId scenario_id = 1;
inline bool ScenarioTaskId::_internal_has_scenario_id() const {
  return this != internal_default_instance() && scenario_id_ != nullptr;
}
inline bool ScenarioTaskId::has_scenario_id() const {
  return _internal_has_scenario_id();
}
inline void ScenarioTaskId::clear_scenario_id() {
  if (GetArena() == nullptr && scenario_id_ != nullptr) {
    delete scenario_id_;
  }
  scenario_id_ = nullptr;
}
inline const ::zb::dcts::scenario::ScenarioId& ScenarioTaskId::_internal_scenario_id() const {
  const ::zb::dcts::scenario::ScenarioId* p = scenario_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::ScenarioId*>(
      &::zb::dcts::scenario::_ScenarioId_default_instance_);
}
inline const ::zb::dcts::scenario::ScenarioId& ScenarioTaskId::scenario_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.ScenarioTaskId.scenario_id)
  return _internal_scenario_id();
}
inline void ScenarioTaskId::unsafe_arena_set_allocated_scenario_id(
    ::zb::dcts::scenario::ScenarioId* scenario_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scenario_id_);
  }
  scenario_id_ = scenario_id;
  if (scenario_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.ScenarioTaskId.scenario_id)
}
inline ::zb::dcts::scenario::ScenarioId* ScenarioTaskId::release_scenario_id() {
  auto temp = unsafe_arena_release_scenario_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::ScenarioId* ScenarioTaskId::unsafe_arena_release_scenario_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.ScenarioTaskId.scenario_id)
  
  ::zb::dcts::scenario::ScenarioId* temp = scenario_id_;
  scenario_id_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::ScenarioId* ScenarioTaskId::_internal_mutable_scenario_id() {
  
  if (scenario_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::ScenarioId>(GetArena());
    scenario_id_ = p;
  }
  return scenario_id_;
}
inline ::zb::dcts::scenario::ScenarioId* ScenarioTaskId::mutable_scenario_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.ScenarioTaskId.scenario_id)
  return _internal_mutable_scenario_id();
}
inline void ScenarioTaskId::set_allocated_scenario_id(::zb::dcts::scenario::ScenarioId* scenario_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scenario_id_;
  }
  if (scenario_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scenario_id);
    if (message_arena != submessage_arena) {
      scenario_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scenario_id, submessage_arena);
    }
    
  } else {
    
  }
  scenario_id_ = scenario_id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.ScenarioTaskId.scenario_id)
}

// .zb.dcts.scenario.TaskId task_id = 2;
inline bool ScenarioTaskId::_internal_has_task_id() const {
  return this != internal_default_instance() && task_id_ != nullptr;
}
inline bool ScenarioTaskId::has_task_id() const {
  return _internal_has_task_id();
}
inline void ScenarioTaskId::clear_task_id() {
  if (GetArena() == nullptr && task_id_ != nullptr) {
    delete task_id_;
  }
  task_id_ = nullptr;
}
inline const ::zb::dcts::scenario::TaskId& ScenarioTaskId::_internal_task_id() const {
  const ::zb::dcts::scenario::TaskId* p = task_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::TaskId*>(
      &::zb::dcts::scenario::_TaskId_default_instance_);
}
inline const ::zb::dcts::scenario::TaskId& ScenarioTaskId::task_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.ScenarioTaskId.task_id)
  return _internal_task_id();
}
inline void ScenarioTaskId::unsafe_arena_set_allocated_task_id(
    ::zb::dcts::scenario::TaskId* task_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_id_);
  }
  task_id_ = task_id;
  if (task_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.ScenarioTaskId.task_id)
}
inline ::zb::dcts::scenario::TaskId* ScenarioTaskId::release_task_id() {
  auto temp = unsafe_arena_release_task_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::TaskId* ScenarioTaskId::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.ScenarioTaskId.task_id)
  
  ::zb::dcts::scenario::TaskId* temp = task_id_;
  task_id_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::TaskId* ScenarioTaskId::_internal_mutable_task_id() {
  
  if (task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::TaskId>(GetArena());
    task_id_ = p;
  }
  return task_id_;
}
inline ::zb::dcts::scenario::TaskId* ScenarioTaskId::mutable_task_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.ScenarioTaskId.task_id)
  return _internal_mutable_task_id();
}
inline void ScenarioTaskId::set_allocated_task_id(::zb::dcts::scenario::TaskId* task_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete task_id_;
  }
  if (task_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(task_id);
    if (message_arena != submessage_arena) {
      task_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.ScenarioTaskId.task_id)
}

// -------------------------------------------------------------------

// TaskSummary

// .zb.dcts.scenario.TaskId id = 1;
inline bool TaskSummary::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool TaskSummary::has_id() const {
  return _internal_has_id();
}
inline void TaskSummary::clear_id() {
  if (GetArena() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::zb::dcts::scenario::TaskId& TaskSummary::_internal_id() const {
  const ::zb::dcts::scenario::TaskId* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::TaskId*>(
      &::zb::dcts::scenario::_TaskId_default_instance_);
}
inline const ::zb::dcts::scenario::TaskId& TaskSummary::id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.TaskSummary.id)
  return _internal_id();
}
inline void TaskSummary::unsafe_arena_set_allocated_id(
    ::zb::dcts::scenario::TaskId* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.TaskSummary.id)
}
inline ::zb::dcts::scenario::TaskId* TaskSummary::release_id() {
  auto temp = unsafe_arena_release_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::TaskId* TaskSummary::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.TaskSummary.id)
  
  ::zb::dcts::scenario::TaskId* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::TaskId* TaskSummary::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::TaskId>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::zb::dcts::scenario::TaskId* TaskSummary::mutable_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.TaskSummary.id)
  return _internal_mutable_id();
}
inline void TaskSummary::set_allocated_id(::zb::dcts::scenario::TaskId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.TaskSummary.id)
}

// .zb.dcts.scenario.TaskType type = 2;
inline void TaskSummary::clear_type() {
  type_ = 0;
}
inline ::zb::dcts::scenario::TaskType TaskSummary::_internal_type() const {
  return static_cast< ::zb::dcts::scenario::TaskType >(type_);
}
inline ::zb::dcts::scenario::TaskType TaskSummary::type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.TaskSummary.type)
  return _internal_type();
}
inline void TaskSummary::_internal_set_type(::zb::dcts::scenario::TaskType value) {
  
  type_ = value;
}
inline void TaskSummary::set_type(::zb::dcts::scenario::TaskType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.TaskSummary.type)
}

// .zb.dcts.scenario.TaskStatus status = 4;
inline void TaskSummary::clear_status() {
  status_ = 0;
}
inline ::zb::dcts::scenario::TaskStatus TaskSummary::_internal_status() const {
  return static_cast< ::zb::dcts::scenario::TaskStatus >(status_);
}
inline ::zb::dcts::scenario::TaskStatus TaskSummary::status() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.TaskSummary.status)
  return _internal_status();
}
inline void TaskSummary::_internal_set_status(::zb::dcts::scenario::TaskStatus value) {
  
  status_ = value;
}
inline void TaskSummary::set_status(::zb::dcts::scenario::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.TaskSummary.status)
}

// .zb.dcts.Timestamp start_time = 5;
inline bool TaskSummary::_internal_has_start_time() const {
  return this != internal_default_instance() && start_time_ != nullptr;
}
inline bool TaskSummary::has_start_time() const {
  return _internal_has_start_time();
}
inline const ::zb::dcts::Timestamp& TaskSummary::_internal_start_time() const {
  const ::zb::dcts::Timestamp* p = start_time_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Timestamp*>(
      &::zb::dcts::_Timestamp_default_instance_);
}
inline const ::zb::dcts::Timestamp& TaskSummary::start_time() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.TaskSummary.start_time)
  return _internal_start_time();
}
inline void TaskSummary::unsafe_arena_set_allocated_start_time(
    ::zb::dcts::Timestamp* start_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  start_time_ = start_time;
  if (start_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.TaskSummary.start_time)
}
inline ::zb::dcts::Timestamp* TaskSummary::release_start_time() {
  auto temp = unsafe_arena_release_start_time();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Timestamp* TaskSummary::unsafe_arena_release_start_time() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.TaskSummary.start_time)
  
  ::zb::dcts::Timestamp* temp = start_time_;
  start_time_ = nullptr;
  return temp;
}
inline ::zb::dcts::Timestamp* TaskSummary::_internal_mutable_start_time() {
  
  if (start_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Timestamp>(GetArena());
    start_time_ = p;
  }
  return start_time_;
}
inline ::zb::dcts::Timestamp* TaskSummary::mutable_start_time() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.TaskSummary.start_time)
  return _internal_mutable_start_time();
}
inline void TaskSummary::set_allocated_start_time(::zb::dcts::Timestamp* start_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time_);
  }
  if (start_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_time)->GetArena();
    if (message_arena != submessage_arena) {
      start_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_time, submessage_arena);
    }
    
  } else {
    
  }
  start_time_ = start_time;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.TaskSummary.start_time)
}

// repeated .zb.dcts.Topic topics = 6;
inline int TaskSummary::_internal_topics_size() const {
  return topics_.size();
}
inline int TaskSummary::topics_size() const {
  return _internal_topics_size();
}
inline ::zb::dcts::Topic* TaskSummary::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.TaskSummary.topics)
  return topics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::Topic >*
TaskSummary::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.TaskSummary.topics)
  return &topics_;
}
inline const ::zb::dcts::Topic& TaskSummary::_internal_topics(int index) const {
  return topics_.Get(index);
}
inline const ::zb::dcts::Topic& TaskSummary::topics(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.TaskSummary.topics)
  return _internal_topics(index);
}
inline ::zb::dcts::Topic* TaskSummary::_internal_add_topics() {
  return topics_.Add();
}
inline ::zb::dcts::Topic* TaskSummary::add_topics() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.TaskSummary.topics)
  return _internal_add_topics();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::Topic >&
TaskSummary::topics() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.TaskSummary.topics)
  return topics_;
}

// -------------------------------------------------------------------

// ScenarioInfo

// .zb.dcts.scenario.ScenarioId id = 1;
inline bool ScenarioInfo::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool ScenarioInfo::has_id() const {
  return _internal_has_id();
}
inline void ScenarioInfo::clear_id() {
  if (GetArena() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::zb::dcts::scenario::ScenarioId& ScenarioInfo::_internal_id() const {
  const ::zb::dcts::scenario::ScenarioId* p = id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::ScenarioId*>(
      &::zb::dcts::scenario::_ScenarioId_default_instance_);
}
inline const ::zb::dcts::scenario::ScenarioId& ScenarioInfo::id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.ScenarioInfo.id)
  return _internal_id();
}
inline void ScenarioInfo::unsafe_arena_set_allocated_id(
    ::zb::dcts::scenario::ScenarioId* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.ScenarioInfo.id)
}
inline ::zb::dcts::scenario::ScenarioId* ScenarioInfo::release_id() {
  auto temp = unsafe_arena_release_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::ScenarioId* ScenarioInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.ScenarioInfo.id)
  
  ::zb::dcts::scenario::ScenarioId* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::ScenarioId* ScenarioInfo::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::ScenarioId>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::zb::dcts::scenario::ScenarioId* ScenarioInfo::mutable_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.ScenarioInfo.id)
  return _internal_mutable_id();
}
inline void ScenarioInfo::set_allocated_id(::zb::dcts::scenario::ScenarioId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.ScenarioInfo.id)
}

// repeated .zb.dcts.scenario.TaskSummary tasks = 6;
inline int ScenarioInfo::_internal_tasks_size() const {
  return tasks_.size();
}
inline int ScenarioInfo::tasks_size() const {
  return _internal_tasks_size();
}
inline void ScenarioInfo::clear_tasks() {
  tasks_.Clear();
}
inline ::zb::dcts::scenario::TaskSummary* ScenarioInfo::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.ScenarioInfo.tasks)
  return tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::TaskSummary >*
ScenarioInfo::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.ScenarioInfo.tasks)
  return &tasks_;
}
inline const ::zb::dcts::scenario::TaskSummary& ScenarioInfo::_internal_tasks(int index) const {
  return tasks_.Get(index);
}
inline const ::zb::dcts::scenario::TaskSummary& ScenarioInfo::tasks(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.ScenarioInfo.tasks)
  return _internal_tasks(index);
}
inline ::zb::dcts::scenario::TaskSummary* ScenarioInfo::_internal_add_tasks() {
  return tasks_.Add();
}
inline ::zb::dcts::scenario::TaskSummary* ScenarioInfo::add_tasks() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.ScenarioInfo.tasks)
  return _internal_add_tasks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::TaskSummary >&
ScenarioInfo::tasks() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.ScenarioInfo.tasks)
  return tasks_;
}

// .zb.dcts.source.SourceSetInfo using_sources = 7;
inline bool ScenarioInfo::_internal_has_using_sources() const {
  return this != internal_default_instance() && using_sources_ != nullptr;
}
inline bool ScenarioInfo::has_using_sources() const {
  return _internal_has_using_sources();
}
inline const ::zb::dcts::source::SourceSetInfo& ScenarioInfo::_internal_using_sources() const {
  const ::zb::dcts::source::SourceSetInfo* p = using_sources_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::SourceSetInfo*>(
      &::zb::dcts::source::_SourceSetInfo_default_instance_);
}
inline const ::zb::dcts::source::SourceSetInfo& ScenarioInfo::using_sources() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.ScenarioInfo.using_sources)
  return _internal_using_sources();
}
inline void ScenarioInfo::unsafe_arena_set_allocated_using_sources(
    ::zb::dcts::source::SourceSetInfo* using_sources) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(using_sources_);
  }
  using_sources_ = using_sources;
  if (using_sources) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.ScenarioInfo.using_sources)
}
inline ::zb::dcts::source::SourceSetInfo* ScenarioInfo::release_using_sources() {
  auto temp = unsafe_arena_release_using_sources();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::SourceSetInfo* ScenarioInfo::unsafe_arena_release_using_sources() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.ScenarioInfo.using_sources)
  
  ::zb::dcts::source::SourceSetInfo* temp = using_sources_;
  using_sources_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::SourceSetInfo* ScenarioInfo::_internal_mutable_using_sources() {
  
  if (using_sources_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::SourceSetInfo>(GetArena());
    using_sources_ = p;
  }
  return using_sources_;
}
inline ::zb::dcts::source::SourceSetInfo* ScenarioInfo::mutable_using_sources() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.ScenarioInfo.using_sources)
  return _internal_mutable_using_sources();
}
inline void ScenarioInfo::set_allocated_using_sources(::zb::dcts::source::SourceSetInfo* using_sources) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(using_sources_);
  }
  if (using_sources) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(using_sources)->GetArena();
    if (message_arena != submessage_arena) {
      using_sources = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, using_sources, submessage_arena);
    }
    
  } else {
    
  }
  using_sources_ = using_sources;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.ScenarioInfo.using_sources)
}

// -------------------------------------------------------------------

// ScenarioReply

// .zb.dcts.scenario.ScenarioTaskId responser = 1;
inline bool ScenarioReply::_internal_has_responser() const {
  return this != internal_default_instance() && responser_ != nullptr;
}
inline bool ScenarioReply::has_responser() const {
  return _internal_has_responser();
}
inline void ScenarioReply::clear_responser() {
  if (GetArena() == nullptr && responser_ != nullptr) {
    delete responser_;
  }
  responser_ = nullptr;
}
inline const ::zb::dcts::scenario::ScenarioTaskId& ScenarioReply::_internal_responser() const {
  const ::zb::dcts::scenario::ScenarioTaskId* p = responser_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::ScenarioTaskId*>(
      &::zb::dcts::scenario::_ScenarioTaskId_default_instance_);
}
inline const ::zb::dcts::scenario::ScenarioTaskId& ScenarioReply::responser() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.ScenarioReply.responser)
  return _internal_responser();
}
inline void ScenarioReply::unsafe_arena_set_allocated_responser(
    ::zb::dcts::scenario::ScenarioTaskId* responser) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(responser_);
  }
  responser_ = responser;
  if (responser) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.ScenarioReply.responser)
}
inline ::zb::dcts::scenario::ScenarioTaskId* ScenarioReply::release_responser() {
  auto temp = unsafe_arena_release_responser();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::ScenarioTaskId* ScenarioReply::unsafe_arena_release_responser() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.ScenarioReply.responser)
  
  ::zb::dcts::scenario::ScenarioTaskId* temp = responser_;
  responser_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::ScenarioTaskId* ScenarioReply::_internal_mutable_responser() {
  
  if (responser_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::ScenarioTaskId>(GetArena());
    responser_ = p;
  }
  return responser_;
}
inline ::zb::dcts::scenario::ScenarioTaskId* ScenarioReply::mutable_responser() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.ScenarioReply.responser)
  return _internal_mutable_responser();
}
inline void ScenarioReply::set_allocated_responser(::zb::dcts::scenario::ScenarioTaskId* responser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete responser_;
  }
  if (responser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(responser);
    if (message_arena != submessage_arena) {
      responser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, responser, submessage_arena);
    }
    
  } else {
    
  }
  responser_ = responser;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.ScenarioReply.responser)
}

// .zb.dcts.ErrorType error_code = 2;
inline void ScenarioReply::clear_error_code() {
  error_code_ = 0;
}
inline ::zb::dcts::ErrorType ScenarioReply::_internal_error_code() const {
  return static_cast< ::zb::dcts::ErrorType >(error_code_);
}
inline ::zb::dcts::ErrorType ScenarioReply::error_code() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.ScenarioReply.error_code)
  return _internal_error_code();
}
inline void ScenarioReply::_internal_set_error_code(::zb::dcts::ErrorType value) {
  
  error_code_ = value;
}
inline void ScenarioReply::set_error_code(::zb::dcts::ErrorType value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.ScenarioReply.error_code)
}

// -------------------------------------------------------------------

// ScenariosInfo

// repeated .zb.dcts.scenario.ScenarioInfo scenario_info = 1;
inline int ScenariosInfo::_internal_scenario_info_size() const {
  return scenario_info_.size();
}
inline int ScenariosInfo::scenario_info_size() const {
  return _internal_scenario_info_size();
}
inline void ScenariosInfo::clear_scenario_info() {
  scenario_info_.Clear();
}
inline ::zb::dcts::scenario::ScenarioInfo* ScenariosInfo::mutable_scenario_info(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.ScenariosInfo.scenario_info)
  return scenario_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::ScenarioInfo >*
ScenariosInfo::mutable_scenario_info() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.ScenariosInfo.scenario_info)
  return &scenario_info_;
}
inline const ::zb::dcts::scenario::ScenarioInfo& ScenariosInfo::_internal_scenario_info(int index) const {
  return scenario_info_.Get(index);
}
inline const ::zb::dcts::scenario::ScenarioInfo& ScenariosInfo::scenario_info(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.ScenariosInfo.scenario_info)
  return _internal_scenario_info(index);
}
inline ::zb::dcts::scenario::ScenarioInfo* ScenariosInfo::_internal_add_scenario_info() {
  return scenario_info_.Add();
}
inline ::zb::dcts::scenario::ScenarioInfo* ScenariosInfo::add_scenario_info() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.ScenariosInfo.scenario_info)
  return _internal_add_scenario_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::ScenarioInfo >&
ScenariosInfo::scenario_info() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.ScenariosInfo.scenario_info)
  return scenario_info_;
}

// -------------------------------------------------------------------

// SubscribeRequest

// .zb.dcts.scenario.ScenarioTaskId scenario_task = 1;
inline bool SubscribeRequest::_internal_has_scenario_task() const {
  return this != internal_default_instance() && scenario_task_ != nullptr;
}
inline bool SubscribeRequest::has_scenario_task() const {
  return _internal_has_scenario_task();
}
inline void SubscribeRequest::clear_scenario_task() {
  if (GetArena() == nullptr && scenario_task_ != nullptr) {
    delete scenario_task_;
  }
  scenario_task_ = nullptr;
}
inline const ::zb::dcts::scenario::ScenarioTaskId& SubscribeRequest::_internal_scenario_task() const {
  const ::zb::dcts::scenario::ScenarioTaskId* p = scenario_task_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::ScenarioTaskId*>(
      &::zb::dcts::scenario::_ScenarioTaskId_default_instance_);
}
inline const ::zb::dcts::scenario::ScenarioTaskId& SubscribeRequest::scenario_task() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.SubscribeRequest.scenario_task)
  return _internal_scenario_task();
}
inline void SubscribeRequest::unsafe_arena_set_allocated_scenario_task(
    ::zb::dcts::scenario::ScenarioTaskId* scenario_task) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scenario_task_);
  }
  scenario_task_ = scenario_task;
  if (scenario_task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.SubscribeRequest.scenario_task)
}
inline ::zb::dcts::scenario::ScenarioTaskId* SubscribeRequest::release_scenario_task() {
  auto temp = unsafe_arena_release_scenario_task();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::ScenarioTaskId* SubscribeRequest::unsafe_arena_release_scenario_task() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.SubscribeRequest.scenario_task)
  
  ::zb::dcts::scenario::ScenarioTaskId* temp = scenario_task_;
  scenario_task_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::ScenarioTaskId* SubscribeRequest::_internal_mutable_scenario_task() {
  
  if (scenario_task_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::ScenarioTaskId>(GetArena());
    scenario_task_ = p;
  }
  return scenario_task_;
}
inline ::zb::dcts::scenario::ScenarioTaskId* SubscribeRequest::mutable_scenario_task() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.SubscribeRequest.scenario_task)
  return _internal_mutable_scenario_task();
}
inline void SubscribeRequest::set_allocated_scenario_task(::zb::dcts::scenario::ScenarioTaskId* scenario_task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scenario_task_;
  }
  if (scenario_task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scenario_task);
    if (message_arena != submessage_arena) {
      scenario_task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scenario_task, submessage_arena);
    }
    
  } else {
    
  }
  scenario_task_ = scenario_task;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.SubscribeRequest.scenario_task)
}

// .zb.dcts.Topic topic = 2;
inline bool SubscribeRequest::_internal_has_topic() const {
  return this != internal_default_instance() && topic_ != nullptr;
}
inline bool SubscribeRequest::has_topic() const {
  return _internal_has_topic();
}
inline const ::zb::dcts::Topic& SubscribeRequest::_internal_topic() const {
  const ::zb::dcts::Topic* p = topic_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Topic*>(
      &::zb::dcts::_Topic_default_instance_);
}
inline const ::zb::dcts::Topic& SubscribeRequest::topic() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.SubscribeRequest.topic)
  return _internal_topic();
}
inline void SubscribeRequest::unsafe_arena_set_allocated_topic(
    ::zb::dcts::Topic* topic) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  topic_ = topic;
  if (topic) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.SubscribeRequest.topic)
}
inline ::zb::dcts::Topic* SubscribeRequest::release_topic() {
  auto temp = unsafe_arena_release_topic();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Topic* SubscribeRequest::unsafe_arena_release_topic() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.SubscribeRequest.topic)
  
  ::zb::dcts::Topic* temp = topic_;
  topic_ = nullptr;
  return temp;
}
inline ::zb::dcts::Topic* SubscribeRequest::_internal_mutable_topic() {
  
  if (topic_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Topic>(GetArena());
    topic_ = p;
  }
  return topic_;
}
inline ::zb::dcts::Topic* SubscribeRequest::mutable_topic() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.SubscribeRequest.topic)
  return _internal_mutable_topic();
}
inline void SubscribeRequest::set_allocated_topic(::zb::dcts::Topic* topic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic_);
  }
  if (topic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(topic)->GetArena();
    if (message_arena != submessage_arena) {
      topic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topic, submessage_arena);
    }
    
  } else {
    
  }
  topic_ = topic;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.SubscribeRequest.topic)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace scenario
}  // namespace dcts
}  // namespace zb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zb::dcts::scenario::TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::scenario::TaskType>() {
  return ::zb::dcts::scenario::TaskType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::scenario::TaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::scenario::TaskStatus>() {
  return ::zb::dcts::scenario::TaskStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scenario_2fscenario_2eproto
