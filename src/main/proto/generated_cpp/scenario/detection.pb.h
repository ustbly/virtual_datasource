// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scenario/detection.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scenario_2fdetection_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scenario_2fdetection_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dcts.pb.h"
#include "source/source.pb.h"
#include "scenario/spectrum.pb.h"
#include "scenario/scenario.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scenario_2fdetection_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scenario_2fdetection_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scenario_2fdetection_2eproto;
namespace zb {
namespace dcts {
namespace scenario {
namespace detection {
class AdaptiveThresholdParam;
class AdaptiveThresholdParamDefaultTypeInternal;
extern AdaptiveThresholdParamDefaultTypeInternal _AdaptiveThresholdParam_default_instance_;
class AutoGatheringParam;
class AutoGatheringParamDefaultTypeInternal;
extern AutoGatheringParamDefaultTypeInternal _AutoGatheringParam_default_instance_;
class DetectionParam;
class DetectionParamDefaultTypeInternal;
extern DetectionParamDefaultTypeInternal _DetectionParam_default_instance_;
class DetectionRequest;
class DetectionRequestDefaultTypeInternal;
extern DetectionRequestDefaultTypeInternal _DetectionRequest_default_instance_;
class DeviceDetectResult;
class DeviceDetectResultDefaultTypeInternal;
extern DeviceDetectResultDefaultTypeInternal _DeviceDetectResult_default_instance_;
class EnergyDetectionParam;
class EnergyDetectionParamDefaultTypeInternal;
extern EnergyDetectionParamDefaultTypeInternal _EnergyDetectionParam_default_instance_;
class FixSignalList;
class FixSignalListDefaultTypeInternal;
extern FixSignalListDefaultTypeInternal _FixSignalList_default_instance_;
class FreqSpanFilter;
class FreqSpanFilterDefaultTypeInternal;
extern FreqSpanFilterDefaultTypeInternal _FreqSpanFilter_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class HistoryThresholdParam;
class HistoryThresholdParamDefaultTypeInternal;
extern HistoryThresholdParamDefaultTypeInternal _HistoryThresholdParam_default_instance_;
class HopSignalCluster;
class HopSignalClusterDefaultTypeInternal;
extern HopSignalClusterDefaultTypeInternal _HopSignalCluster_default_instance_;
class HopSignalClusterParam;
class HopSignalClusterParamDefaultTypeInternal;
extern HopSignalClusterParamDefaultTypeInternal _HopSignalClusterParam_default_instance_;
class HopSignalDetectionParam;
class HopSignalDetectionParamDefaultTypeInternal;
extern HopSignalDetectionParamDefaultTypeInternal _HopSignalDetectionParam_default_instance_;
class HopSignalDigest;
class HopSignalDigestDefaultTypeInternal;
extern HopSignalDigestDefaultTypeInternal _HopSignalDigest_default_instance_;
class HopSignalList;
class HopSignalListDefaultTypeInternal;
extern HopSignalListDefaultTypeInternal _HopSignalList_default_instance_;
class ManualGatheringParam;
class ManualGatheringParamDefaultTypeInternal;
extern ManualGatheringParamDefaultTypeInternal _ManualGatheringParam_default_instance_;
class NeighborVarThresholdParam;
class NeighborVarThresholdParamDefaultTypeInternal;
extern NeighborVarThresholdParamDefaultTypeInternal _NeighborVarThresholdParam_default_instance_;
class RawBody;
class RawBodyDefaultTypeInternal;
extern RawBodyDefaultTypeInternal _RawBody_default_instance_;
class RawData;
class RawDataDefaultTypeInternal;
extern RawDataDefaultTypeInternal _RawData_default_instance_;
class SignalDetectParam;
class SignalDetectParamDefaultTypeInternal;
extern SignalDetectParamDefaultTypeInternal _SignalDetectParam_default_instance_;
class SignalDigest;
class SignalDigestDefaultTypeInternal;
extern SignalDigestDefaultTypeInternal _SignalDigest_default_instance_;
class SignalFeature;
class SignalFeatureDefaultTypeInternal;
extern SignalFeatureDefaultTypeInternal _SignalFeature_default_instance_;
class SignalGatheringRequest;
class SignalGatheringRequestDefaultTypeInternal;
extern SignalGatheringRequestDefaultTypeInternal _SignalGatheringRequest_default_instance_;
class SignalLayerSurvey;
class SignalLayerSurveyDefaultTypeInternal;
extern SignalLayerSurveyDefaultTypeInternal _SignalLayerSurvey_default_instance_;
class SignalSample;
class SignalSampleDefaultTypeInternal;
extern SignalSampleDefaultTypeInternal _SignalSample_default_instance_;
class SignalSampleList;
class SignalSampleListDefaultTypeInternal;
extern SignalSampleListDefaultTypeInternal _SignalSampleList_default_instance_;
class SignalSegment;
class SignalSegmentDefaultTypeInternal;
extern SignalSegmentDefaultTypeInternal _SignalSegment_default_instance_;
class SignalSegmentationParam;
class SignalSegmentationParamDefaultTypeInternal;
extern SignalSegmentationParamDefaultTypeInternal _SignalSegmentationParam_default_instance_;
class SignalTableQueryRequest;
class SignalTableQueryRequestDefaultTypeInternal;
extern SignalTableQueryRequestDefaultTypeInternal _SignalTableQueryRequest_default_instance_;
class SignalTableQueryResponse;
class SignalTableQueryResponseDefaultTypeInternal;
extern SignalTableQueryResponseDefaultTypeInternal _SignalTableQueryResponse_default_instance_;
class ThresholdSector;
class ThresholdSectorDefaultTypeInternal;
extern ThresholdSectorDefaultTypeInternal _ThresholdSector_default_instance_;
class ThresholdTrace;
class ThresholdTraceDefaultTypeInternal;
extern ThresholdTraceDefaultTypeInternal _ThresholdTrace_default_instance_;
class UserThresholdParam;
class UserThresholdParamDefaultTypeInternal;
extern UserThresholdParamDefaultTypeInternal _UserThresholdParam_default_instance_;
}  // namespace detection
}  // namespace scenario
}  // namespace dcts
}  // namespace zb
PROTOBUF_NAMESPACE_OPEN
template<> ::zb::dcts::scenario::detection::AdaptiveThresholdParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::AdaptiveThresholdParam>(Arena*);
template<> ::zb::dcts::scenario::detection::AutoGatheringParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::AutoGatheringParam>(Arena*);
template<> ::zb::dcts::scenario::detection::DetectionParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::DetectionParam>(Arena*);
template<> ::zb::dcts::scenario::detection::DetectionRequest* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::DetectionRequest>(Arena*);
template<> ::zb::dcts::scenario::detection::DeviceDetectResult* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::DeviceDetectResult>(Arena*);
template<> ::zb::dcts::scenario::detection::EnergyDetectionParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::EnergyDetectionParam>(Arena*);
template<> ::zb::dcts::scenario::detection::FixSignalList* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::FixSignalList>(Arena*);
template<> ::zb::dcts::scenario::detection::FreqSpanFilter* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::FreqSpanFilter>(Arena*);
template<> ::zb::dcts::scenario::detection::Header* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::Header>(Arena*);
template<> ::zb::dcts::scenario::detection::HistoryThresholdParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::HistoryThresholdParam>(Arena*);
template<> ::zb::dcts::scenario::detection::HopSignalCluster* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::HopSignalCluster>(Arena*);
template<> ::zb::dcts::scenario::detection::HopSignalClusterParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::HopSignalClusterParam>(Arena*);
template<> ::zb::dcts::scenario::detection::HopSignalDetectionParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::HopSignalDetectionParam>(Arena*);
template<> ::zb::dcts::scenario::detection::HopSignalDigest* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::HopSignalDigest>(Arena*);
template<> ::zb::dcts::scenario::detection::HopSignalList* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::HopSignalList>(Arena*);
template<> ::zb::dcts::scenario::detection::ManualGatheringParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::ManualGatheringParam>(Arena*);
template<> ::zb::dcts::scenario::detection::NeighborVarThresholdParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::NeighborVarThresholdParam>(Arena*);
template<> ::zb::dcts::scenario::detection::RawBody* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::RawBody>(Arena*);
template<> ::zb::dcts::scenario::detection::RawData* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::RawData>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalDetectParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalDetectParam>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalDigest* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalDigest>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalFeature* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalFeature>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalGatheringRequest* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalGatheringRequest>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalLayerSurvey* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalLayerSurvey>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalSample* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalSample>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalSampleList* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalSampleList>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalSegment* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalSegment>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalSegmentationParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalSegmentationParam>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalTableQueryRequest* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalTableQueryRequest>(Arena*);
template<> ::zb::dcts::scenario::detection::SignalTableQueryResponse* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::SignalTableQueryResponse>(Arena*);
template<> ::zb::dcts::scenario::detection::ThresholdSector* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::ThresholdSector>(Arena*);
template<> ::zb::dcts::scenario::detection::ThresholdTrace* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::ThresholdTrace>(Arena*);
template<> ::zb::dcts::scenario::detection::UserThresholdParam* Arena::CreateMaybeMessage<::zb::dcts::scenario::detection::UserThresholdParam>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zb {
namespace dcts {
namespace scenario {
namespace detection {

enum AdaptiveThresholdParam_PartitionMode : int {
  AdaptiveThresholdParam_PartitionMode_PM_STANDARD = 0,
  AdaptiveThresholdParam_PartitionMode_PM_AGGRESIVE = 1,
  AdaptiveThresholdParam_PartitionMode_PM_FAST = 2,
  AdaptiveThresholdParam_PartitionMode_AdaptiveThresholdParam_PartitionMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AdaptiveThresholdParam_PartitionMode_AdaptiveThresholdParam_PartitionMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AdaptiveThresholdParam_PartitionMode_IsValid(int value);
constexpr AdaptiveThresholdParam_PartitionMode AdaptiveThresholdParam_PartitionMode_PartitionMode_MIN = AdaptiveThresholdParam_PartitionMode_PM_STANDARD;
constexpr AdaptiveThresholdParam_PartitionMode AdaptiveThresholdParam_PartitionMode_PartitionMode_MAX = AdaptiveThresholdParam_PartitionMode_PM_FAST;
constexpr int AdaptiveThresholdParam_PartitionMode_PartitionMode_ARRAYSIZE = AdaptiveThresholdParam_PartitionMode_PartitionMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdaptiveThresholdParam_PartitionMode_descriptor();
template<typename T>
inline const std::string& AdaptiveThresholdParam_PartitionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdaptiveThresholdParam_PartitionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdaptiveThresholdParam_PartitionMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdaptiveThresholdParam_PartitionMode_descriptor(), enum_t_value);
}
inline bool AdaptiveThresholdParam_PartitionMode_Parse(
    const std::string& name, AdaptiveThresholdParam_PartitionMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdaptiveThresholdParam_PartitionMode>(
    AdaptiveThresholdParam_PartitionMode_descriptor(), name, value);
}
enum EnergyDetectionParam_LogicType : int {
  EnergyDetectionParam_LogicType_LT_AND = 0,
  EnergyDetectionParam_LogicType_LT_OR = 1,
  EnergyDetectionParam_LogicType_EnergyDetectionParam_LogicType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EnergyDetectionParam_LogicType_EnergyDetectionParam_LogicType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EnergyDetectionParam_LogicType_IsValid(int value);
constexpr EnergyDetectionParam_LogicType EnergyDetectionParam_LogicType_LogicType_MIN = EnergyDetectionParam_LogicType_LT_AND;
constexpr EnergyDetectionParam_LogicType EnergyDetectionParam_LogicType_LogicType_MAX = EnergyDetectionParam_LogicType_LT_OR;
constexpr int EnergyDetectionParam_LogicType_LogicType_ARRAYSIZE = EnergyDetectionParam_LogicType_LogicType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EnergyDetectionParam_LogicType_descriptor();
template<typename T>
inline const std::string& EnergyDetectionParam_LogicType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnergyDetectionParam_LogicType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnergyDetectionParam_LogicType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EnergyDetectionParam_LogicType_descriptor(), enum_t_value);
}
inline bool EnergyDetectionParam_LogicType_Parse(
    const std::string& name, EnergyDetectionParam_LogicType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EnergyDetectionParam_LogicType>(
    EnergyDetectionParam_LogicType_descriptor(), name, value);
}
enum ThresholdType : int {
  HISTORY = 0,
  USER_DEFINE = 1,
  ADAPTIVE = 2,
  NEIGHBOR = 3,
  ThresholdType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ThresholdType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ThresholdType_IsValid(int value);
constexpr ThresholdType ThresholdType_MIN = HISTORY;
constexpr ThresholdType ThresholdType_MAX = NEIGHBOR;
constexpr int ThresholdType_ARRAYSIZE = ThresholdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThresholdType_descriptor();
template<typename T>
inline const std::string& ThresholdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThresholdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThresholdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ThresholdType_descriptor(), enum_t_value);
}
inline bool ThresholdType_Parse(
    const std::string& name, ThresholdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ThresholdType>(
    ThresholdType_descriptor(), name, value);
}
enum SignalActivity : int {
  UNKNOWN = 0,
  ACTIVE = 1,
  INACTIVE = 2,
  DECAYED = 4,
  REMOVED = 8,
  SignalActivity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SignalActivity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SignalActivity_IsValid(int value);
constexpr SignalActivity SignalActivity_MIN = UNKNOWN;
constexpr SignalActivity SignalActivity_MAX = REMOVED;
constexpr int SignalActivity_ARRAYSIZE = SignalActivity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignalActivity_descriptor();
template<typename T>
inline const std::string& SignalActivity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignalActivity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignalActivity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignalActivity_descriptor(), enum_t_value);
}
inline bool SignalActivity_Parse(
    const std::string& name, SignalActivity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignalActivity>(
    SignalActivity_descriptor(), name, value);
}
// ===================================================================

class ThresholdSector PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.ThresholdSector) */ {
 public:
  inline ThresholdSector() : ThresholdSector(nullptr) {};
  virtual ~ThresholdSector();

  ThresholdSector(const ThresholdSector& from);
  ThresholdSector(ThresholdSector&& from) noexcept
    : ThresholdSector() {
    *this = ::std::move(from);
  }

  inline ThresholdSector& operator=(const ThresholdSector& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThresholdSector& operator=(ThresholdSector&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThresholdSector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThresholdSector* internal_default_instance() {
    return reinterpret_cast<const ThresholdSector*>(
               &_ThresholdSector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ThresholdSector& a, ThresholdSector& b) {
    a.Swap(&b);
  }
  inline void Swap(ThresholdSector* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThresholdSector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThresholdSector* New() const final {
    return CreateMaybeMessage<ThresholdSector>(nullptr);
  }

  ThresholdSector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThresholdSector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThresholdSector& from);
  void MergeFrom(const ThresholdSector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThresholdSector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.ThresholdSector";
  }
  protected:
  explicit ThresholdSector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFreqSpanFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // .zb.dcts.scenario.spectrum.FrequencySpan freq_span = 1;
  bool has_freq_span() const;
  private:
  bool _internal_has_freq_span() const;
  public:
  void clear_freq_span();
  const ::zb::dcts::scenario::spectrum::FrequencySpan& freq_span() const;
  ::zb::dcts::scenario::spectrum::FrequencySpan* release_freq_span();
  ::zb::dcts::scenario::spectrum::FrequencySpan* mutable_freq_span();
  void set_allocated_freq_span(::zb::dcts::scenario::spectrum::FrequencySpan* freq_span);
  private:
  const ::zb::dcts::scenario::spectrum::FrequencySpan& _internal_freq_span() const;
  ::zb::dcts::scenario::spectrum::FrequencySpan* _internal_mutable_freq_span();
  public:
  void unsafe_arena_set_allocated_freq_span(
      ::zb::dcts::scenario::spectrum::FrequencySpan* freq_span);
  ::zb::dcts::scenario::spectrum::FrequencySpan* unsafe_arena_release_freq_span();

  // float level = 2;
  void clear_level();
  float level() const;
  void set_level(float value);
  private:
  float _internal_level() const;
  void _internal_set_level(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.ThresholdSector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::spectrum::FrequencySpan* freq_span_;
  float level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class UserThresholdParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.UserThresholdParam) */ {
 public:
  inline UserThresholdParam() : UserThresholdParam(nullptr) {};
  virtual ~UserThresholdParam();

  UserThresholdParam(const UserThresholdParam& from);
  UserThresholdParam(UserThresholdParam&& from) noexcept
    : UserThresholdParam() {
    *this = ::std::move(from);
  }

  inline UserThresholdParam& operator=(const UserThresholdParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserThresholdParam& operator=(UserThresholdParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserThresholdParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserThresholdParam* internal_default_instance() {
    return reinterpret_cast<const UserThresholdParam*>(
               &_UserThresholdParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserThresholdParam& a, UserThresholdParam& b) {
    a.Swap(&b);
  }
  inline void Swap(UserThresholdParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserThresholdParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserThresholdParam* New() const final {
    return CreateMaybeMessage<UserThresholdParam>(nullptr);
  }

  UserThresholdParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserThresholdParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserThresholdParam& from);
  void MergeFrom(const UserThresholdParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserThresholdParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.UserThresholdParam";
  }
  protected:
  explicit UserThresholdParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSectorsFieldNumber = 1,
  };
  // repeated .zb.dcts.scenario.detection.ThresholdSector sectors = 1;
  int sectors_size() const;
  private:
  int _internal_sectors_size() const;
  public:
  void clear_sectors();
  ::zb::dcts::scenario::detection::ThresholdSector* mutable_sectors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::ThresholdSector >*
      mutable_sectors();
  private:
  const ::zb::dcts::scenario::detection::ThresholdSector& _internal_sectors(int index) const;
  ::zb::dcts::scenario::detection::ThresholdSector* _internal_add_sectors();
  public:
  const ::zb::dcts::scenario::detection::ThresholdSector& sectors(int index) const;
  ::zb::dcts::scenario::detection::ThresholdSector* add_sectors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::ThresholdSector >&
      sectors() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.UserThresholdParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::ThresholdSector > sectors_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class HistoryThresholdParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.HistoryThresholdParam) */ {
 public:
  inline HistoryThresholdParam() : HistoryThresholdParam(nullptr) {};
  virtual ~HistoryThresholdParam();

  HistoryThresholdParam(const HistoryThresholdParam& from);
  HistoryThresholdParam(HistoryThresholdParam&& from) noexcept
    : HistoryThresholdParam() {
    *this = ::std::move(from);
  }

  inline HistoryThresholdParam& operator=(const HistoryThresholdParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoryThresholdParam& operator=(HistoryThresholdParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HistoryThresholdParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HistoryThresholdParam* internal_default_instance() {
    return reinterpret_cast<const HistoryThresholdParam*>(
               &_HistoryThresholdParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HistoryThresholdParam& a, HistoryThresholdParam& b) {
    a.Swap(&b);
  }
  inline void Swap(HistoryThresholdParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoryThresholdParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HistoryThresholdParam* New() const final {
    return CreateMaybeMessage<HistoryThresholdParam>(nullptr);
  }

  HistoryThresholdParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HistoryThresholdParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HistoryThresholdParam& from);
  void MergeFrom(const HistoryThresholdParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoryThresholdParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.HistoryThresholdParam";
  }
  protected:
  explicit HistoryThresholdParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpanFieldNumber = 1,
    kMaxLoadCountFieldNumber = 3,
    kOffsetFieldNumber = 4,
  };
  // .zb.dcts.TimeSpan span = 1;
  bool has_span() const;
  private:
  bool _internal_has_span() const;
  public:
  void clear_span();
  const ::zb::dcts::TimeSpan& span() const;
  ::zb::dcts::TimeSpan* release_span();
  ::zb::dcts::TimeSpan* mutable_span();
  void set_allocated_span(::zb::dcts::TimeSpan* span);
  private:
  const ::zb::dcts::TimeSpan& _internal_span() const;
  ::zb::dcts::TimeSpan* _internal_mutable_span();
  public:
  void unsafe_arena_set_allocated_span(
      ::zb::dcts::TimeSpan* span);
  ::zb::dcts::TimeSpan* unsafe_arena_release_span();

  // int32 max_load_count = 3;
  void clear_max_load_count();
  ::PROTOBUF_NAMESPACE_ID::int32 max_load_count() const;
  void set_max_load_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_load_count() const;
  void _internal_set_max_load_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float offset = 4;
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.HistoryThresholdParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::TimeSpan* span_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_load_count_;
  float offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class AdaptiveThresholdParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.AdaptiveThresholdParam) */ {
 public:
  inline AdaptiveThresholdParam() : AdaptiveThresholdParam(nullptr) {};
  virtual ~AdaptiveThresholdParam();

  AdaptiveThresholdParam(const AdaptiveThresholdParam& from);
  AdaptiveThresholdParam(AdaptiveThresholdParam&& from) noexcept
    : AdaptiveThresholdParam() {
    *this = ::std::move(from);
  }

  inline AdaptiveThresholdParam& operator=(const AdaptiveThresholdParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdaptiveThresholdParam& operator=(AdaptiveThresholdParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdaptiveThresholdParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdaptiveThresholdParam* internal_default_instance() {
    return reinterpret_cast<const AdaptiveThresholdParam*>(
               &_AdaptiveThresholdParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AdaptiveThresholdParam& a, AdaptiveThresholdParam& b) {
    a.Swap(&b);
  }
  inline void Swap(AdaptiveThresholdParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdaptiveThresholdParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdaptiveThresholdParam* New() const final {
    return CreateMaybeMessage<AdaptiveThresholdParam>(nullptr);
  }

  AdaptiveThresholdParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdaptiveThresholdParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdaptiveThresholdParam& from);
  void MergeFrom(const AdaptiveThresholdParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdaptiveThresholdParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.AdaptiveThresholdParam";
  }
  protected:
  explicit AdaptiveThresholdParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AdaptiveThresholdParam_PartitionMode PartitionMode;
  static constexpr PartitionMode PM_STANDARD =
    AdaptiveThresholdParam_PartitionMode_PM_STANDARD;
  static constexpr PartitionMode PM_AGGRESIVE =
    AdaptiveThresholdParam_PartitionMode_PM_AGGRESIVE;
  static constexpr PartitionMode PM_FAST =
    AdaptiveThresholdParam_PartitionMode_PM_FAST;
  static inline bool PartitionMode_IsValid(int value) {
    return AdaptiveThresholdParam_PartitionMode_IsValid(value);
  }
  static constexpr PartitionMode PartitionMode_MIN =
    AdaptiveThresholdParam_PartitionMode_PartitionMode_MIN;
  static constexpr PartitionMode PartitionMode_MAX =
    AdaptiveThresholdParam_PartitionMode_PartitionMode_MAX;
  static constexpr int PartitionMode_ARRAYSIZE =
    AdaptiveThresholdParam_PartitionMode_PartitionMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PartitionMode_descriptor() {
    return AdaptiveThresholdParam_PartitionMode_descriptor();
  }
  template<typename T>
  static inline const std::string& PartitionMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PartitionMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PartitionMode_Name.");
    return AdaptiveThresholdParam_PartitionMode_Name(enum_t_value);
  }
  static inline bool PartitionMode_Parse(const std::string& name,
      PartitionMode* value) {
    return AdaptiveThresholdParam_PartitionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAverageCountFieldNumber = 1,
    kPartitionModeFieldNumber = 2,
    kOffsetFieldNumber = 3,
  };
  // int32 average_count = 1;
  void clear_average_count();
  ::PROTOBUF_NAMESPACE_ID::int32 average_count() const;
  void set_average_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_average_count() const;
  void _internal_set_average_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .zb.dcts.scenario.detection.AdaptiveThresholdParam.PartitionMode partition_mode = 2;
  void clear_partition_mode();
  ::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode partition_mode() const;
  void set_partition_mode(::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode value);
  private:
  ::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode _internal_partition_mode() const;
  void _internal_set_partition_mode(::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode value);
  public:

  // float offset = 3;
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.AdaptiveThresholdParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 average_count_;
  int partition_mode_;
  float offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class NeighborVarThresholdParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.NeighborVarThresholdParam) */ {
 public:
  inline NeighborVarThresholdParam() : NeighborVarThresholdParam(nullptr) {};
  virtual ~NeighborVarThresholdParam();

  NeighborVarThresholdParam(const NeighborVarThresholdParam& from);
  NeighborVarThresholdParam(NeighborVarThresholdParam&& from) noexcept
    : NeighborVarThresholdParam() {
    *this = ::std::move(from);
  }

  inline NeighborVarThresholdParam& operator=(const NeighborVarThresholdParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline NeighborVarThresholdParam& operator=(NeighborVarThresholdParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NeighborVarThresholdParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NeighborVarThresholdParam* internal_default_instance() {
    return reinterpret_cast<const NeighborVarThresholdParam*>(
               &_NeighborVarThresholdParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NeighborVarThresholdParam& a, NeighborVarThresholdParam& b) {
    a.Swap(&b);
  }
  inline void Swap(NeighborVarThresholdParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NeighborVarThresholdParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NeighborVarThresholdParam* New() const final {
    return CreateMaybeMessage<NeighborVarThresholdParam>(nullptr);
  }

  NeighborVarThresholdParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NeighborVarThresholdParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NeighborVarThresholdParam& from);
  void MergeFrom(const NeighborVarThresholdParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NeighborVarThresholdParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.NeighborVarThresholdParam";
  }
  protected:
  explicit NeighborVarThresholdParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoiseVarianceScaleFieldNumber = 1,
    kNoiseMaxVarianceFieldNumber = 2,
    kLookupFreqSpanFieldNumber = 4,
    kOffsetFieldNumber = 3,
    kSmoothRangeFieldNumber = 5,
  };
  // float noise_variance_scale = 1;
  void clear_noise_variance_scale();
  float noise_variance_scale() const;
  void set_noise_variance_scale(float value);
  private:
  float _internal_noise_variance_scale() const;
  void _internal_set_noise_variance_scale(float value);
  public:

  // float noise_max_variance = 2;
  void clear_noise_max_variance();
  float noise_max_variance() const;
  void set_noise_max_variance(float value);
  private:
  float _internal_noise_max_variance() const;
  void _internal_set_noise_max_variance(float value);
  public:

  // double lookup_freq_span = 4;
  void clear_lookup_freq_span();
  double lookup_freq_span() const;
  void set_lookup_freq_span(double value);
  private:
  double _internal_lookup_freq_span() const;
  void _internal_set_lookup_freq_span(double value);
  public:

  // float offset = 3;
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // int32 smooth_range = 5;
  void clear_smooth_range();
  ::PROTOBUF_NAMESPACE_ID::int32 smooth_range() const;
  void set_smooth_range(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_smooth_range() const;
  void _internal_set_smooth_range(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.NeighborVarThresholdParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float noise_variance_scale_;
  float noise_max_variance_;
  double lookup_freq_span_;
  float offset_;
  ::PROTOBUF_NAMESPACE_ID::int32 smooth_range_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class EnergyDetectionParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.EnergyDetectionParam) */ {
 public:
  inline EnergyDetectionParam() : EnergyDetectionParam(nullptr) {};
  virtual ~EnergyDetectionParam();

  EnergyDetectionParam(const EnergyDetectionParam& from);
  EnergyDetectionParam(EnergyDetectionParam&& from) noexcept
    : EnergyDetectionParam() {
    *this = ::std::move(from);
  }

  inline EnergyDetectionParam& operator=(const EnergyDetectionParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnergyDetectionParam& operator=(EnergyDetectionParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnergyDetectionParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnergyDetectionParam* internal_default_instance() {
    return reinterpret_cast<const EnergyDetectionParam*>(
               &_EnergyDetectionParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EnergyDetectionParam& a, EnergyDetectionParam& b) {
    a.Swap(&b);
  }
  inline void Swap(EnergyDetectionParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnergyDetectionParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnergyDetectionParam* New() const final {
    return CreateMaybeMessage<EnergyDetectionParam>(nullptr);
  }

  EnergyDetectionParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnergyDetectionParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnergyDetectionParam& from);
  void MergeFrom(const EnergyDetectionParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnergyDetectionParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.EnergyDetectionParam";
  }
  protected:
  explicit EnergyDetectionParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EnergyDetectionParam_LogicType LogicType;
  static constexpr LogicType LT_AND =
    EnergyDetectionParam_LogicType_LT_AND;
  static constexpr LogicType LT_OR =
    EnergyDetectionParam_LogicType_LT_OR;
  static inline bool LogicType_IsValid(int value) {
    return EnergyDetectionParam_LogicType_IsValid(value);
  }
  static constexpr LogicType LogicType_MIN =
    EnergyDetectionParam_LogicType_LogicType_MIN;
  static constexpr LogicType LogicType_MAX =
    EnergyDetectionParam_LogicType_LogicType_MAX;
  static constexpr int LogicType_ARRAYSIZE =
    EnergyDetectionParam_LogicType_LogicType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LogicType_descriptor() {
    return EnergyDetectionParam_LogicType_descriptor();
  }
  template<typename T>
  static inline const std::string& LogicType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LogicType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LogicType_Name.");
    return EnergyDetectionParam_LogicType_Name(enum_t_value);
  }
  static inline bool LogicType_Parse(const std::string& name,
      LogicType* value) {
    return EnergyDetectionParam_LogicType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kActiveTypesFieldNumber = 1,
    kHistoryThresholdFieldNumber = 5,
    kUserThresholdFieldNumber = 6,
    kAdaptiveThresholdFieldNumber = 7,
    kNeighborThresholdFieldNumber = 9,
    kLogicFieldNumber = 2,
  };
  // repeated .zb.dcts.scenario.detection.ThresholdType active_types = 1;
  int active_types_size() const;
  private:
  int _internal_active_types_size() const;
  public:
  void clear_active_types();
  private:
  ::zb::dcts::scenario::detection::ThresholdType _internal_active_types(int index) const;
  void _internal_add_active_types(::zb::dcts::scenario::detection::ThresholdType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_active_types();
  public:
  ::zb::dcts::scenario::detection::ThresholdType active_types(int index) const;
  void set_active_types(int index, ::zb::dcts::scenario::detection::ThresholdType value);
  void add_active_types(::zb::dcts::scenario::detection::ThresholdType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& active_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_active_types();

  // .zb.dcts.scenario.detection.HistoryThresholdParam history_threshold = 5;
  bool has_history_threshold() const;
  private:
  bool _internal_has_history_threshold() const;
  public:
  void clear_history_threshold();
  const ::zb::dcts::scenario::detection::HistoryThresholdParam& history_threshold() const;
  ::zb::dcts::scenario::detection::HistoryThresholdParam* release_history_threshold();
  ::zb::dcts::scenario::detection::HistoryThresholdParam* mutable_history_threshold();
  void set_allocated_history_threshold(::zb::dcts::scenario::detection::HistoryThresholdParam* history_threshold);
  private:
  const ::zb::dcts::scenario::detection::HistoryThresholdParam& _internal_history_threshold() const;
  ::zb::dcts::scenario::detection::HistoryThresholdParam* _internal_mutable_history_threshold();
  public:
  void unsafe_arena_set_allocated_history_threshold(
      ::zb::dcts::scenario::detection::HistoryThresholdParam* history_threshold);
  ::zb::dcts::scenario::detection::HistoryThresholdParam* unsafe_arena_release_history_threshold();

  // .zb.dcts.scenario.detection.UserThresholdParam user_threshold = 6;
  bool has_user_threshold() const;
  private:
  bool _internal_has_user_threshold() const;
  public:
  void clear_user_threshold();
  const ::zb::dcts::scenario::detection::UserThresholdParam& user_threshold() const;
  ::zb::dcts::scenario::detection::UserThresholdParam* release_user_threshold();
  ::zb::dcts::scenario::detection::UserThresholdParam* mutable_user_threshold();
  void set_allocated_user_threshold(::zb::dcts::scenario::detection::UserThresholdParam* user_threshold);
  private:
  const ::zb::dcts::scenario::detection::UserThresholdParam& _internal_user_threshold() const;
  ::zb::dcts::scenario::detection::UserThresholdParam* _internal_mutable_user_threshold();
  public:
  void unsafe_arena_set_allocated_user_threshold(
      ::zb::dcts::scenario::detection::UserThresholdParam* user_threshold);
  ::zb::dcts::scenario::detection::UserThresholdParam* unsafe_arena_release_user_threshold();

  // .zb.dcts.scenario.detection.AdaptiveThresholdParam adaptive_threshold = 7;
  bool has_adaptive_threshold() const;
  private:
  bool _internal_has_adaptive_threshold() const;
  public:
  void clear_adaptive_threshold();
  const ::zb::dcts::scenario::detection::AdaptiveThresholdParam& adaptive_threshold() const;
  ::zb::dcts::scenario::detection::AdaptiveThresholdParam* release_adaptive_threshold();
  ::zb::dcts::scenario::detection::AdaptiveThresholdParam* mutable_adaptive_threshold();
  void set_allocated_adaptive_threshold(::zb::dcts::scenario::detection::AdaptiveThresholdParam* adaptive_threshold);
  private:
  const ::zb::dcts::scenario::detection::AdaptiveThresholdParam& _internal_adaptive_threshold() const;
  ::zb::dcts::scenario::detection::AdaptiveThresholdParam* _internal_mutable_adaptive_threshold();
  public:
  void unsafe_arena_set_allocated_adaptive_threshold(
      ::zb::dcts::scenario::detection::AdaptiveThresholdParam* adaptive_threshold);
  ::zb::dcts::scenario::detection::AdaptiveThresholdParam* unsafe_arena_release_adaptive_threshold();

  // .zb.dcts.scenario.detection.NeighborVarThresholdParam neighbor_threshold = 9;
  bool has_neighbor_threshold() const;
  private:
  bool _internal_has_neighbor_threshold() const;
  public:
  void clear_neighbor_threshold();
  const ::zb::dcts::scenario::detection::NeighborVarThresholdParam& neighbor_threshold() const;
  ::zb::dcts::scenario::detection::NeighborVarThresholdParam* release_neighbor_threshold();
  ::zb::dcts::scenario::detection::NeighborVarThresholdParam* mutable_neighbor_threshold();
  void set_allocated_neighbor_threshold(::zb::dcts::scenario::detection::NeighborVarThresholdParam* neighbor_threshold);
  private:
  const ::zb::dcts::scenario::detection::NeighborVarThresholdParam& _internal_neighbor_threshold() const;
  ::zb::dcts::scenario::detection::NeighborVarThresholdParam* _internal_mutable_neighbor_threshold();
  public:
  void unsafe_arena_set_allocated_neighbor_threshold(
      ::zb::dcts::scenario::detection::NeighborVarThresholdParam* neighbor_threshold);
  ::zb::dcts::scenario::detection::NeighborVarThresholdParam* unsafe_arena_release_neighbor_threshold();

  // .zb.dcts.scenario.detection.EnergyDetectionParam.LogicType logic = 2;
  void clear_logic();
  ::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType logic() const;
  void set_logic(::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType value);
  private:
  ::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType _internal_logic() const;
  void _internal_set_logic(::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.EnergyDetectionParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> active_types_;
  mutable std::atomic<int> _active_types_cached_byte_size_;
  ::zb::dcts::scenario::detection::HistoryThresholdParam* history_threshold_;
  ::zb::dcts::scenario::detection::UserThresholdParam* user_threshold_;
  ::zb::dcts::scenario::detection::AdaptiveThresholdParam* adaptive_threshold_;
  ::zb::dcts::scenario::detection::NeighborVarThresholdParam* neighbor_threshold_;
  int logic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class ThresholdTrace PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.ThresholdTrace) */ {
 public:
  inline ThresholdTrace() : ThresholdTrace(nullptr) {};
  virtual ~ThresholdTrace();

  ThresholdTrace(const ThresholdTrace& from);
  ThresholdTrace(ThresholdTrace&& from) noexcept
    : ThresholdTrace() {
    *this = ::std::move(from);
  }

  inline ThresholdTrace& operator=(const ThresholdTrace& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThresholdTrace& operator=(ThresholdTrace&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThresholdTrace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThresholdTrace* internal_default_instance() {
    return reinterpret_cast<const ThresholdTrace*>(
               &_ThresholdTrace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ThresholdTrace& a, ThresholdTrace& b) {
    a.Swap(&b);
  }
  inline void Swap(ThresholdTrace* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThresholdTrace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThresholdTrace* New() const final {
    return CreateMaybeMessage<ThresholdTrace>(nullptr);
  }

  ThresholdTrace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThresholdTrace>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThresholdTrace& from);
  void MergeFrom(const ThresholdTrace& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThresholdTrace* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.ThresholdTrace";
  }
  protected:
  explicit ThresholdTrace(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThresholdTraceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated float threshold_trace = 2;
  int threshold_trace_size() const;
  private:
  int _internal_threshold_trace_size() const;
  public:
  void clear_threshold_trace();
  private:
  float _internal_threshold_trace(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_threshold_trace() const;
  void _internal_add_threshold_trace(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_threshold_trace();
  public:
  float threshold_trace(int index) const;
  void set_threshold_trace(int index, float value);
  void add_threshold_trace(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      threshold_trace() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_threshold_trace();

  // .zb.dcts.scenario.detection.ThresholdType type = 1;
  void clear_type();
  ::zb::dcts::scenario::detection::ThresholdType type() const;
  void set_type(::zb::dcts::scenario::detection::ThresholdType value);
  private:
  ::zb::dcts::scenario::detection::ThresholdType _internal_type() const;
  void _internal_set_type(::zb::dcts::scenario::detection::ThresholdType value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.ThresholdTrace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > threshold_trace_;
  mutable std::atomic<int> _threshold_trace_cached_byte_size_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class FreqSpanFilter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.FreqSpanFilter) */ {
 public:
  inline FreqSpanFilter() : FreqSpanFilter(nullptr) {};
  virtual ~FreqSpanFilter();

  FreqSpanFilter(const FreqSpanFilter& from);
  FreqSpanFilter(FreqSpanFilter&& from) noexcept
    : FreqSpanFilter() {
    *this = ::std::move(from);
  }

  inline FreqSpanFilter& operator=(const FreqSpanFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreqSpanFilter& operator=(FreqSpanFilter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FreqSpanFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreqSpanFilter* internal_default_instance() {
    return reinterpret_cast<const FreqSpanFilter*>(
               &_FreqSpanFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FreqSpanFilter& a, FreqSpanFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(FreqSpanFilter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreqSpanFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FreqSpanFilter* New() const final {
    return CreateMaybeMessage<FreqSpanFilter>(nullptr);
  }

  FreqSpanFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FreqSpanFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FreqSpanFilter& from);
  void MergeFrom(const FreqSpanFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreqSpanFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.FreqSpanFilter";
  }
  protected:
  explicit FreqSpanFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFreqSpansFieldNumber = 1,
  };
  // repeated .zb.dcts.scenario.spectrum.FrequencySpan freq_spans = 1;
  int freq_spans_size() const;
  private:
  int _internal_freq_spans_size() const;
  public:
  void clear_freq_spans();
  ::zb::dcts::scenario::spectrum::FrequencySpan* mutable_freq_spans(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::spectrum::FrequencySpan >*
      mutable_freq_spans();
  private:
  const ::zb::dcts::scenario::spectrum::FrequencySpan& _internal_freq_spans(int index) const;
  ::zb::dcts::scenario::spectrum::FrequencySpan* _internal_add_freq_spans();
  public:
  const ::zb::dcts::scenario::spectrum::FrequencySpan& freq_spans(int index) const;
  ::zb::dcts::scenario::spectrum::FrequencySpan* add_freq_spans();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::spectrum::FrequencySpan >&
      freq_spans() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.FreqSpanFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::spectrum::FrequencySpan > freq_spans_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalSegmentationParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalSegmentationParam) */ {
 public:
  inline SignalSegmentationParam() : SignalSegmentationParam(nullptr) {};
  virtual ~SignalSegmentationParam();

  SignalSegmentationParam(const SignalSegmentationParam& from);
  SignalSegmentationParam(SignalSegmentationParam&& from) noexcept
    : SignalSegmentationParam() {
    *this = ::std::move(from);
  }

  inline SignalSegmentationParam& operator=(const SignalSegmentationParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalSegmentationParam& operator=(SignalSegmentationParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalSegmentationParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalSegmentationParam* internal_default_instance() {
    return reinterpret_cast<const SignalSegmentationParam*>(
               &_SignalSegmentationParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SignalSegmentationParam& a, SignalSegmentationParam& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalSegmentationParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalSegmentationParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalSegmentationParam* New() const final {
    return CreateMaybeMessage<SignalSegmentationParam>(nullptr);
  }

  SignalSegmentationParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalSegmentationParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalSegmentationParam& from);
  void MergeFrom(const SignalSegmentationParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalSegmentationParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalSegmentationParam";
  }
  protected:
  explicit SignalSegmentationParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFreqCenterJitterToleranceFieldNumber = 1,
    kFreqBorderBlurToleranceFieldNumber = 2,
    kMinRssFieldNumber = 3,
    kTimeGapToleranceFieldNumber = 4,
  };
  // float freq_center_jitter_tolerance = 1;
  void clear_freq_center_jitter_tolerance();
  float freq_center_jitter_tolerance() const;
  void set_freq_center_jitter_tolerance(float value);
  private:
  float _internal_freq_center_jitter_tolerance() const;
  void _internal_set_freq_center_jitter_tolerance(float value);
  public:

  // float freq_border_blur_tolerance = 2;
  void clear_freq_border_blur_tolerance();
  float freq_border_blur_tolerance() const;
  void set_freq_border_blur_tolerance(float value);
  private:
  float _internal_freq_border_blur_tolerance() const;
  void _internal_set_freq_border_blur_tolerance(float value);
  public:

  // float min_rss = 3;
  void clear_min_rss();
  float min_rss() const;
  void set_min_rss(float value);
  private:
  float _internal_min_rss() const;
  void _internal_set_min_rss(float value);
  public:

  // int32 time_gap_tolerance = 4;
  void clear_time_gap_tolerance();
  ::PROTOBUF_NAMESPACE_ID::int32 time_gap_tolerance() const;
  void set_time_gap_tolerance(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time_gap_tolerance() const;
  void _internal_set_time_gap_tolerance(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalSegmentationParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float freq_center_jitter_tolerance_;
  float freq_border_blur_tolerance_;
  float min_rss_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_gap_tolerance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class HopSignalClusterParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.HopSignalClusterParam) */ {
 public:
  inline HopSignalClusterParam() : HopSignalClusterParam(nullptr) {};
  virtual ~HopSignalClusterParam();

  HopSignalClusterParam(const HopSignalClusterParam& from);
  HopSignalClusterParam(HopSignalClusterParam&& from) noexcept
    : HopSignalClusterParam() {
    *this = ::std::move(from);
  }

  inline HopSignalClusterParam& operator=(const HopSignalClusterParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline HopSignalClusterParam& operator=(HopSignalClusterParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HopSignalClusterParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HopSignalClusterParam* internal_default_instance() {
    return reinterpret_cast<const HopSignalClusterParam*>(
               &_HopSignalClusterParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HopSignalClusterParam& a, HopSignalClusterParam& b) {
    a.Swap(&b);
  }
  inline void Swap(HopSignalClusterParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HopSignalClusterParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HopSignalClusterParam* New() const final {
    return CreateMaybeMessage<HopSignalClusterParam>(nullptr);
  }

  HopSignalClusterParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HopSignalClusterParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HopSignalClusterParam& from);
  void MergeFrom(const HopSignalClusterParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HopSignalClusterParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.HopSignalClusterParam";
  }
  protected:
  explicit HopSignalClusterParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kFrequencyRangeFieldNumber = 2,
    kBandWidthRangeFieldNumber = 3,
    kFreqJitterToleranceFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .zb.dcts.scenario.spectrum.FrequencySpan frequency_range = 2;
  bool has_frequency_range() const;
  private:
  bool _internal_has_frequency_range() const;
  public:
  void clear_frequency_range();
  const ::zb::dcts::scenario::spectrum::FrequencySpan& frequency_range() const;
  ::zb::dcts::scenario::spectrum::FrequencySpan* release_frequency_range();
  ::zb::dcts::scenario::spectrum::FrequencySpan* mutable_frequency_range();
  void set_allocated_frequency_range(::zb::dcts::scenario::spectrum::FrequencySpan* frequency_range);
  private:
  const ::zb::dcts::scenario::spectrum::FrequencySpan& _internal_frequency_range() const;
  ::zb::dcts::scenario::spectrum::FrequencySpan* _internal_mutable_frequency_range();
  public:
  void unsafe_arena_set_allocated_frequency_range(
      ::zb::dcts::scenario::spectrum::FrequencySpan* frequency_range);
  ::zb::dcts::scenario::spectrum::FrequencySpan* unsafe_arena_release_frequency_range();

  // .zb.dcts.DRange band_width_range = 3;
  bool has_band_width_range() const;
  private:
  bool _internal_has_band_width_range() const;
  public:
  void clear_band_width_range();
  const ::zb::dcts::DRange& band_width_range() const;
  ::zb::dcts::DRange* release_band_width_range();
  ::zb::dcts::DRange* mutable_band_width_range();
  void set_allocated_band_width_range(::zb::dcts::DRange* band_width_range);
  private:
  const ::zb::dcts::DRange& _internal_band_width_range() const;
  ::zb::dcts::DRange* _internal_mutable_band_width_range();
  public:
  void unsafe_arena_set_allocated_band_width_range(
      ::zb::dcts::DRange* band_width_range);
  ::zb::dcts::DRange* unsafe_arena_release_band_width_range();

  // float freq_jitter_tolerance = 4;
  void clear_freq_jitter_tolerance();
  float freq_jitter_tolerance() const;
  void set_freq_jitter_tolerance(float value);
  private:
  float _internal_freq_jitter_tolerance() const;
  void _internal_set_freq_jitter_tolerance(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.HopSignalClusterParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::zb::dcts::scenario::spectrum::FrequencySpan* frequency_range_;
  ::zb::dcts::DRange* band_width_range_;
  float freq_jitter_tolerance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class HopSignalDetectionParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.HopSignalDetectionParam) */ {
 public:
  inline HopSignalDetectionParam() : HopSignalDetectionParam(nullptr) {};
  virtual ~HopSignalDetectionParam();

  HopSignalDetectionParam(const HopSignalDetectionParam& from);
  HopSignalDetectionParam(HopSignalDetectionParam&& from) noexcept
    : HopSignalDetectionParam() {
    *this = ::std::move(from);
  }

  inline HopSignalDetectionParam& operator=(const HopSignalDetectionParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline HopSignalDetectionParam& operator=(HopSignalDetectionParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HopSignalDetectionParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HopSignalDetectionParam* internal_default_instance() {
    return reinterpret_cast<const HopSignalDetectionParam*>(
               &_HopSignalDetectionParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(HopSignalDetectionParam& a, HopSignalDetectionParam& b) {
    a.Swap(&b);
  }
  inline void Swap(HopSignalDetectionParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HopSignalDetectionParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HopSignalDetectionParam* New() const final {
    return CreateMaybeMessage<HopSignalDetectionParam>(nullptr);
  }

  HopSignalDetectionParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HopSignalDetectionParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HopSignalDetectionParam& from);
  void MergeFrom(const HopSignalDetectionParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HopSignalDetectionParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.HopSignalDetectionParam";
  }
  protected:
  explicit HopSignalDetectionParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHopSignalClustersFieldNumber = 1,
  };
  // repeated .zb.dcts.scenario.detection.HopSignalClusterParam hop_signal_clusters = 1;
  int hop_signal_clusters_size() const;
  private:
  int _internal_hop_signal_clusters_size() const;
  public:
  void clear_hop_signal_clusters();
  ::zb::dcts::scenario::detection::HopSignalClusterParam* mutable_hop_signal_clusters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalClusterParam >*
      mutable_hop_signal_clusters();
  private:
  const ::zb::dcts::scenario::detection::HopSignalClusterParam& _internal_hop_signal_clusters(int index) const;
  ::zb::dcts::scenario::detection::HopSignalClusterParam* _internal_add_hop_signal_clusters();
  public:
  const ::zb::dcts::scenario::detection::HopSignalClusterParam& hop_signal_clusters(int index) const;
  ::zb::dcts::scenario::detection::HopSignalClusterParam* add_hop_signal_clusters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalClusterParam >&
      hop_signal_clusters() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.HopSignalDetectionParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalClusterParam > hop_signal_clusters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalDetectParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalDetectParam) */ {
 public:
  inline SignalDetectParam() : SignalDetectParam(nullptr) {};
  virtual ~SignalDetectParam();

  SignalDetectParam(const SignalDetectParam& from);
  SignalDetectParam(SignalDetectParam&& from) noexcept
    : SignalDetectParam() {
    *this = ::std::move(from);
  }

  inline SignalDetectParam& operator=(const SignalDetectParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalDetectParam& operator=(SignalDetectParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalDetectParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalDetectParam* internal_default_instance() {
    return reinterpret_cast<const SignalDetectParam*>(
               &_SignalDetectParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SignalDetectParam& a, SignalDetectParam& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalDetectParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalDetectParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalDetectParam* New() const final {
    return CreateMaybeMessage<SignalDetectParam>(nullptr);
  }

  SignalDetectParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalDetectParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalDetectParam& from);
  void MergeFrom(const SignalDetectParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalDetectParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalDetectParam";
  }
  protected:
  explicit SignalDetectParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhiteListFieldNumber = 1,
    kSignalSegmenationParamFieldNumber = 2,
    kHopSignalDetectionParamFieldNumber = 3,
  };
  // .zb.dcts.scenario.detection.FreqSpanFilter white_list = 1;
  bool has_white_list() const;
  private:
  bool _internal_has_white_list() const;
  public:
  void clear_white_list();
  const ::zb::dcts::scenario::detection::FreqSpanFilter& white_list() const;
  ::zb::dcts::scenario::detection::FreqSpanFilter* release_white_list();
  ::zb::dcts::scenario::detection::FreqSpanFilter* mutable_white_list();
  void set_allocated_white_list(::zb::dcts::scenario::detection::FreqSpanFilter* white_list);
  private:
  const ::zb::dcts::scenario::detection::FreqSpanFilter& _internal_white_list() const;
  ::zb::dcts::scenario::detection::FreqSpanFilter* _internal_mutable_white_list();
  public:
  void unsafe_arena_set_allocated_white_list(
      ::zb::dcts::scenario::detection::FreqSpanFilter* white_list);
  ::zb::dcts::scenario::detection::FreqSpanFilter* unsafe_arena_release_white_list();

  // .zb.dcts.scenario.detection.SignalSegmentationParam signal_segmenation_param = 2;
  bool has_signal_segmenation_param() const;
  private:
  bool _internal_has_signal_segmenation_param() const;
  public:
  void clear_signal_segmenation_param();
  const ::zb::dcts::scenario::detection::SignalSegmentationParam& signal_segmenation_param() const;
  ::zb::dcts::scenario::detection::SignalSegmentationParam* release_signal_segmenation_param();
  ::zb::dcts::scenario::detection::SignalSegmentationParam* mutable_signal_segmenation_param();
  void set_allocated_signal_segmenation_param(::zb::dcts::scenario::detection::SignalSegmentationParam* signal_segmenation_param);
  private:
  const ::zb::dcts::scenario::detection::SignalSegmentationParam& _internal_signal_segmenation_param() const;
  ::zb::dcts::scenario::detection::SignalSegmentationParam* _internal_mutable_signal_segmenation_param();
  public:
  void unsafe_arena_set_allocated_signal_segmenation_param(
      ::zb::dcts::scenario::detection::SignalSegmentationParam* signal_segmenation_param);
  ::zb::dcts::scenario::detection::SignalSegmentationParam* unsafe_arena_release_signal_segmenation_param();

  // .zb.dcts.scenario.detection.HopSignalDetectionParam hop_signal_detection_param = 3;
  bool has_hop_signal_detection_param() const;
  private:
  bool _internal_has_hop_signal_detection_param() const;
  public:
  void clear_hop_signal_detection_param();
  const ::zb::dcts::scenario::detection::HopSignalDetectionParam& hop_signal_detection_param() const;
  ::zb::dcts::scenario::detection::HopSignalDetectionParam* release_hop_signal_detection_param();
  ::zb::dcts::scenario::detection::HopSignalDetectionParam* mutable_hop_signal_detection_param();
  void set_allocated_hop_signal_detection_param(::zb::dcts::scenario::detection::HopSignalDetectionParam* hop_signal_detection_param);
  private:
  const ::zb::dcts::scenario::detection::HopSignalDetectionParam& _internal_hop_signal_detection_param() const;
  ::zb::dcts::scenario::detection::HopSignalDetectionParam* _internal_mutable_hop_signal_detection_param();
  public:
  void unsafe_arena_set_allocated_hop_signal_detection_param(
      ::zb::dcts::scenario::detection::HopSignalDetectionParam* hop_signal_detection_param);
  ::zb::dcts::scenario::detection::HopSignalDetectionParam* unsafe_arena_release_hop_signal_detection_param();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalDetectParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::detection::FreqSpanFilter* white_list_;
  ::zb::dcts::scenario::detection::SignalSegmentationParam* signal_segmenation_param_;
  ::zb::dcts::scenario::detection::HopSignalDetectionParam* hop_signal_detection_param_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class DetectionParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.DetectionParam) */ {
 public:
  inline DetectionParam() : DetectionParam(nullptr) {};
  virtual ~DetectionParam();

  DetectionParam(const DetectionParam& from);
  DetectionParam(DetectionParam&& from) noexcept
    : DetectionParam() {
    *this = ::std::move(from);
  }

  inline DetectionParam& operator=(const DetectionParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectionParam& operator=(DetectionParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DetectionParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetectionParam* internal_default_instance() {
    return reinterpret_cast<const DetectionParam*>(
               &_DetectionParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DetectionParam& a, DetectionParam& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectionParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectionParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DetectionParam* New() const final {
    return CreateMaybeMessage<DetectionParam>(nullptr);
  }

  DetectionParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DetectionParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DetectionParam& from);
  void MergeFrom(const DetectionParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.DetectionParam";
  }
  protected:
  explicit DetectionParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnergyDetectParamFieldNumber = 2,
    kSignalDetectParamFieldNumber = 3,
    kResultIntervalFieldNumber = 1,
  };
  // .zb.dcts.scenario.detection.EnergyDetectionParam energy_detect_param = 2;
  bool has_energy_detect_param() const;
  private:
  bool _internal_has_energy_detect_param() const;
  public:
  void clear_energy_detect_param();
  const ::zb::dcts::scenario::detection::EnergyDetectionParam& energy_detect_param() const;
  ::zb::dcts::scenario::detection::EnergyDetectionParam* release_energy_detect_param();
  ::zb::dcts::scenario::detection::EnergyDetectionParam* mutable_energy_detect_param();
  void set_allocated_energy_detect_param(::zb::dcts::scenario::detection::EnergyDetectionParam* energy_detect_param);
  private:
  const ::zb::dcts::scenario::detection::EnergyDetectionParam& _internal_energy_detect_param() const;
  ::zb::dcts::scenario::detection::EnergyDetectionParam* _internal_mutable_energy_detect_param();
  public:
  void unsafe_arena_set_allocated_energy_detect_param(
      ::zb::dcts::scenario::detection::EnergyDetectionParam* energy_detect_param);
  ::zb::dcts::scenario::detection::EnergyDetectionParam* unsafe_arena_release_energy_detect_param();

  // .zb.dcts.scenario.detection.SignalDetectParam signal_detect_param = 3;
  bool has_signal_detect_param() const;
  private:
  bool _internal_has_signal_detect_param() const;
  public:
  void clear_signal_detect_param();
  const ::zb::dcts::scenario::detection::SignalDetectParam& signal_detect_param() const;
  ::zb::dcts::scenario::detection::SignalDetectParam* release_signal_detect_param();
  ::zb::dcts::scenario::detection::SignalDetectParam* mutable_signal_detect_param();
  void set_allocated_signal_detect_param(::zb::dcts::scenario::detection::SignalDetectParam* signal_detect_param);
  private:
  const ::zb::dcts::scenario::detection::SignalDetectParam& _internal_signal_detect_param() const;
  ::zb::dcts::scenario::detection::SignalDetectParam* _internal_mutable_signal_detect_param();
  public:
  void unsafe_arena_set_allocated_signal_detect_param(
      ::zb::dcts::scenario::detection::SignalDetectParam* signal_detect_param);
  ::zb::dcts::scenario::detection::SignalDetectParam* unsafe_arena_release_signal_detect_param();

  // int32 result_interval = 1;
  void clear_result_interval();
  ::PROTOBUF_NAMESPACE_ID::int32 result_interval() const;
  void set_result_interval(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_result_interval() const;
  void _internal_set_result_interval(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.DetectionParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::detection::EnergyDetectionParam* energy_detect_param_;
  ::zb::dcts::scenario::detection::SignalDetectParam* signal_detect_param_;
  ::PROTOBUF_NAMESPACE_ID::int32 result_interval_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalFeature PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalFeature) */ {
 public:
  inline SignalFeature() : SignalFeature(nullptr) {};
  virtual ~SignalFeature();

  SignalFeature(const SignalFeature& from);
  SignalFeature(SignalFeature&& from) noexcept
    : SignalFeature() {
    *this = ::std::move(from);
  }

  inline SignalFeature& operator=(const SignalFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalFeature& operator=(SignalFeature&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalFeature* internal_default_instance() {
    return reinterpret_cast<const SignalFeature*>(
               &_SignalFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SignalFeature& a, SignalFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalFeature* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalFeature* New() const final {
    return CreateMaybeMessage<SignalFeature>(nullptr);
  }

  SignalFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalFeature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalFeature& from);
  void MergeFrom(const SignalFeature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalFeature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalFeature";
  }
  protected:
  explicit SignalFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalBandFieldNumber = 2,
    kAmplitudeFieldNumber = 4,
    kHitsFieldNumber = 5,
    kSequenceNumberFieldNumber = 1,
  };
  // .zb.dcts.scenario.spectrum.SignalBand signal_band = 2;
  bool has_signal_band() const;
  private:
  bool _internal_has_signal_band() const;
  public:
  void clear_signal_band();
  const ::zb::dcts::scenario::spectrum::SignalBand& signal_band() const;
  ::zb::dcts::scenario::spectrum::SignalBand* release_signal_band();
  ::zb::dcts::scenario::spectrum::SignalBand* mutable_signal_band();
  void set_allocated_signal_band(::zb::dcts::scenario::spectrum::SignalBand* signal_band);
  private:
  const ::zb::dcts::scenario::spectrum::SignalBand& _internal_signal_band() const;
  ::zb::dcts::scenario::spectrum::SignalBand* _internal_mutable_signal_band();
  public:
  void unsafe_arena_set_allocated_signal_band(
      ::zb::dcts::scenario::spectrum::SignalBand* signal_band);
  ::zb::dcts::scenario::spectrum::SignalBand* unsafe_arena_release_signal_band();

  // .zb.dcts.StatisticVal amplitude = 4;
  bool has_amplitude() const;
  private:
  bool _internal_has_amplitude() const;
  public:
  void clear_amplitude();
  const ::zb::dcts::StatisticVal& amplitude() const;
  ::zb::dcts::StatisticVal* release_amplitude();
  ::zb::dcts::StatisticVal* mutable_amplitude();
  void set_allocated_amplitude(::zb::dcts::StatisticVal* amplitude);
  private:
  const ::zb::dcts::StatisticVal& _internal_amplitude() const;
  ::zb::dcts::StatisticVal* _internal_mutable_amplitude();
  public:
  void unsafe_arena_set_allocated_amplitude(
      ::zb::dcts::StatisticVal* amplitude);
  ::zb::dcts::StatisticVal* unsafe_arena_release_amplitude();

  // .zb.dcts.StatisticVal hits = 5;
  bool has_hits() const;
  private:
  bool _internal_has_hits() const;
  public:
  void clear_hits();
  const ::zb::dcts::StatisticVal& hits() const;
  ::zb::dcts::StatisticVal* release_hits();
  ::zb::dcts::StatisticVal* mutable_hits();
  void set_allocated_hits(::zb::dcts::StatisticVal* hits);
  private:
  const ::zb::dcts::StatisticVal& _internal_hits() const;
  ::zb::dcts::StatisticVal* _internal_mutable_hits();
  public:
  void unsafe_arena_set_allocated_hits(
      ::zb::dcts::StatisticVal* hits);
  ::zb::dcts::StatisticVal* unsafe_arena_release_hits();

  // int32 sequence_number = 1;
  void clear_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::int32 sequence_number() const;
  void set_sequence_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sequence_number() const;
  void _internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::spectrum::SignalBand* signal_band_;
  ::zb::dcts::StatisticVal* amplitude_;
  ::zb::dcts::StatisticVal* hits_;
  ::PROTOBUF_NAMESPACE_ID::int32 sequence_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalDigest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalDigest) */ {
 public:
  inline SignalDigest() : SignalDigest(nullptr) {};
  virtual ~SignalDigest();

  SignalDigest(const SignalDigest& from);
  SignalDigest(SignalDigest&& from) noexcept
    : SignalDigest() {
    *this = ::std::move(from);
  }

  inline SignalDigest& operator=(const SignalDigest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalDigest& operator=(SignalDigest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalDigest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalDigest* internal_default_instance() {
    return reinterpret_cast<const SignalDigest*>(
               &_SignalDigest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SignalDigest& a, SignalDigest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalDigest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalDigest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalDigest* New() const final {
    return CreateMaybeMessage<SignalDigest>(nullptr);
  }

  SignalDigest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalDigest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalDigest& from);
  void MergeFrom(const SignalDigest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalDigest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalDigest";
  }
  protected:
  explicit SignalDigest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kClassificationFieldNumber = 10,
    kDescriptionFieldNumber = 11,
    kCenterFreqFieldNumber = 3,
    kBandWidthFieldNumber = 4,
    kAmplitudeFieldNumber = 5,
    kEmitTimeSpanFieldNumber = 6,
    kDirOfArrivalFieldNumber = 9,
    kActivityFieldNumber = 2,
    kNumFeaturesFieldNumber = 7,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string classification = 10;
  void clear_classification();
  const std::string& classification() const;
  void set_classification(const std::string& value);
  void set_classification(std::string&& value);
  void set_classification(const char* value);
  void set_classification(const char* value, size_t size);
  std::string* mutable_classification();
  std::string* release_classification();
  void set_allocated_classification(std::string* classification);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_classification();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_classification(
      std::string* classification);
  private:
  const std::string& _internal_classification() const;
  void _internal_set_classification(const std::string& value);
  std::string* _internal_mutable_classification();
  public:

  // string description = 11;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_description();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_description(
      std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .zb.dcts.StatisticVal center_freq = 3;
  bool has_center_freq() const;
  private:
  bool _internal_has_center_freq() const;
  public:
  void clear_center_freq();
  const ::zb::dcts::StatisticVal& center_freq() const;
  ::zb::dcts::StatisticVal* release_center_freq();
  ::zb::dcts::StatisticVal* mutable_center_freq();
  void set_allocated_center_freq(::zb::dcts::StatisticVal* center_freq);
  private:
  const ::zb::dcts::StatisticVal& _internal_center_freq() const;
  ::zb::dcts::StatisticVal* _internal_mutable_center_freq();
  public:
  void unsafe_arena_set_allocated_center_freq(
      ::zb::dcts::StatisticVal* center_freq);
  ::zb::dcts::StatisticVal* unsafe_arena_release_center_freq();

  // .zb.dcts.StatisticVal band_width = 4;
  bool has_band_width() const;
  private:
  bool _internal_has_band_width() const;
  public:
  void clear_band_width();
  const ::zb::dcts::StatisticVal& band_width() const;
  ::zb::dcts::StatisticVal* release_band_width();
  ::zb::dcts::StatisticVal* mutable_band_width();
  void set_allocated_band_width(::zb::dcts::StatisticVal* band_width);
  private:
  const ::zb::dcts::StatisticVal& _internal_band_width() const;
  ::zb::dcts::StatisticVal* _internal_mutable_band_width();
  public:
  void unsafe_arena_set_allocated_band_width(
      ::zb::dcts::StatisticVal* band_width);
  ::zb::dcts::StatisticVal* unsafe_arena_release_band_width();

  // .zb.dcts.StatisticVal amplitude = 5;
  bool has_amplitude() const;
  private:
  bool _internal_has_amplitude() const;
  public:
  void clear_amplitude();
  const ::zb::dcts::StatisticVal& amplitude() const;
  ::zb::dcts::StatisticVal* release_amplitude();
  ::zb::dcts::StatisticVal* mutable_amplitude();
  void set_allocated_amplitude(::zb::dcts::StatisticVal* amplitude);
  private:
  const ::zb::dcts::StatisticVal& _internal_amplitude() const;
  ::zb::dcts::StatisticVal* _internal_mutable_amplitude();
  public:
  void unsafe_arena_set_allocated_amplitude(
      ::zb::dcts::StatisticVal* amplitude);
  ::zb::dcts::StatisticVal* unsafe_arena_release_amplitude();

  // .zb.dcts.TimeSpan emit_time_span = 6;
  bool has_emit_time_span() const;
  private:
  bool _internal_has_emit_time_span() const;
  public:
  void clear_emit_time_span();
  const ::zb::dcts::TimeSpan& emit_time_span() const;
  ::zb::dcts::TimeSpan* release_emit_time_span();
  ::zb::dcts::TimeSpan* mutable_emit_time_span();
  void set_allocated_emit_time_span(::zb::dcts::TimeSpan* emit_time_span);
  private:
  const ::zb::dcts::TimeSpan& _internal_emit_time_span() const;
  ::zb::dcts::TimeSpan* _internal_mutable_emit_time_span();
  public:
  void unsafe_arena_set_allocated_emit_time_span(
      ::zb::dcts::TimeSpan* emit_time_span);
  ::zb::dcts::TimeSpan* unsafe_arena_release_emit_time_span();

  // .zb.dcts.DOA dir_of_arrival = 9;
  bool has_dir_of_arrival() const;
  private:
  bool _internal_has_dir_of_arrival() const;
  public:
  void clear_dir_of_arrival();
  const ::zb::dcts::DOA& dir_of_arrival() const;
  ::zb::dcts::DOA* release_dir_of_arrival();
  ::zb::dcts::DOA* mutable_dir_of_arrival();
  void set_allocated_dir_of_arrival(::zb::dcts::DOA* dir_of_arrival);
  private:
  const ::zb::dcts::DOA& _internal_dir_of_arrival() const;
  ::zb::dcts::DOA* _internal_mutable_dir_of_arrival();
  public:
  void unsafe_arena_set_allocated_dir_of_arrival(
      ::zb::dcts::DOA* dir_of_arrival);
  ::zb::dcts::DOA* unsafe_arena_release_dir_of_arrival();

  // .zb.dcts.scenario.detection.SignalActivity activity = 2;
  void clear_activity();
  ::zb::dcts::scenario::detection::SignalActivity activity() const;
  void set_activity(::zb::dcts::scenario::detection::SignalActivity value);
  private:
  ::zb::dcts::scenario::detection::SignalActivity _internal_activity() const;
  void _internal_set_activity(::zb::dcts::scenario::detection::SignalActivity value);
  public:

  // int32 num_features = 7;
  void clear_num_features();
  ::PROTOBUF_NAMESPACE_ID::int32 num_features() const;
  void set_num_features(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_features() const;
  void _internal_set_num_features(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalDigest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr classification_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::zb::dcts::StatisticVal* center_freq_;
  ::zb::dcts::StatisticVal* band_width_;
  ::zb::dcts::StatisticVal* amplitude_;
  ::zb::dcts::TimeSpan* emit_time_span_;
  ::zb::dcts::DOA* dir_of_arrival_;
  int activity_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_features_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalSegment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalSegment) */ {
 public:
  inline SignalSegment() : SignalSegment(nullptr) {};
  virtual ~SignalSegment();

  SignalSegment(const SignalSegment& from);
  SignalSegment(SignalSegment&& from) noexcept
    : SignalSegment() {
    *this = ::std::move(from);
  }

  inline SignalSegment& operator=(const SignalSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalSegment& operator=(SignalSegment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalSegment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalSegment* internal_default_instance() {
    return reinterpret_cast<const SignalSegment*>(
               &_SignalSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SignalSegment& a, SignalSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalSegment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalSegment* New() const final {
    return CreateMaybeMessage<SignalSegment>(nullptr);
  }

  SignalSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalSegment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalSegment& from);
  void MergeFrom(const SignalSegment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalSegment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalSegment";
  }
  protected:
  explicit SignalSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureDetailsFieldNumber = 2,
    kDigestFieldNumber = 1,
  };
  // repeated .zb.dcts.scenario.detection.SignalFeature feature_details = 2;
  int feature_details_size() const;
  private:
  int _internal_feature_details_size() const;
  public:
  void clear_feature_details();
  ::zb::dcts::scenario::detection::SignalFeature* mutable_feature_details(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalFeature >*
      mutable_feature_details();
  private:
  const ::zb::dcts::scenario::detection::SignalFeature& _internal_feature_details(int index) const;
  ::zb::dcts::scenario::detection::SignalFeature* _internal_add_feature_details();
  public:
  const ::zb::dcts::scenario::detection::SignalFeature& feature_details(int index) const;
  ::zb::dcts::scenario::detection::SignalFeature* add_feature_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalFeature >&
      feature_details() const;

  // .zb.dcts.scenario.detection.SignalDigest digest = 1;
  bool has_digest() const;
  private:
  bool _internal_has_digest() const;
  public:
  void clear_digest();
  const ::zb::dcts::scenario::detection::SignalDigest& digest() const;
  ::zb::dcts::scenario::detection::SignalDigest* release_digest();
  ::zb::dcts::scenario::detection::SignalDigest* mutable_digest();
  void set_allocated_digest(::zb::dcts::scenario::detection::SignalDigest* digest);
  private:
  const ::zb::dcts::scenario::detection::SignalDigest& _internal_digest() const;
  ::zb::dcts::scenario::detection::SignalDigest* _internal_mutable_digest();
  public:
  void unsafe_arena_set_allocated_digest(
      ::zb::dcts::scenario::detection::SignalDigest* digest);
  ::zb::dcts::scenario::detection::SignalDigest* unsafe_arena_release_digest();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalFeature > feature_details_;
  ::zb::dcts::scenario::detection::SignalDigest* digest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class HopSignalDigest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.HopSignalDigest) */ {
 public:
  inline HopSignalDigest() : HopSignalDigest(nullptr) {};
  virtual ~HopSignalDigest();

  HopSignalDigest(const HopSignalDigest& from);
  HopSignalDigest(HopSignalDigest&& from) noexcept
    : HopSignalDigest() {
    *this = ::std::move(from);
  }

  inline HopSignalDigest& operator=(const HopSignalDigest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HopSignalDigest& operator=(HopSignalDigest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HopSignalDigest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HopSignalDigest* internal_default_instance() {
    return reinterpret_cast<const HopSignalDigest*>(
               &_HopSignalDigest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HopSignalDigest& a, HopSignalDigest& b) {
    a.Swap(&b);
  }
  inline void Swap(HopSignalDigest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HopSignalDigest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HopSignalDigest* New() const final {
    return CreateMaybeMessage<HopSignalDigest>(nullptr);
  }

  HopSignalDigest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HopSignalDigest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HopSignalDigest& from);
  void MergeFrom(const HopSignalDigest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HopSignalDigest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.HopSignalDigest";
  }
  protected:
  explicit HopSignalDigest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFreqFieldNumber = 1,
    kBandWidthFieldNumber = 2,
    kAmplitudeFieldNumber = 3,
    kNumFeaturesFieldNumber = 5,
  };
  // .zb.dcts.StatisticVal center_freq = 1;
  bool has_center_freq() const;
  private:
  bool _internal_has_center_freq() const;
  public:
  void clear_center_freq();
  const ::zb::dcts::StatisticVal& center_freq() const;
  ::zb::dcts::StatisticVal* release_center_freq();
  ::zb::dcts::StatisticVal* mutable_center_freq();
  void set_allocated_center_freq(::zb::dcts::StatisticVal* center_freq);
  private:
  const ::zb::dcts::StatisticVal& _internal_center_freq() const;
  ::zb::dcts::StatisticVal* _internal_mutable_center_freq();
  public:
  void unsafe_arena_set_allocated_center_freq(
      ::zb::dcts::StatisticVal* center_freq);
  ::zb::dcts::StatisticVal* unsafe_arena_release_center_freq();

  // .zb.dcts.StatisticVal band_width = 2;
  bool has_band_width() const;
  private:
  bool _internal_has_band_width() const;
  public:
  void clear_band_width();
  const ::zb::dcts::StatisticVal& band_width() const;
  ::zb::dcts::StatisticVal* release_band_width();
  ::zb::dcts::StatisticVal* mutable_band_width();
  void set_allocated_band_width(::zb::dcts::StatisticVal* band_width);
  private:
  const ::zb::dcts::StatisticVal& _internal_band_width() const;
  ::zb::dcts::StatisticVal* _internal_mutable_band_width();
  public:
  void unsafe_arena_set_allocated_band_width(
      ::zb::dcts::StatisticVal* band_width);
  ::zb::dcts::StatisticVal* unsafe_arena_release_band_width();

  // .zb.dcts.StatisticVal amplitude = 3;
  bool has_amplitude() const;
  private:
  bool _internal_has_amplitude() const;
  public:
  void clear_amplitude();
  const ::zb::dcts::StatisticVal& amplitude() const;
  ::zb::dcts::StatisticVal* release_amplitude();
  ::zb::dcts::StatisticVal* mutable_amplitude();
  void set_allocated_amplitude(::zb::dcts::StatisticVal* amplitude);
  private:
  const ::zb::dcts::StatisticVal& _internal_amplitude() const;
  ::zb::dcts::StatisticVal* _internal_mutable_amplitude();
  public:
  void unsafe_arena_set_allocated_amplitude(
      ::zb::dcts::StatisticVal* amplitude);
  ::zb::dcts::StatisticVal* unsafe_arena_release_amplitude();

  // int32 num_features = 5;
  void clear_num_features();
  ::PROTOBUF_NAMESPACE_ID::int32 num_features() const;
  void set_num_features(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_features() const;
  void _internal_set_num_features(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.HopSignalDigest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::StatisticVal* center_freq_;
  ::zb::dcts::StatisticVal* band_width_;
  ::zb::dcts::StatisticVal* amplitude_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_features_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class HopSignalCluster PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.HopSignalCluster) */ {
 public:
  inline HopSignalCluster() : HopSignalCluster(nullptr) {};
  virtual ~HopSignalCluster();

  HopSignalCluster(const HopSignalCluster& from);
  HopSignalCluster(HopSignalCluster&& from) noexcept
    : HopSignalCluster() {
    *this = ::std::move(from);
  }

  inline HopSignalCluster& operator=(const HopSignalCluster& from) {
    CopyFrom(from);
    return *this;
  }
  inline HopSignalCluster& operator=(HopSignalCluster&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HopSignalCluster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HopSignalCluster* internal_default_instance() {
    return reinterpret_cast<const HopSignalCluster*>(
               &_HopSignalCluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(HopSignalCluster& a, HopSignalCluster& b) {
    a.Swap(&b);
  }
  inline void Swap(HopSignalCluster* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HopSignalCluster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HopSignalCluster* New() const final {
    return CreateMaybeMessage<HopSignalCluster>(nullptr);
  }

  HopSignalCluster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HopSignalCluster>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HopSignalCluster& from);
  void MergeFrom(const HopSignalCluster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HopSignalCluster* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.HopSignalCluster";
  }
  protected:
  explicit HopSignalCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFreqSetFieldNumber = 4,
    kNameFieldNumber = 1,
    kEmitTimeSpanFieldNumber = 3,
    kActivityFieldNumber = 2,
  };
  // repeated .zb.dcts.scenario.detection.HopSignalDigest freq_set = 4;
  int freq_set_size() const;
  private:
  int _internal_freq_set_size() const;
  public:
  void clear_freq_set();
  ::zb::dcts::scenario::detection::HopSignalDigest* mutable_freq_set(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalDigest >*
      mutable_freq_set();
  private:
  const ::zb::dcts::scenario::detection::HopSignalDigest& _internal_freq_set(int index) const;
  ::zb::dcts::scenario::detection::HopSignalDigest* _internal_add_freq_set();
  public:
  const ::zb::dcts::scenario::detection::HopSignalDigest& freq_set(int index) const;
  ::zb::dcts::scenario::detection::HopSignalDigest* add_freq_set();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalDigest >&
      freq_set() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .zb.dcts.TimeSpan emit_time_span = 3;
  bool has_emit_time_span() const;
  private:
  bool _internal_has_emit_time_span() const;
  public:
  void clear_emit_time_span();
  const ::zb::dcts::TimeSpan& emit_time_span() const;
  ::zb::dcts::TimeSpan* release_emit_time_span();
  ::zb::dcts::TimeSpan* mutable_emit_time_span();
  void set_allocated_emit_time_span(::zb::dcts::TimeSpan* emit_time_span);
  private:
  const ::zb::dcts::TimeSpan& _internal_emit_time_span() const;
  ::zb::dcts::TimeSpan* _internal_mutable_emit_time_span();
  public:
  void unsafe_arena_set_allocated_emit_time_span(
      ::zb::dcts::TimeSpan* emit_time_span);
  ::zb::dcts::TimeSpan* unsafe_arena_release_emit_time_span();

  // .zb.dcts.scenario.detection.SignalActivity activity = 2;
  void clear_activity();
  ::zb::dcts::scenario::detection::SignalActivity activity() const;
  void set_activity(::zb::dcts::scenario::detection::SignalActivity value);
  private:
  ::zb::dcts::scenario::detection::SignalActivity _internal_activity() const;
  void _internal_set_activity(::zb::dcts::scenario::detection::SignalActivity value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.HopSignalCluster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalDigest > freq_set_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::zb::dcts::TimeSpan* emit_time_span_;
  int activity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class FixSignalList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.FixSignalList) */ {
 public:
  inline FixSignalList() : FixSignalList(nullptr) {};
  virtual ~FixSignalList();

  FixSignalList(const FixSignalList& from);
  FixSignalList(FixSignalList&& from) noexcept
    : FixSignalList() {
    *this = ::std::move(from);
  }

  inline FixSignalList& operator=(const FixSignalList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FixSignalList& operator=(FixSignalList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FixSignalList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FixSignalList* internal_default_instance() {
    return reinterpret_cast<const FixSignalList*>(
               &_FixSignalList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(FixSignalList& a, FixSignalList& b) {
    a.Swap(&b);
  }
  inline void Swap(FixSignalList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FixSignalList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FixSignalList* New() const final {
    return CreateMaybeMessage<FixSignalList>(nullptr);
  }

  FixSignalList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FixSignalList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FixSignalList& from);
  void MergeFrom(const FixSignalList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FixSignalList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.FixSignalList";
  }
  protected:
  explicit FixSignalList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFixSignalsFieldNumber = 1,
  };
  // repeated .zb.dcts.scenario.detection.SignalSegment fix_signals = 1;
  int fix_signals_size() const;
  private:
  int _internal_fix_signals_size() const;
  public:
  void clear_fix_signals();
  ::zb::dcts::scenario::detection::SignalSegment* mutable_fix_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalSegment >*
      mutable_fix_signals();
  private:
  const ::zb::dcts::scenario::detection::SignalSegment& _internal_fix_signals(int index) const;
  ::zb::dcts::scenario::detection::SignalSegment* _internal_add_fix_signals();
  public:
  const ::zb::dcts::scenario::detection::SignalSegment& fix_signals(int index) const;
  ::zb::dcts::scenario::detection::SignalSegment* add_fix_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalSegment >&
      fix_signals() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.FixSignalList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalSegment > fix_signals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class HopSignalList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.HopSignalList) */ {
 public:
  inline HopSignalList() : HopSignalList(nullptr) {};
  virtual ~HopSignalList();

  HopSignalList(const HopSignalList& from);
  HopSignalList(HopSignalList&& from) noexcept
    : HopSignalList() {
    *this = ::std::move(from);
  }

  inline HopSignalList& operator=(const HopSignalList& from) {
    CopyFrom(from);
    return *this;
  }
  inline HopSignalList& operator=(HopSignalList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HopSignalList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HopSignalList* internal_default_instance() {
    return reinterpret_cast<const HopSignalList*>(
               &_HopSignalList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(HopSignalList& a, HopSignalList& b) {
    a.Swap(&b);
  }
  inline void Swap(HopSignalList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HopSignalList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HopSignalList* New() const final {
    return CreateMaybeMessage<HopSignalList>(nullptr);
  }

  HopSignalList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HopSignalList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HopSignalList& from);
  void MergeFrom(const HopSignalList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HopSignalList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.HopSignalList";
  }
  protected:
  explicit HopSignalList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHopSignalClustersFieldNumber = 1,
  };
  // repeated .zb.dcts.scenario.detection.HopSignalCluster hop_signal_clusters = 1;
  int hop_signal_clusters_size() const;
  private:
  int _internal_hop_signal_clusters_size() const;
  public:
  void clear_hop_signal_clusters();
  ::zb::dcts::scenario::detection::HopSignalCluster* mutable_hop_signal_clusters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >*
      mutable_hop_signal_clusters();
  private:
  const ::zb::dcts::scenario::detection::HopSignalCluster& _internal_hop_signal_clusters(int index) const;
  ::zb::dcts::scenario::detection::HopSignalCluster* _internal_add_hop_signal_clusters();
  public:
  const ::zb::dcts::scenario::detection::HopSignalCluster& hop_signal_clusters(int index) const;
  ::zb::dcts::scenario::detection::HopSignalCluster* add_hop_signal_clusters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >&
      hop_signal_clusters() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.HopSignalList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster > hop_signal_clusters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class DetectionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.DetectionRequest) */ {
 public:
  inline DetectionRequest() : DetectionRequest(nullptr) {};
  virtual ~DetectionRequest();

  DetectionRequest(const DetectionRequest& from);
  DetectionRequest(DetectionRequest&& from) noexcept
    : DetectionRequest() {
    *this = ::std::move(from);
  }

  inline DetectionRequest& operator=(const DetectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectionRequest& operator=(DetectionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DetectionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetectionRequest* internal_default_instance() {
    return reinterpret_cast<const DetectionRequest*>(
               &_DetectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DetectionRequest& a, DetectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DetectionRequest* New() const final {
    return CreateMaybeMessage<DetectionRequest>(nullptr);
  }

  DetectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DetectionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DetectionRequest& from);
  void MergeFrom(const DetectionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.DetectionRequest";
  }
  protected:
  explicit DetectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponserFieldNumber = 1,
    kDetectionParamFieldNumber = 2,
  };
  // .zb.dcts.scenario.ScenarioTaskId responser = 1;
  bool has_responser() const;
  private:
  bool _internal_has_responser() const;
  public:
  void clear_responser();
  const ::zb::dcts::scenario::ScenarioTaskId& responser() const;
  ::zb::dcts::scenario::ScenarioTaskId* release_responser();
  ::zb::dcts::scenario::ScenarioTaskId* mutable_responser();
  void set_allocated_responser(::zb::dcts::scenario::ScenarioTaskId* responser);
  private:
  const ::zb::dcts::scenario::ScenarioTaskId& _internal_responser() const;
  ::zb::dcts::scenario::ScenarioTaskId* _internal_mutable_responser();
  public:
  void unsafe_arena_set_allocated_responser(
      ::zb::dcts::scenario::ScenarioTaskId* responser);
  ::zb::dcts::scenario::ScenarioTaskId* unsafe_arena_release_responser();

  // .zb.dcts.scenario.detection.DetectionParam detection_param = 2;
  bool has_detection_param() const;
  private:
  bool _internal_has_detection_param() const;
  public:
  void clear_detection_param();
  const ::zb::dcts::scenario::detection::DetectionParam& detection_param() const;
  ::zb::dcts::scenario::detection::DetectionParam* release_detection_param();
  ::zb::dcts::scenario::detection::DetectionParam* mutable_detection_param();
  void set_allocated_detection_param(::zb::dcts::scenario::detection::DetectionParam* detection_param);
  private:
  const ::zb::dcts::scenario::detection::DetectionParam& _internal_detection_param() const;
  ::zb::dcts::scenario::detection::DetectionParam* _internal_mutable_detection_param();
  public:
  void unsafe_arena_set_allocated_detection_param(
      ::zb::dcts::scenario::detection::DetectionParam* detection_param);
  ::zb::dcts::scenario::detection::DetectionParam* unsafe_arena_release_detection_param();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.DetectionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::ScenarioTaskId* responser_;
  ::zb::dcts::scenario::detection::DetectionParam* detection_param_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class AutoGatheringParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.AutoGatheringParam) */ {
 public:
  inline AutoGatheringParam() : AutoGatheringParam(nullptr) {};
  virtual ~AutoGatheringParam();

  AutoGatheringParam(const AutoGatheringParam& from);
  AutoGatheringParam(AutoGatheringParam&& from) noexcept
    : AutoGatheringParam() {
    *this = ::std::move(from);
  }

  inline AutoGatheringParam& operator=(const AutoGatheringParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoGatheringParam& operator=(AutoGatheringParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AutoGatheringParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutoGatheringParam* internal_default_instance() {
    return reinterpret_cast<const AutoGatheringParam*>(
               &_AutoGatheringParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AutoGatheringParam& a, AutoGatheringParam& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoGatheringParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoGatheringParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutoGatheringParam* New() const final {
    return CreateMaybeMessage<AutoGatheringParam>(nullptr);
  }

  AutoGatheringParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutoGatheringParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AutoGatheringParam& from);
  void MergeFrom(const AutoGatheringParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoGatheringParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.AutoGatheringParam";
  }
  protected:
  explicit AutoGatheringParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalCandidatesFieldNumber = 2,
    kTimeSpanInMsecFieldNumber = 1,
  };
  // repeated string signal_candidates = 2;
  int signal_candidates_size() const;
  private:
  int _internal_signal_candidates_size() const;
  public:
  void clear_signal_candidates();
  const std::string& signal_candidates(int index) const;
  std::string* mutable_signal_candidates(int index);
  void set_signal_candidates(int index, const std::string& value);
  void set_signal_candidates(int index, std::string&& value);
  void set_signal_candidates(int index, const char* value);
  void set_signal_candidates(int index, const char* value, size_t size);
  std::string* add_signal_candidates();
  void add_signal_candidates(const std::string& value);
  void add_signal_candidates(std::string&& value);
  void add_signal_candidates(const char* value);
  void add_signal_candidates(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signal_candidates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signal_candidates();
  private:
  const std::string& _internal_signal_candidates(int index) const;
  std::string* _internal_add_signal_candidates();
  public:

  // int32 time_span_in_msec = 1;
  void clear_time_span_in_msec();
  ::PROTOBUF_NAMESPACE_ID::int32 time_span_in_msec() const;
  void set_time_span_in_msec(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time_span_in_msec() const;
  void _internal_set_time_span_in_msec(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.AutoGatheringParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signal_candidates_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_span_in_msec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class ManualGatheringParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.ManualGatheringParam) */ {
 public:
  inline ManualGatheringParam() : ManualGatheringParam(nullptr) {};
  virtual ~ManualGatheringParam();

  ManualGatheringParam(const ManualGatheringParam& from);
  ManualGatheringParam(ManualGatheringParam&& from) noexcept
    : ManualGatheringParam() {
    *this = ::std::move(from);
  }

  inline ManualGatheringParam& operator=(const ManualGatheringParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManualGatheringParam& operator=(ManualGatheringParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ManualGatheringParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ManualGatheringParam* internal_default_instance() {
    return reinterpret_cast<const ManualGatheringParam*>(
               &_ManualGatheringParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ManualGatheringParam& a, ManualGatheringParam& b) {
    a.Swap(&b);
  }
  inline void Swap(ManualGatheringParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManualGatheringParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ManualGatheringParam* New() const final {
    return CreateMaybeMessage<ManualGatheringParam>(nullptr);
  }

  ManualGatheringParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ManualGatheringParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ManualGatheringParam& from);
  void MergeFrom(const ManualGatheringParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManualGatheringParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.ManualGatheringParam";
  }
  protected:
  explicit ManualGatheringParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kFreqSpanFieldNumber = 3,
    kTimeSpanInMsecFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .zb.dcts.scenario.spectrum.FrequencySpan freq_span = 3;
  bool has_freq_span() const;
  private:
  bool _internal_has_freq_span() const;
  public:
  void clear_freq_span();
  const ::zb::dcts::scenario::spectrum::FrequencySpan& freq_span() const;
  ::zb::dcts::scenario::spectrum::FrequencySpan* release_freq_span();
  ::zb::dcts::scenario::spectrum::FrequencySpan* mutable_freq_span();
  void set_allocated_freq_span(::zb::dcts::scenario::spectrum::FrequencySpan* freq_span);
  private:
  const ::zb::dcts::scenario::spectrum::FrequencySpan& _internal_freq_span() const;
  ::zb::dcts::scenario::spectrum::FrequencySpan* _internal_mutable_freq_span();
  public:
  void unsafe_arena_set_allocated_freq_span(
      ::zb::dcts::scenario::spectrum::FrequencySpan* freq_span);
  ::zb::dcts::scenario::spectrum::FrequencySpan* unsafe_arena_release_freq_span();

  // int32 time_span_in_msec = 2;
  void clear_time_span_in_msec();
  ::PROTOBUF_NAMESPACE_ID::int32 time_span_in_msec() const;
  void set_time_span_in_msec(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time_span_in_msec() const;
  void _internal_set_time_span_in_msec(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.ManualGatheringParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::zb::dcts::scenario::spectrum::FrequencySpan* freq_span_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_span_in_msec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalGatheringRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalGatheringRequest) */ {
 public:
  inline SignalGatheringRequest() : SignalGatheringRequest(nullptr) {};
  virtual ~SignalGatheringRequest();

  SignalGatheringRequest(const SignalGatheringRequest& from);
  SignalGatheringRequest(SignalGatheringRequest&& from) noexcept
    : SignalGatheringRequest() {
    *this = ::std::move(from);
  }

  inline SignalGatheringRequest& operator=(const SignalGatheringRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalGatheringRequest& operator=(SignalGatheringRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalGatheringRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalGatheringRequest* internal_default_instance() {
    return reinterpret_cast<const SignalGatheringRequest*>(
               &_SignalGatheringRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SignalGatheringRequest& a, SignalGatheringRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalGatheringRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalGatheringRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalGatheringRequest* New() const final {
    return CreateMaybeMessage<SignalGatheringRequest>(nullptr);
  }

  SignalGatheringRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalGatheringRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalGatheringRequest& from);
  void MergeFrom(const SignalGatheringRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalGatheringRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalGatheringRequest";
  }
  protected:
  explicit SignalGatheringRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponserFieldNumber = 1,
    kAutoGatheringParamFieldNumber = 2,
    kManualGatheringParamFieldNumber = 3,
  };
  // .zb.dcts.scenario.ScenarioTaskId responser = 1;
  bool has_responser() const;
  private:
  bool _internal_has_responser() const;
  public:
  void clear_responser();
  const ::zb::dcts::scenario::ScenarioTaskId& responser() const;
  ::zb::dcts::scenario::ScenarioTaskId* release_responser();
  ::zb::dcts::scenario::ScenarioTaskId* mutable_responser();
  void set_allocated_responser(::zb::dcts::scenario::ScenarioTaskId* responser);
  private:
  const ::zb::dcts::scenario::ScenarioTaskId& _internal_responser() const;
  ::zb::dcts::scenario::ScenarioTaskId* _internal_mutable_responser();
  public:
  void unsafe_arena_set_allocated_responser(
      ::zb::dcts::scenario::ScenarioTaskId* responser);
  ::zb::dcts::scenario::ScenarioTaskId* unsafe_arena_release_responser();

  // .zb.dcts.scenario.detection.AutoGatheringParam auto_gathering_param = 2;
  bool has_auto_gathering_param() const;
  private:
  bool _internal_has_auto_gathering_param() const;
  public:
  void clear_auto_gathering_param();
  const ::zb::dcts::scenario::detection::AutoGatheringParam& auto_gathering_param() const;
  ::zb::dcts::scenario::detection::AutoGatheringParam* release_auto_gathering_param();
  ::zb::dcts::scenario::detection::AutoGatheringParam* mutable_auto_gathering_param();
  void set_allocated_auto_gathering_param(::zb::dcts::scenario::detection::AutoGatheringParam* auto_gathering_param);
  private:
  const ::zb::dcts::scenario::detection::AutoGatheringParam& _internal_auto_gathering_param() const;
  ::zb::dcts::scenario::detection::AutoGatheringParam* _internal_mutable_auto_gathering_param();
  public:
  void unsafe_arena_set_allocated_auto_gathering_param(
      ::zb::dcts::scenario::detection::AutoGatheringParam* auto_gathering_param);
  ::zb::dcts::scenario::detection::AutoGatheringParam* unsafe_arena_release_auto_gathering_param();

  // .zb.dcts.scenario.detection.ManualGatheringParam manual_gathering_param = 3;
  bool has_manual_gathering_param() const;
  private:
  bool _internal_has_manual_gathering_param() const;
  public:
  void clear_manual_gathering_param();
  const ::zb::dcts::scenario::detection::ManualGatheringParam& manual_gathering_param() const;
  ::zb::dcts::scenario::detection::ManualGatheringParam* release_manual_gathering_param();
  ::zb::dcts::scenario::detection::ManualGatheringParam* mutable_manual_gathering_param();
  void set_allocated_manual_gathering_param(::zb::dcts::scenario::detection::ManualGatheringParam* manual_gathering_param);
  private:
  const ::zb::dcts::scenario::detection::ManualGatheringParam& _internal_manual_gathering_param() const;
  ::zb::dcts::scenario::detection::ManualGatheringParam* _internal_mutable_manual_gathering_param();
  public:
  void unsafe_arena_set_allocated_manual_gathering_param(
      ::zb::dcts::scenario::detection::ManualGatheringParam* manual_gathering_param);
  ::zb::dcts::scenario::detection::ManualGatheringParam* unsafe_arena_release_manual_gathering_param();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalGatheringRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::ScenarioTaskId* responser_;
  ::zb::dcts::scenario::detection::AutoGatheringParam* auto_gathering_param_;
  ::zb::dcts::scenario::detection::ManualGatheringParam* manual_gathering_param_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalSample PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalSample) */ {
 public:
  inline SignalSample() : SignalSample(nullptr) {};
  virtual ~SignalSample();

  SignalSample(const SignalSample& from);
  SignalSample(SignalSample&& from) noexcept
    : SignalSample() {
    *this = ::std::move(from);
  }

  inline SignalSample& operator=(const SignalSample& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalSample& operator=(SignalSample&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalSample& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalSample* internal_default_instance() {
    return reinterpret_cast<const SignalSample*>(
               &_SignalSample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SignalSample& a, SignalSample& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalSample* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalSample* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalSample* New() const final {
    return CreateMaybeMessage<SignalSample>(nullptr);
  }

  SignalSample* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalSample>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalSample& from);
  void MergeFrom(const SignalSample& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalSample* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalSample";
  }
  protected:
  explicit SignalSample(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSampleBlockFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .zb.dcts.scenario.spectrum.SpectrumBlock sample_block = 2;
  bool has_sample_block() const;
  private:
  bool _internal_has_sample_block() const;
  public:
  void clear_sample_block();
  const ::zb::dcts::scenario::spectrum::SpectrumBlock& sample_block() const;
  ::zb::dcts::scenario::spectrum::SpectrumBlock* release_sample_block();
  ::zb::dcts::scenario::spectrum::SpectrumBlock* mutable_sample_block();
  void set_allocated_sample_block(::zb::dcts::scenario::spectrum::SpectrumBlock* sample_block);
  private:
  const ::zb::dcts::scenario::spectrum::SpectrumBlock& _internal_sample_block() const;
  ::zb::dcts::scenario::spectrum::SpectrumBlock* _internal_mutable_sample_block();
  public:
  void unsafe_arena_set_allocated_sample_block(
      ::zb::dcts::scenario::spectrum::SpectrumBlock* sample_block);
  ::zb::dcts::scenario::spectrum::SpectrumBlock* unsafe_arena_release_sample_block();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalSample)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::zb::dcts::scenario::spectrum::SpectrumBlock* sample_block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalSampleList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalSampleList) */ {
 public:
  inline SignalSampleList() : SignalSampleList(nullptr) {};
  virtual ~SignalSampleList();

  SignalSampleList(const SignalSampleList& from);
  SignalSampleList(SignalSampleList&& from) noexcept
    : SignalSampleList() {
    *this = ::std::move(from);
  }

  inline SignalSampleList& operator=(const SignalSampleList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalSampleList& operator=(SignalSampleList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalSampleList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalSampleList* internal_default_instance() {
    return reinterpret_cast<const SignalSampleList*>(
               &_SignalSampleList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SignalSampleList& a, SignalSampleList& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalSampleList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalSampleList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalSampleList* New() const final {
    return CreateMaybeMessage<SignalSampleList>(nullptr);
  }

  SignalSampleList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalSampleList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalSampleList& from);
  void MergeFrom(const SignalSampleList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalSampleList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalSampleList";
  }
  protected:
  explicit SignalSampleList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSamplesFieldNumber = 1,
  };
  // repeated .zb.dcts.scenario.detection.SignalSample samples = 1;
  int samples_size() const;
  private:
  int _internal_samples_size() const;
  public:
  void clear_samples();
  ::zb::dcts::scenario::detection::SignalSample* mutable_samples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalSample >*
      mutable_samples();
  private:
  const ::zb::dcts::scenario::detection::SignalSample& _internal_samples(int index) const;
  ::zb::dcts::scenario::detection::SignalSample* _internal_add_samples();
  public:
  const ::zb::dcts::scenario::detection::SignalSample& samples(int index) const;
  ::zb::dcts::scenario::detection::SignalSample* add_samples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalSample >&
      samples() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalSampleList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalSample > samples_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalTableQueryRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalTableQueryRequest) */ {
 public:
  inline SignalTableQueryRequest() : SignalTableQueryRequest(nullptr) {};
  virtual ~SignalTableQueryRequest();

  SignalTableQueryRequest(const SignalTableQueryRequest& from);
  SignalTableQueryRequest(SignalTableQueryRequest&& from) noexcept
    : SignalTableQueryRequest() {
    *this = ::std::move(from);
  }

  inline SignalTableQueryRequest& operator=(const SignalTableQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalTableQueryRequest& operator=(SignalTableQueryRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalTableQueryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalTableQueryRequest* internal_default_instance() {
    return reinterpret_cast<const SignalTableQueryRequest*>(
               &_SignalTableQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SignalTableQueryRequest& a, SignalTableQueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalTableQueryRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalTableQueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalTableQueryRequest* New() const final {
    return CreateMaybeMessage<SignalTableQueryRequest>(nullptr);
  }

  SignalTableQueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalTableQueryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalTableQueryRequest& from);
  void MergeFrom(const SignalTableQueryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalTableQueryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalTableQueryRequest";
  }
  protected:
  explicit SignalTableQueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponserFieldNumber = 1,
    kDataSourceFieldNumber = 2,
    kActiviyMaskFieldNumber = 3,
    kFreqRangeFieldNumber = 4,
    kTimeRangeFieldNumber = 5,
  };
  // .zb.dcts.scenario.ScenarioTaskId responser = 1;
  bool has_responser() const;
  private:
  bool _internal_has_responser() const;
  public:
  void clear_responser();
  const ::zb::dcts::scenario::ScenarioTaskId& responser() const;
  ::zb::dcts::scenario::ScenarioTaskId* release_responser();
  ::zb::dcts::scenario::ScenarioTaskId* mutable_responser();
  void set_allocated_responser(::zb::dcts::scenario::ScenarioTaskId* responser);
  private:
  const ::zb::dcts::scenario::ScenarioTaskId& _internal_responser() const;
  ::zb::dcts::scenario::ScenarioTaskId* _internal_mutable_responser();
  public:
  void unsafe_arena_set_allocated_responser(
      ::zb::dcts::scenario::ScenarioTaskId* responser);
  ::zb::dcts::scenario::ScenarioTaskId* unsafe_arena_release_responser();

  // .zb.dcts.source.SourceId data_source = 2;
  bool has_data_source() const;
  private:
  bool _internal_has_data_source() const;
  public:
  void clear_data_source();
  const ::zb::dcts::source::SourceId& data_source() const;
  ::zb::dcts::source::SourceId* release_data_source();
  ::zb::dcts::source::SourceId* mutable_data_source();
  void set_allocated_data_source(::zb::dcts::source::SourceId* data_source);
  private:
  const ::zb::dcts::source::SourceId& _internal_data_source() const;
  ::zb::dcts::source::SourceId* _internal_mutable_data_source();
  public:
  void unsafe_arena_set_allocated_data_source(
      ::zb::dcts::source::SourceId* data_source);
  ::zb::dcts::source::SourceId* unsafe_arena_release_data_source();

  // .zb.dcts.Integer activiy_mask = 3;
  bool has_activiy_mask() const;
  private:
  bool _internal_has_activiy_mask() const;
  public:
  void clear_activiy_mask();
  const ::zb::dcts::Integer& activiy_mask() const;
  ::zb::dcts::Integer* release_activiy_mask();
  ::zb::dcts::Integer* mutable_activiy_mask();
  void set_allocated_activiy_mask(::zb::dcts::Integer* activiy_mask);
  private:
  const ::zb::dcts::Integer& _internal_activiy_mask() const;
  ::zb::dcts::Integer* _internal_mutable_activiy_mask();
  public:
  void unsafe_arena_set_allocated_activiy_mask(
      ::zb::dcts::Integer* activiy_mask);
  ::zb::dcts::Integer* unsafe_arena_release_activiy_mask();

  // .zb.dcts.scenario.spectrum.FrequencySpan freq_range = 4;
  bool has_freq_range() const;
  private:
  bool _internal_has_freq_range() const;
  public:
  void clear_freq_range();
  const ::zb::dcts::scenario::spectrum::FrequencySpan& freq_range() const;
  ::zb::dcts::scenario::spectrum::FrequencySpan* release_freq_range();
  ::zb::dcts::scenario::spectrum::FrequencySpan* mutable_freq_range();
  void set_allocated_freq_range(::zb::dcts::scenario::spectrum::FrequencySpan* freq_range);
  private:
  const ::zb::dcts::scenario::spectrum::FrequencySpan& _internal_freq_range() const;
  ::zb::dcts::scenario::spectrum::FrequencySpan* _internal_mutable_freq_range();
  public:
  void unsafe_arena_set_allocated_freq_range(
      ::zb::dcts::scenario::spectrum::FrequencySpan* freq_range);
  ::zb::dcts::scenario::spectrum::FrequencySpan* unsafe_arena_release_freq_range();

  // .zb.dcts.TimeSpan time_range = 5;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const ::zb::dcts::TimeSpan& time_range() const;
  ::zb::dcts::TimeSpan* release_time_range();
  ::zb::dcts::TimeSpan* mutable_time_range();
  void set_allocated_time_range(::zb::dcts::TimeSpan* time_range);
  private:
  const ::zb::dcts::TimeSpan& _internal_time_range() const;
  ::zb::dcts::TimeSpan* _internal_mutable_time_range();
  public:
  void unsafe_arena_set_allocated_time_range(
      ::zb::dcts::TimeSpan* time_range);
  ::zb::dcts::TimeSpan* unsafe_arena_release_time_range();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalTableQueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::ScenarioTaskId* responser_;
  ::zb::dcts::source::SourceId* data_source_;
  ::zb::dcts::Integer* activiy_mask_;
  ::zb::dcts::scenario::spectrum::FrequencySpan* freq_range_;
  ::zb::dcts::TimeSpan* time_range_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalTableQueryResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalTableQueryResponse) */ {
 public:
  inline SignalTableQueryResponse() : SignalTableQueryResponse(nullptr) {};
  virtual ~SignalTableQueryResponse();

  SignalTableQueryResponse(const SignalTableQueryResponse& from);
  SignalTableQueryResponse(SignalTableQueryResponse&& from) noexcept
    : SignalTableQueryResponse() {
    *this = ::std::move(from);
  }

  inline SignalTableQueryResponse& operator=(const SignalTableQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalTableQueryResponse& operator=(SignalTableQueryResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalTableQueryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalTableQueryResponse* internal_default_instance() {
    return reinterpret_cast<const SignalTableQueryResponse*>(
               &_SignalTableQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SignalTableQueryResponse& a, SignalTableQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalTableQueryResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalTableQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalTableQueryResponse* New() const final {
    return CreateMaybeMessage<SignalTableQueryResponse>(nullptr);
  }

  SignalTableQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalTableQueryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalTableQueryResponse& from);
  void MergeFrom(const SignalTableQueryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalTableQueryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalTableQueryResponse";
  }
  protected:
  explicit SignalTableQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFixSignalListFieldNumber = 7,
    kHopSignalListFieldNumber = 8,
    kDataSourceFieldNumber = 1,
    kNumSweepsFieldNumber = 2,
    kNumDetectsFieldNumber = 3,
    kNumTotalSignalsFieldNumber = 4,
    kNumQuerySignalsFieldNumber = 5,
  };
  // repeated .zb.dcts.scenario.detection.SignalDigest fix_signal_list = 7;
  int fix_signal_list_size() const;
  private:
  int _internal_fix_signal_list_size() const;
  public:
  void clear_fix_signal_list();
  ::zb::dcts::scenario::detection::SignalDigest* mutable_fix_signal_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalDigest >*
      mutable_fix_signal_list();
  private:
  const ::zb::dcts::scenario::detection::SignalDigest& _internal_fix_signal_list(int index) const;
  ::zb::dcts::scenario::detection::SignalDigest* _internal_add_fix_signal_list();
  public:
  const ::zb::dcts::scenario::detection::SignalDigest& fix_signal_list(int index) const;
  ::zb::dcts::scenario::detection::SignalDigest* add_fix_signal_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalDigest >&
      fix_signal_list() const;

  // repeated .zb.dcts.scenario.detection.HopSignalCluster hop_signal_list = 8;
  int hop_signal_list_size() const;
  private:
  int _internal_hop_signal_list_size() const;
  public:
  void clear_hop_signal_list();
  ::zb::dcts::scenario::detection::HopSignalCluster* mutable_hop_signal_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >*
      mutable_hop_signal_list();
  private:
  const ::zb::dcts::scenario::detection::HopSignalCluster& _internal_hop_signal_list(int index) const;
  ::zb::dcts::scenario::detection::HopSignalCluster* _internal_add_hop_signal_list();
  public:
  const ::zb::dcts::scenario::detection::HopSignalCluster& hop_signal_list(int index) const;
  ::zb::dcts::scenario::detection::HopSignalCluster* add_hop_signal_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >&
      hop_signal_list() const;

  // .zb.dcts.source.SourceId data_source = 1;
  bool has_data_source() const;
  private:
  bool _internal_has_data_source() const;
  public:
  void clear_data_source();
  const ::zb::dcts::source::SourceId& data_source() const;
  ::zb::dcts::source::SourceId* release_data_source();
  ::zb::dcts::source::SourceId* mutable_data_source();
  void set_allocated_data_source(::zb::dcts::source::SourceId* data_source);
  private:
  const ::zb::dcts::source::SourceId& _internal_data_source() const;
  ::zb::dcts::source::SourceId* _internal_mutable_data_source();
  public:
  void unsafe_arena_set_allocated_data_source(
      ::zb::dcts::source::SourceId* data_source);
  ::zb::dcts::source::SourceId* unsafe_arena_release_data_source();

  // int32 num_sweeps = 2;
  void clear_num_sweeps();
  ::PROTOBUF_NAMESPACE_ID::int32 num_sweeps() const;
  void set_num_sweeps(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_sweeps() const;
  void _internal_set_num_sweeps(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_detects = 3;
  void clear_num_detects();
  ::PROTOBUF_NAMESPACE_ID::int32 num_detects() const;
  void set_num_detects(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_detects() const;
  void _internal_set_num_detects(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_total_signals = 4;
  void clear_num_total_signals();
  ::PROTOBUF_NAMESPACE_ID::int32 num_total_signals() const;
  void set_num_total_signals(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_total_signals() const;
  void _internal_set_num_total_signals(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 num_query_signals = 5;
  void clear_num_query_signals();
  ::PROTOBUF_NAMESPACE_ID::int32 num_query_signals() const;
  void set_num_query_signals(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_query_signals() const;
  void _internal_set_num_query_signals(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalTableQueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalDigest > fix_signal_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster > hop_signal_list_;
  ::zb::dcts::source::SourceId* data_source_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_sweeps_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_detects_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_total_signals_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_query_signals_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class Header PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.Header) */ {
 public:
  inline Header() : Header(nullptr) {};
  virtual ~Header();

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(nullptr);
  }

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFromFieldNumber = 1,
    kTimeSpanFieldNumber = 5,
    kDevicePositionFieldNumber = 6,
    kSequenceNumberFieldNumber = 3,
    kSweepCountFieldNumber = 4,
  };
  // .zb.dcts.source.SourceId result_from = 1;
  bool has_result_from() const;
  private:
  bool _internal_has_result_from() const;
  public:
  void clear_result_from();
  const ::zb::dcts::source::SourceId& result_from() const;
  ::zb::dcts::source::SourceId* release_result_from();
  ::zb::dcts::source::SourceId* mutable_result_from();
  void set_allocated_result_from(::zb::dcts::source::SourceId* result_from);
  private:
  const ::zb::dcts::source::SourceId& _internal_result_from() const;
  ::zb::dcts::source::SourceId* _internal_mutable_result_from();
  public:
  void unsafe_arena_set_allocated_result_from(
      ::zb::dcts::source::SourceId* result_from);
  ::zb::dcts::source::SourceId* unsafe_arena_release_result_from();

  // .zb.dcts.TimeSpan time_span = 5;
  bool has_time_span() const;
  private:
  bool _internal_has_time_span() const;
  public:
  void clear_time_span();
  const ::zb::dcts::TimeSpan& time_span() const;
  ::zb::dcts::TimeSpan* release_time_span();
  ::zb::dcts::TimeSpan* mutable_time_span();
  void set_allocated_time_span(::zb::dcts::TimeSpan* time_span);
  private:
  const ::zb::dcts::TimeSpan& _internal_time_span() const;
  ::zb::dcts::TimeSpan* _internal_mutable_time_span();
  public:
  void unsafe_arena_set_allocated_time_span(
      ::zb::dcts::TimeSpan* time_span);
  ::zb::dcts::TimeSpan* unsafe_arena_release_time_span();

  // .zb.dcts.Position device_position = 6;
  bool has_device_position() const;
  private:
  bool _internal_has_device_position() const;
  public:
  void clear_device_position();
  const ::zb::dcts::Position& device_position() const;
  ::zb::dcts::Position* release_device_position();
  ::zb::dcts::Position* mutable_device_position();
  void set_allocated_device_position(::zb::dcts::Position* device_position);
  private:
  const ::zb::dcts::Position& _internal_device_position() const;
  ::zb::dcts::Position* _internal_mutable_device_position();
  public:
  void unsafe_arena_set_allocated_device_position(
      ::zb::dcts::Position* device_position);
  ::zb::dcts::Position* unsafe_arena_release_device_position();

  // uint32 sequence_number = 3;
  void clear_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_number() const;
  void set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sequence_number() const;
  void _internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 sweep_count = 4;
  void clear_sweep_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 sweep_count() const;
  void set_sweep_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sweep_count() const;
  void _internal_set_sweep_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::source::SourceId* result_from_;
  ::zb::dcts::TimeSpan* time_span_;
  ::zb::dcts::Position* device_position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_number_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sweep_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class RawBody PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.RawBody) */ {
 public:
  inline RawBody() : RawBody(nullptr) {};
  virtual ~RawBody();

  RawBody(const RawBody& from);
  RawBody(RawBody&& from) noexcept
    : RawBody() {
    *this = ::std::move(from);
  }

  inline RawBody& operator=(const RawBody& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawBody& operator=(RawBody&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RawBody& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawBody* internal_default_instance() {
    return reinterpret_cast<const RawBody*>(
               &_RawBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RawBody& a, RawBody& b) {
    a.Swap(&b);
  }
  inline void Swap(RawBody* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RawBody* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RawBody* New() const final {
    return CreateMaybeMessage<RawBody>(nullptr);
  }

  RawBody* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RawBody>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RawBody& from);
  void MergeFrom(const RawBody& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawBody* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.RawBody";
  }
  protected:
  explicit RawBody(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawSpectrumLinesFieldNumber = 3,
    kFreqSegFieldNumber = 1,
    kOverThresholdHitsFieldNumber = 2,
  };
  // repeated .zb.dcts.scenario.spectrum.SpectrumLine raw_spectrum_lines = 3;
  int raw_spectrum_lines_size() const;
  private:
  int _internal_raw_spectrum_lines_size() const;
  public:
  void clear_raw_spectrum_lines();
  ::zb::dcts::scenario::spectrum::SpectrumLine* mutable_raw_spectrum_lines(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::spectrum::SpectrumLine >*
      mutable_raw_spectrum_lines();
  private:
  const ::zb::dcts::scenario::spectrum::SpectrumLine& _internal_raw_spectrum_lines(int index) const;
  ::zb::dcts::scenario::spectrum::SpectrumLine* _internal_add_raw_spectrum_lines();
  public:
  const ::zb::dcts::scenario::spectrum::SpectrumLine& raw_spectrum_lines(int index) const;
  ::zb::dcts::scenario::spectrum::SpectrumLine* add_raw_spectrum_lines();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::spectrum::SpectrumLine >&
      raw_spectrum_lines() const;

  // .zb.dcts.scenario.spectrum.FrequencySegment freq_seg = 1;
  bool has_freq_seg() const;
  private:
  bool _internal_has_freq_seg() const;
  public:
  void clear_freq_seg();
  const ::zb::dcts::scenario::spectrum::FrequencySegment& freq_seg() const;
  ::zb::dcts::scenario::spectrum::FrequencySegment* release_freq_seg();
  ::zb::dcts::scenario::spectrum::FrequencySegment* mutable_freq_seg();
  void set_allocated_freq_seg(::zb::dcts::scenario::spectrum::FrequencySegment* freq_seg);
  private:
  const ::zb::dcts::scenario::spectrum::FrequencySegment& _internal_freq_seg() const;
  ::zb::dcts::scenario::spectrum::FrequencySegment* _internal_mutable_freq_seg();
  public:
  void unsafe_arena_set_allocated_freq_seg(
      ::zb::dcts::scenario::spectrum::FrequencySegment* freq_seg);
  ::zb::dcts::scenario::spectrum::FrequencySegment* unsafe_arena_release_freq_seg();

  // .zb.dcts.scenario.spectrum.SpectrumLine over_threshold_hits = 2;
  bool has_over_threshold_hits() const;
  private:
  bool _internal_has_over_threshold_hits() const;
  public:
  void clear_over_threshold_hits();
  const ::zb::dcts::scenario::spectrum::SpectrumLine& over_threshold_hits() const;
  ::zb::dcts::scenario::spectrum::SpectrumLine* release_over_threshold_hits();
  ::zb::dcts::scenario::spectrum::SpectrumLine* mutable_over_threshold_hits();
  void set_allocated_over_threshold_hits(::zb::dcts::scenario::spectrum::SpectrumLine* over_threshold_hits);
  private:
  const ::zb::dcts::scenario::spectrum::SpectrumLine& _internal_over_threshold_hits() const;
  ::zb::dcts::scenario::spectrum::SpectrumLine* _internal_mutable_over_threshold_hits();
  public:
  void unsafe_arena_set_allocated_over_threshold_hits(
      ::zb::dcts::scenario::spectrum::SpectrumLine* over_threshold_hits);
  ::zb::dcts::scenario::spectrum::SpectrumLine* unsafe_arena_release_over_threshold_hits();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.RawBody)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::spectrum::SpectrumLine > raw_spectrum_lines_;
  ::zb::dcts::scenario::spectrum::FrequencySegment* freq_seg_;
  ::zb::dcts::scenario::spectrum::SpectrumLine* over_threshold_hits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class RawData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.RawData) */ {
 public:
  inline RawData() : RawData(nullptr) {};
  virtual ~RawData();

  RawData(const RawData& from);
  RawData(RawData&& from) noexcept
    : RawData() {
    *this = ::std::move(from);
  }

  inline RawData& operator=(const RawData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawData& operator=(RawData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RawData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawData* internal_default_instance() {
    return reinterpret_cast<const RawData*>(
               &_RawData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(RawData& a, RawData& b) {
    a.Swap(&b);
  }
  inline void Swap(RawData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RawData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RawData* New() const final {
    return CreateMaybeMessage<RawData>(nullptr);
  }

  RawData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RawData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RawData& from);
  void MergeFrom(const RawData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.RawData";
  }
  protected:
  explicit RawData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalSegmentsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // repeated .zb.dcts.IRange signal_segments = 3;
  int signal_segments_size() const;
  private:
  int _internal_signal_segments_size() const;
  public:
  void clear_signal_segments();
  ::zb::dcts::IRange* mutable_signal_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::IRange >*
      mutable_signal_segments();
  private:
  const ::zb::dcts::IRange& _internal_signal_segments(int index) const;
  ::zb::dcts::IRange* _internal_add_signal_segments();
  public:
  const ::zb::dcts::IRange& signal_segments(int index) const;
  ::zb::dcts::IRange* add_signal_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::IRange >&
      signal_segments() const;

  // .zb.dcts.scenario.detection.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::zb::dcts::scenario::detection::Header& header() const;
  ::zb::dcts::scenario::detection::Header* release_header();
  ::zb::dcts::scenario::detection::Header* mutable_header();
  void set_allocated_header(::zb::dcts::scenario::detection::Header* header);
  private:
  const ::zb::dcts::scenario::detection::Header& _internal_header() const;
  ::zb::dcts::scenario::detection::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::zb::dcts::scenario::detection::Header* header);
  ::zb::dcts::scenario::detection::Header* unsafe_arena_release_header();

  // .zb.dcts.scenario.detection.RawBody body = 2;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::zb::dcts::scenario::detection::RawBody& body() const;
  ::zb::dcts::scenario::detection::RawBody* release_body();
  ::zb::dcts::scenario::detection::RawBody* mutable_body();
  void set_allocated_body(::zb::dcts::scenario::detection::RawBody* body);
  private:
  const ::zb::dcts::scenario::detection::RawBody& _internal_body() const;
  ::zb::dcts::scenario::detection::RawBody* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::zb::dcts::scenario::detection::RawBody* body);
  ::zb::dcts::scenario::detection::RawBody* unsafe_arena_release_body();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.RawData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::IRange > signal_segments_;
  ::zb::dcts::scenario::detection::Header* header_;
  ::zb::dcts::scenario::detection::RawBody* body_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class DeviceDetectResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.DeviceDetectResult) */ {
 public:
  inline DeviceDetectResult() : DeviceDetectResult(nullptr) {};
  virtual ~DeviceDetectResult();

  DeviceDetectResult(const DeviceDetectResult& from);
  DeviceDetectResult(DeviceDetectResult&& from) noexcept
    : DeviceDetectResult() {
    *this = ::std::move(from);
  }

  inline DeviceDetectResult& operator=(const DeviceDetectResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceDetectResult& operator=(DeviceDetectResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeviceDetectResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceDetectResult* internal_default_instance() {
    return reinterpret_cast<const DeviceDetectResult*>(
               &_DeviceDetectResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(DeviceDetectResult& a, DeviceDetectResult& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceDetectResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceDetectResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceDetectResult* New() const final {
    return CreateMaybeMessage<DeviceDetectResult>(nullptr);
  }

  DeviceDetectResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceDetectResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeviceDetectResult& from);
  void MergeFrom(const DeviceDetectResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceDetectResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.DeviceDetectResult";
  }
  protected:
  explicit DeviceDetectResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kFixSignalListFieldNumber = 3,
    kHopSignalListFieldNumber = 4,
    kSignalSampleListFieldNumber = 5,
  };
  // .zb.dcts.scenario.detection.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::zb::dcts::scenario::detection::Header& header() const;
  ::zb::dcts::scenario::detection::Header* release_header();
  ::zb::dcts::scenario::detection::Header* mutable_header();
  void set_allocated_header(::zb::dcts::scenario::detection::Header* header);
  private:
  const ::zb::dcts::scenario::detection::Header& _internal_header() const;
  ::zb::dcts::scenario::detection::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::zb::dcts::scenario::detection::Header* header);
  ::zb::dcts::scenario::detection::Header* unsafe_arena_release_header();

  // .zb.dcts.scenario.detection.FixSignalList fix_signal_list = 3;
  bool has_fix_signal_list() const;
  private:
  bool _internal_has_fix_signal_list() const;
  public:
  void clear_fix_signal_list();
  const ::zb::dcts::scenario::detection::FixSignalList& fix_signal_list() const;
  ::zb::dcts::scenario::detection::FixSignalList* release_fix_signal_list();
  ::zb::dcts::scenario::detection::FixSignalList* mutable_fix_signal_list();
  void set_allocated_fix_signal_list(::zb::dcts::scenario::detection::FixSignalList* fix_signal_list);
  private:
  const ::zb::dcts::scenario::detection::FixSignalList& _internal_fix_signal_list() const;
  ::zb::dcts::scenario::detection::FixSignalList* _internal_mutable_fix_signal_list();
  public:
  void unsafe_arena_set_allocated_fix_signal_list(
      ::zb::dcts::scenario::detection::FixSignalList* fix_signal_list);
  ::zb::dcts::scenario::detection::FixSignalList* unsafe_arena_release_fix_signal_list();

  // .zb.dcts.scenario.detection.HopSignalList hop_signal_list = 4;
  bool has_hop_signal_list() const;
  private:
  bool _internal_has_hop_signal_list() const;
  public:
  void clear_hop_signal_list();
  const ::zb::dcts::scenario::detection::HopSignalList& hop_signal_list() const;
  ::zb::dcts::scenario::detection::HopSignalList* release_hop_signal_list();
  ::zb::dcts::scenario::detection::HopSignalList* mutable_hop_signal_list();
  void set_allocated_hop_signal_list(::zb::dcts::scenario::detection::HopSignalList* hop_signal_list);
  private:
  const ::zb::dcts::scenario::detection::HopSignalList& _internal_hop_signal_list() const;
  ::zb::dcts::scenario::detection::HopSignalList* _internal_mutable_hop_signal_list();
  public:
  void unsafe_arena_set_allocated_hop_signal_list(
      ::zb::dcts::scenario::detection::HopSignalList* hop_signal_list);
  ::zb::dcts::scenario::detection::HopSignalList* unsafe_arena_release_hop_signal_list();

  // .zb.dcts.scenario.detection.SignalSampleList signal_sample_list = 5;
  bool has_signal_sample_list() const;
  private:
  bool _internal_has_signal_sample_list() const;
  public:
  void clear_signal_sample_list();
  const ::zb::dcts::scenario::detection::SignalSampleList& signal_sample_list() const;
  ::zb::dcts::scenario::detection::SignalSampleList* release_signal_sample_list();
  ::zb::dcts::scenario::detection::SignalSampleList* mutable_signal_sample_list();
  void set_allocated_signal_sample_list(::zb::dcts::scenario::detection::SignalSampleList* signal_sample_list);
  private:
  const ::zb::dcts::scenario::detection::SignalSampleList& _internal_signal_sample_list() const;
  ::zb::dcts::scenario::detection::SignalSampleList* _internal_mutable_signal_sample_list();
  public:
  void unsafe_arena_set_allocated_signal_sample_list(
      ::zb::dcts::scenario::detection::SignalSampleList* signal_sample_list);
  ::zb::dcts::scenario::detection::SignalSampleList* unsafe_arena_release_signal_sample_list();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.DeviceDetectResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::scenario::detection::Header* header_;
  ::zb::dcts::scenario::detection::FixSignalList* fix_signal_list_;
  ::zb::dcts::scenario::detection::HopSignalList* hop_signal_list_;
  ::zb::dcts::scenario::detection::SignalSampleList* signal_sample_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalLayerSurvey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.scenario.detection.SignalLayerSurvey) */ {
 public:
  inline SignalLayerSurvey() : SignalLayerSurvey(nullptr) {};
  virtual ~SignalLayerSurvey();

  SignalLayerSurvey(const SignalLayerSurvey& from);
  SignalLayerSurvey(SignalLayerSurvey&& from) noexcept
    : SignalLayerSurvey() {
    *this = ::std::move(from);
  }

  inline SignalLayerSurvey& operator=(const SignalLayerSurvey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalLayerSurvey& operator=(SignalLayerSurvey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalLayerSurvey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalLayerSurvey* internal_default_instance() {
    return reinterpret_cast<const SignalLayerSurvey*>(
               &_SignalLayerSurvey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SignalLayerSurvey& a, SignalLayerSurvey& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalLayerSurvey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalLayerSurvey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalLayerSurvey* New() const final {
    return CreateMaybeMessage<SignalLayerSurvey>(nullptr);
  }

  SignalLayerSurvey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalLayerSurvey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalLayerSurvey& from);
  void MergeFrom(const SignalLayerSurvey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalLayerSurvey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.scenario.detection.SignalLayerSurvey";
  }
  protected:
  explicit SignalLayerSurvey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scenario_2fdetection_2eproto);
    return ::descriptor_table_scenario_2fdetection_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFixSignalListFieldNumber = 4,
    kHopSignalListFieldNumber = 5,
    kResultFromFieldNumber = 1,
    kTimeStampFieldNumber = 2,
    kPositionFieldNumber = 3,
  };
  // repeated .zb.dcts.scenario.detection.SignalDigest fix_signal_list = 4;
  int fix_signal_list_size() const;
  private:
  int _internal_fix_signal_list_size() const;
  public:
  void clear_fix_signal_list();
  ::zb::dcts::scenario::detection::SignalDigest* mutable_fix_signal_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalDigest >*
      mutable_fix_signal_list();
  private:
  const ::zb::dcts::scenario::detection::SignalDigest& _internal_fix_signal_list(int index) const;
  ::zb::dcts::scenario::detection::SignalDigest* _internal_add_fix_signal_list();
  public:
  const ::zb::dcts::scenario::detection::SignalDigest& fix_signal_list(int index) const;
  ::zb::dcts::scenario::detection::SignalDigest* add_fix_signal_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalDigest >&
      fix_signal_list() const;

  // repeated .zb.dcts.scenario.detection.HopSignalCluster hop_signal_list = 5;
  int hop_signal_list_size() const;
  private:
  int _internal_hop_signal_list_size() const;
  public:
  void clear_hop_signal_list();
  ::zb::dcts::scenario::detection::HopSignalCluster* mutable_hop_signal_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >*
      mutable_hop_signal_list();
  private:
  const ::zb::dcts::scenario::detection::HopSignalCluster& _internal_hop_signal_list(int index) const;
  ::zb::dcts::scenario::detection::HopSignalCluster* _internal_add_hop_signal_list();
  public:
  const ::zb::dcts::scenario::detection::HopSignalCluster& hop_signal_list(int index) const;
  ::zb::dcts::scenario::detection::HopSignalCluster* add_hop_signal_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >&
      hop_signal_list() const;

  // .zb.dcts.source.SourceId result_from = 1;
  bool has_result_from() const;
  private:
  bool _internal_has_result_from() const;
  public:
  void clear_result_from();
  const ::zb::dcts::source::SourceId& result_from() const;
  ::zb::dcts::source::SourceId* release_result_from();
  ::zb::dcts::source::SourceId* mutable_result_from();
  void set_allocated_result_from(::zb::dcts::source::SourceId* result_from);
  private:
  const ::zb::dcts::source::SourceId& _internal_result_from() const;
  ::zb::dcts::source::SourceId* _internal_mutable_result_from();
  public:
  void unsafe_arena_set_allocated_result_from(
      ::zb::dcts::source::SourceId* result_from);
  ::zb::dcts::source::SourceId* unsafe_arena_release_result_from();

  // .zb.dcts.Timestamp time_stamp = 2;
  bool has_time_stamp() const;
  private:
  bool _internal_has_time_stamp() const;
  public:
  void clear_time_stamp();
  const ::zb::dcts::Timestamp& time_stamp() const;
  ::zb::dcts::Timestamp* release_time_stamp();
  ::zb::dcts::Timestamp* mutable_time_stamp();
  void set_allocated_time_stamp(::zb::dcts::Timestamp* time_stamp);
  private:
  const ::zb::dcts::Timestamp& _internal_time_stamp() const;
  ::zb::dcts::Timestamp* _internal_mutable_time_stamp();
  public:
  void unsafe_arena_set_allocated_time_stamp(
      ::zb::dcts::Timestamp* time_stamp);
  ::zb::dcts::Timestamp* unsafe_arena_release_time_stamp();

  // .zb.dcts.Position position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::zb::dcts::Position& position() const;
  ::zb::dcts::Position* release_position();
  ::zb::dcts::Position* mutable_position();
  void set_allocated_position(::zb::dcts::Position* position);
  private:
  const ::zb::dcts::Position& _internal_position() const;
  ::zb::dcts::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::zb::dcts::Position* position);
  ::zb::dcts::Position* unsafe_arena_release_position();

  // @@protoc_insertion_point(class_scope:zb.dcts.scenario.detection.SignalLayerSurvey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalDigest > fix_signal_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster > hop_signal_list_;
  ::zb::dcts::source::SourceId* result_from_;
  ::zb::dcts::Timestamp* time_stamp_;
  ::zb::dcts::Position* position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scenario_2fdetection_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ThresholdSector

// .zb.dcts.scenario.spectrum.FrequencySpan freq_span = 1;
inline bool ThresholdSector::_internal_has_freq_span() const {
  return this != internal_default_instance() && freq_span_ != nullptr;
}
inline bool ThresholdSector::has_freq_span() const {
  return _internal_has_freq_span();
}
inline const ::zb::dcts::scenario::spectrum::FrequencySpan& ThresholdSector::_internal_freq_span() const {
  const ::zb::dcts::scenario::spectrum::FrequencySpan* p = freq_span_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::spectrum::FrequencySpan*>(
      &::zb::dcts::scenario::spectrum::_FrequencySpan_default_instance_);
}
inline const ::zb::dcts::scenario::spectrum::FrequencySpan& ThresholdSector::freq_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.ThresholdSector.freq_span)
  return _internal_freq_span();
}
inline void ThresholdSector::unsafe_arena_set_allocated_freq_span(
    ::zb::dcts::scenario::spectrum::FrequencySpan* freq_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_span_);
  }
  freq_span_ = freq_span;
  if (freq_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.ThresholdSector.freq_span)
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* ThresholdSector::release_freq_span() {
  auto temp = unsafe_arena_release_freq_span();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* ThresholdSector::unsafe_arena_release_freq_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.ThresholdSector.freq_span)
  
  ::zb::dcts::scenario::spectrum::FrequencySpan* temp = freq_span_;
  freq_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* ThresholdSector::_internal_mutable_freq_span() {
  
  if (freq_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::spectrum::FrequencySpan>(GetArena());
    freq_span_ = p;
  }
  return freq_span_;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* ThresholdSector::mutable_freq_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.ThresholdSector.freq_span)
  return _internal_mutable_freq_span();
}
inline void ThresholdSector::set_allocated_freq_span(::zb::dcts::scenario::spectrum::FrequencySpan* freq_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_span_);
  }
  if (freq_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_span)->GetArena();
    if (message_arena != submessage_arena) {
      freq_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, freq_span, submessage_arena);
    }
    
  } else {
    
  }
  freq_span_ = freq_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.ThresholdSector.freq_span)
}

// float level = 2;
inline void ThresholdSector::clear_level() {
  level_ = 0;
}
inline float ThresholdSector::_internal_level() const {
  return level_;
}
inline float ThresholdSector::level() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.ThresholdSector.level)
  return _internal_level();
}
inline void ThresholdSector::_internal_set_level(float value) {
  
  level_ = value;
}
inline void ThresholdSector::set_level(float value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.ThresholdSector.level)
}

// -------------------------------------------------------------------

// UserThresholdParam

// repeated .zb.dcts.scenario.detection.ThresholdSector sectors = 1;
inline int UserThresholdParam::_internal_sectors_size() const {
  return sectors_.size();
}
inline int UserThresholdParam::sectors_size() const {
  return _internal_sectors_size();
}
inline void UserThresholdParam::clear_sectors() {
  sectors_.Clear();
}
inline ::zb::dcts::scenario::detection::ThresholdSector* UserThresholdParam::mutable_sectors(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.UserThresholdParam.sectors)
  return sectors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::ThresholdSector >*
UserThresholdParam::mutable_sectors() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.UserThresholdParam.sectors)
  return &sectors_;
}
inline const ::zb::dcts::scenario::detection::ThresholdSector& UserThresholdParam::_internal_sectors(int index) const {
  return sectors_.Get(index);
}
inline const ::zb::dcts::scenario::detection::ThresholdSector& UserThresholdParam::sectors(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.UserThresholdParam.sectors)
  return _internal_sectors(index);
}
inline ::zb::dcts::scenario::detection::ThresholdSector* UserThresholdParam::_internal_add_sectors() {
  return sectors_.Add();
}
inline ::zb::dcts::scenario::detection::ThresholdSector* UserThresholdParam::add_sectors() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.UserThresholdParam.sectors)
  return _internal_add_sectors();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::ThresholdSector >&
UserThresholdParam::sectors() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.UserThresholdParam.sectors)
  return sectors_;
}

// -------------------------------------------------------------------

// HistoryThresholdParam

// .zb.dcts.TimeSpan span = 1;
inline bool HistoryThresholdParam::_internal_has_span() const {
  return this != internal_default_instance() && span_ != nullptr;
}
inline bool HistoryThresholdParam::has_span() const {
  return _internal_has_span();
}
inline const ::zb::dcts::TimeSpan& HistoryThresholdParam::_internal_span() const {
  const ::zb::dcts::TimeSpan* p = span_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::TimeSpan*>(
      &::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& HistoryThresholdParam::span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HistoryThresholdParam.span)
  return _internal_span();
}
inline void HistoryThresholdParam::unsafe_arena_set_allocated_span(
    ::zb::dcts::TimeSpan* span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(span_);
  }
  span_ = span;
  if (span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.HistoryThresholdParam.span)
}
inline ::zb::dcts::TimeSpan* HistoryThresholdParam::release_span() {
  auto temp = unsafe_arena_release_span();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* HistoryThresholdParam::unsafe_arena_release_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.HistoryThresholdParam.span)
  
  ::zb::dcts::TimeSpan* temp = span_;
  span_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* HistoryThresholdParam::_internal_mutable_span() {
  
  if (span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    span_ = p;
  }
  return span_;
}
inline ::zb::dcts::TimeSpan* HistoryThresholdParam::mutable_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HistoryThresholdParam.span)
  return _internal_mutable_span();
}
inline void HistoryThresholdParam::set_allocated_span(::zb::dcts::TimeSpan* span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(span_);
  }
  if (span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(span)->GetArena();
    if (message_arena != submessage_arena) {
      span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, span, submessage_arena);
    }
    
  } else {
    
  }
  span_ = span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.HistoryThresholdParam.span)
}

// int32 max_load_count = 3;
inline void HistoryThresholdParam::clear_max_load_count() {
  max_load_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HistoryThresholdParam::_internal_max_load_count() const {
  return max_load_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HistoryThresholdParam::max_load_count() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HistoryThresholdParam.max_load_count)
  return _internal_max_load_count();
}
inline void HistoryThresholdParam::_internal_set_max_load_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_load_count_ = value;
}
inline void HistoryThresholdParam::set_max_load_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_load_count(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.HistoryThresholdParam.max_load_count)
}

// float offset = 4;
inline void HistoryThresholdParam::clear_offset() {
  offset_ = 0;
}
inline float HistoryThresholdParam::_internal_offset() const {
  return offset_;
}
inline float HistoryThresholdParam::offset() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HistoryThresholdParam.offset)
  return _internal_offset();
}
inline void HistoryThresholdParam::_internal_set_offset(float value) {
  
  offset_ = value;
}
inline void HistoryThresholdParam::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.HistoryThresholdParam.offset)
}

// -------------------------------------------------------------------

// AdaptiveThresholdParam

// int32 average_count = 1;
inline void AdaptiveThresholdParam::clear_average_count() {
  average_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AdaptiveThresholdParam::_internal_average_count() const {
  return average_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AdaptiveThresholdParam::average_count() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.AdaptiveThresholdParam.average_count)
  return _internal_average_count();
}
inline void AdaptiveThresholdParam::_internal_set_average_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  average_count_ = value;
}
inline void AdaptiveThresholdParam::set_average_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_average_count(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.AdaptiveThresholdParam.average_count)
}

// .zb.dcts.scenario.detection.AdaptiveThresholdParam.PartitionMode partition_mode = 2;
inline void AdaptiveThresholdParam::clear_partition_mode() {
  partition_mode_ = 0;
}
inline ::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode AdaptiveThresholdParam::_internal_partition_mode() const {
  return static_cast< ::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode >(partition_mode_);
}
inline ::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode AdaptiveThresholdParam::partition_mode() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.AdaptiveThresholdParam.partition_mode)
  return _internal_partition_mode();
}
inline void AdaptiveThresholdParam::_internal_set_partition_mode(::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode value) {
  
  partition_mode_ = value;
}
inline void AdaptiveThresholdParam::set_partition_mode(::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode value) {
  _internal_set_partition_mode(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.AdaptiveThresholdParam.partition_mode)
}

// float offset = 3;
inline void AdaptiveThresholdParam::clear_offset() {
  offset_ = 0;
}
inline float AdaptiveThresholdParam::_internal_offset() const {
  return offset_;
}
inline float AdaptiveThresholdParam::offset() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.AdaptiveThresholdParam.offset)
  return _internal_offset();
}
inline void AdaptiveThresholdParam::_internal_set_offset(float value) {
  
  offset_ = value;
}
inline void AdaptiveThresholdParam::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.AdaptiveThresholdParam.offset)
}

// -------------------------------------------------------------------

// NeighborVarThresholdParam

// float noise_variance_scale = 1;
inline void NeighborVarThresholdParam::clear_noise_variance_scale() {
  noise_variance_scale_ = 0;
}
inline float NeighborVarThresholdParam::_internal_noise_variance_scale() const {
  return noise_variance_scale_;
}
inline float NeighborVarThresholdParam::noise_variance_scale() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.NeighborVarThresholdParam.noise_variance_scale)
  return _internal_noise_variance_scale();
}
inline void NeighborVarThresholdParam::_internal_set_noise_variance_scale(float value) {
  
  noise_variance_scale_ = value;
}
inline void NeighborVarThresholdParam::set_noise_variance_scale(float value) {
  _internal_set_noise_variance_scale(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.NeighborVarThresholdParam.noise_variance_scale)
}

// float noise_max_variance = 2;
inline void NeighborVarThresholdParam::clear_noise_max_variance() {
  noise_max_variance_ = 0;
}
inline float NeighborVarThresholdParam::_internal_noise_max_variance() const {
  return noise_max_variance_;
}
inline float NeighborVarThresholdParam::noise_max_variance() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.NeighborVarThresholdParam.noise_max_variance)
  return _internal_noise_max_variance();
}
inline void NeighborVarThresholdParam::_internal_set_noise_max_variance(float value) {
  
  noise_max_variance_ = value;
}
inline void NeighborVarThresholdParam::set_noise_max_variance(float value) {
  _internal_set_noise_max_variance(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.NeighborVarThresholdParam.noise_max_variance)
}

// float offset = 3;
inline void NeighborVarThresholdParam::clear_offset() {
  offset_ = 0;
}
inline float NeighborVarThresholdParam::_internal_offset() const {
  return offset_;
}
inline float NeighborVarThresholdParam::offset() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.NeighborVarThresholdParam.offset)
  return _internal_offset();
}
inline void NeighborVarThresholdParam::_internal_set_offset(float value) {
  
  offset_ = value;
}
inline void NeighborVarThresholdParam::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.NeighborVarThresholdParam.offset)
}

// double lookup_freq_span = 4;
inline void NeighborVarThresholdParam::clear_lookup_freq_span() {
  lookup_freq_span_ = 0;
}
inline double NeighborVarThresholdParam::_internal_lookup_freq_span() const {
  return lookup_freq_span_;
}
inline double NeighborVarThresholdParam::lookup_freq_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.NeighborVarThresholdParam.lookup_freq_span)
  return _internal_lookup_freq_span();
}
inline void NeighborVarThresholdParam::_internal_set_lookup_freq_span(double value) {
  
  lookup_freq_span_ = value;
}
inline void NeighborVarThresholdParam::set_lookup_freq_span(double value) {
  _internal_set_lookup_freq_span(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.NeighborVarThresholdParam.lookup_freq_span)
}

// int32 smooth_range = 5;
inline void NeighborVarThresholdParam::clear_smooth_range() {
  smooth_range_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NeighborVarThresholdParam::_internal_smooth_range() const {
  return smooth_range_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NeighborVarThresholdParam::smooth_range() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.NeighborVarThresholdParam.smooth_range)
  return _internal_smooth_range();
}
inline void NeighborVarThresholdParam::_internal_set_smooth_range(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  smooth_range_ = value;
}
inline void NeighborVarThresholdParam::set_smooth_range(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_smooth_range(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.NeighborVarThresholdParam.smooth_range)
}

// -------------------------------------------------------------------

// EnergyDetectionParam

// repeated .zb.dcts.scenario.detection.ThresholdType active_types = 1;
inline int EnergyDetectionParam::_internal_active_types_size() const {
  return active_types_.size();
}
inline int EnergyDetectionParam::active_types_size() const {
  return _internal_active_types_size();
}
inline void EnergyDetectionParam::clear_active_types() {
  active_types_.Clear();
}
inline ::zb::dcts::scenario::detection::ThresholdType EnergyDetectionParam::_internal_active_types(int index) const {
  return static_cast< ::zb::dcts::scenario::detection::ThresholdType >(active_types_.Get(index));
}
inline ::zb::dcts::scenario::detection::ThresholdType EnergyDetectionParam::active_types(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.EnergyDetectionParam.active_types)
  return _internal_active_types(index);
}
inline void EnergyDetectionParam::set_active_types(int index, ::zb::dcts::scenario::detection::ThresholdType value) {
  active_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.EnergyDetectionParam.active_types)
}
inline void EnergyDetectionParam::_internal_add_active_types(::zb::dcts::scenario::detection::ThresholdType value) {
  active_types_.Add(value);
}
inline void EnergyDetectionParam::add_active_types(::zb::dcts::scenario::detection::ThresholdType value) {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.EnergyDetectionParam.active_types)
  _internal_add_active_types(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
EnergyDetectionParam::active_types() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.EnergyDetectionParam.active_types)
  return active_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
EnergyDetectionParam::_internal_mutable_active_types() {
  return &active_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
EnergyDetectionParam::mutable_active_types() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.EnergyDetectionParam.active_types)
  return _internal_mutable_active_types();
}

// .zb.dcts.scenario.detection.EnergyDetectionParam.LogicType logic = 2;
inline void EnergyDetectionParam::clear_logic() {
  logic_ = 0;
}
inline ::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType EnergyDetectionParam::_internal_logic() const {
  return static_cast< ::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType >(logic_);
}
inline ::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType EnergyDetectionParam::logic() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.EnergyDetectionParam.logic)
  return _internal_logic();
}
inline void EnergyDetectionParam::_internal_set_logic(::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType value) {
  
  logic_ = value;
}
inline void EnergyDetectionParam::set_logic(::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType value) {
  _internal_set_logic(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.EnergyDetectionParam.logic)
}

// .zb.dcts.scenario.detection.HistoryThresholdParam history_threshold = 5;
inline bool EnergyDetectionParam::_internal_has_history_threshold() const {
  return this != internal_default_instance() && history_threshold_ != nullptr;
}
inline bool EnergyDetectionParam::has_history_threshold() const {
  return _internal_has_history_threshold();
}
inline void EnergyDetectionParam::clear_history_threshold() {
  if (GetArena() == nullptr && history_threshold_ != nullptr) {
    delete history_threshold_;
  }
  history_threshold_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::HistoryThresholdParam& EnergyDetectionParam::_internal_history_threshold() const {
  const ::zb::dcts::scenario::detection::HistoryThresholdParam* p = history_threshold_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::HistoryThresholdParam*>(
      &::zb::dcts::scenario::detection::_HistoryThresholdParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::HistoryThresholdParam& EnergyDetectionParam::history_threshold() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.EnergyDetectionParam.history_threshold)
  return _internal_history_threshold();
}
inline void EnergyDetectionParam::unsafe_arena_set_allocated_history_threshold(
    ::zb::dcts::scenario::detection::HistoryThresholdParam* history_threshold) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(history_threshold_);
  }
  history_threshold_ = history_threshold;
  if (history_threshold) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.EnergyDetectionParam.history_threshold)
}
inline ::zb::dcts::scenario::detection::HistoryThresholdParam* EnergyDetectionParam::release_history_threshold() {
  auto temp = unsafe_arena_release_history_threshold();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::HistoryThresholdParam* EnergyDetectionParam::unsafe_arena_release_history_threshold() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.EnergyDetectionParam.history_threshold)
  
  ::zb::dcts::scenario::detection::HistoryThresholdParam* temp = history_threshold_;
  history_threshold_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::HistoryThresholdParam* EnergyDetectionParam::_internal_mutable_history_threshold() {
  
  if (history_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::HistoryThresholdParam>(GetArena());
    history_threshold_ = p;
  }
  return history_threshold_;
}
inline ::zb::dcts::scenario::detection::HistoryThresholdParam* EnergyDetectionParam::mutable_history_threshold() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.EnergyDetectionParam.history_threshold)
  return _internal_mutable_history_threshold();
}
inline void EnergyDetectionParam::set_allocated_history_threshold(::zb::dcts::scenario::detection::HistoryThresholdParam* history_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete history_threshold_;
  }
  if (history_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(history_threshold);
    if (message_arena != submessage_arena) {
      history_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, history_threshold, submessage_arena);
    }
    
  } else {
    
  }
  history_threshold_ = history_threshold;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.EnergyDetectionParam.history_threshold)
}

// .zb.dcts.scenario.detection.UserThresholdParam user_threshold = 6;
inline bool EnergyDetectionParam::_internal_has_user_threshold() const {
  return this != internal_default_instance() && user_threshold_ != nullptr;
}
inline bool EnergyDetectionParam::has_user_threshold() const {
  return _internal_has_user_threshold();
}
inline void EnergyDetectionParam::clear_user_threshold() {
  if (GetArena() == nullptr && user_threshold_ != nullptr) {
    delete user_threshold_;
  }
  user_threshold_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::UserThresholdParam& EnergyDetectionParam::_internal_user_threshold() const {
  const ::zb::dcts::scenario::detection::UserThresholdParam* p = user_threshold_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::UserThresholdParam*>(
      &::zb::dcts::scenario::detection::_UserThresholdParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::UserThresholdParam& EnergyDetectionParam::user_threshold() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.EnergyDetectionParam.user_threshold)
  return _internal_user_threshold();
}
inline void EnergyDetectionParam::unsafe_arena_set_allocated_user_threshold(
    ::zb::dcts::scenario::detection::UserThresholdParam* user_threshold) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_threshold_);
  }
  user_threshold_ = user_threshold;
  if (user_threshold) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.EnergyDetectionParam.user_threshold)
}
inline ::zb::dcts::scenario::detection::UserThresholdParam* EnergyDetectionParam::release_user_threshold() {
  auto temp = unsafe_arena_release_user_threshold();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::UserThresholdParam* EnergyDetectionParam::unsafe_arena_release_user_threshold() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.EnergyDetectionParam.user_threshold)
  
  ::zb::dcts::scenario::detection::UserThresholdParam* temp = user_threshold_;
  user_threshold_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::UserThresholdParam* EnergyDetectionParam::_internal_mutable_user_threshold() {
  
  if (user_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::UserThresholdParam>(GetArena());
    user_threshold_ = p;
  }
  return user_threshold_;
}
inline ::zb::dcts::scenario::detection::UserThresholdParam* EnergyDetectionParam::mutable_user_threshold() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.EnergyDetectionParam.user_threshold)
  return _internal_mutable_user_threshold();
}
inline void EnergyDetectionParam::set_allocated_user_threshold(::zb::dcts::scenario::detection::UserThresholdParam* user_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_threshold_;
  }
  if (user_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user_threshold);
    if (message_arena != submessage_arena) {
      user_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_threshold, submessage_arena);
    }
    
  } else {
    
  }
  user_threshold_ = user_threshold;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.EnergyDetectionParam.user_threshold)
}

// .zb.dcts.scenario.detection.AdaptiveThresholdParam adaptive_threshold = 7;
inline bool EnergyDetectionParam::_internal_has_adaptive_threshold() const {
  return this != internal_default_instance() && adaptive_threshold_ != nullptr;
}
inline bool EnergyDetectionParam::has_adaptive_threshold() const {
  return _internal_has_adaptive_threshold();
}
inline void EnergyDetectionParam::clear_adaptive_threshold() {
  if (GetArena() == nullptr && adaptive_threshold_ != nullptr) {
    delete adaptive_threshold_;
  }
  adaptive_threshold_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::AdaptiveThresholdParam& EnergyDetectionParam::_internal_adaptive_threshold() const {
  const ::zb::dcts::scenario::detection::AdaptiveThresholdParam* p = adaptive_threshold_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::AdaptiveThresholdParam*>(
      &::zb::dcts::scenario::detection::_AdaptiveThresholdParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::AdaptiveThresholdParam& EnergyDetectionParam::adaptive_threshold() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.EnergyDetectionParam.adaptive_threshold)
  return _internal_adaptive_threshold();
}
inline void EnergyDetectionParam::unsafe_arena_set_allocated_adaptive_threshold(
    ::zb::dcts::scenario::detection::AdaptiveThresholdParam* adaptive_threshold) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adaptive_threshold_);
  }
  adaptive_threshold_ = adaptive_threshold;
  if (adaptive_threshold) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.EnergyDetectionParam.adaptive_threshold)
}
inline ::zb::dcts::scenario::detection::AdaptiveThresholdParam* EnergyDetectionParam::release_adaptive_threshold() {
  auto temp = unsafe_arena_release_adaptive_threshold();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::AdaptiveThresholdParam* EnergyDetectionParam::unsafe_arena_release_adaptive_threshold() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.EnergyDetectionParam.adaptive_threshold)
  
  ::zb::dcts::scenario::detection::AdaptiveThresholdParam* temp = adaptive_threshold_;
  adaptive_threshold_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::AdaptiveThresholdParam* EnergyDetectionParam::_internal_mutable_adaptive_threshold() {
  
  if (adaptive_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::AdaptiveThresholdParam>(GetArena());
    adaptive_threshold_ = p;
  }
  return adaptive_threshold_;
}
inline ::zb::dcts::scenario::detection::AdaptiveThresholdParam* EnergyDetectionParam::mutable_adaptive_threshold() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.EnergyDetectionParam.adaptive_threshold)
  return _internal_mutable_adaptive_threshold();
}
inline void EnergyDetectionParam::set_allocated_adaptive_threshold(::zb::dcts::scenario::detection::AdaptiveThresholdParam* adaptive_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete adaptive_threshold_;
  }
  if (adaptive_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(adaptive_threshold);
    if (message_arena != submessage_arena) {
      adaptive_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adaptive_threshold, submessage_arena);
    }
    
  } else {
    
  }
  adaptive_threshold_ = adaptive_threshold;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.EnergyDetectionParam.adaptive_threshold)
}

// .zb.dcts.scenario.detection.NeighborVarThresholdParam neighbor_threshold = 9;
inline bool EnergyDetectionParam::_internal_has_neighbor_threshold() const {
  return this != internal_default_instance() && neighbor_threshold_ != nullptr;
}
inline bool EnergyDetectionParam::has_neighbor_threshold() const {
  return _internal_has_neighbor_threshold();
}
inline void EnergyDetectionParam::clear_neighbor_threshold() {
  if (GetArena() == nullptr && neighbor_threshold_ != nullptr) {
    delete neighbor_threshold_;
  }
  neighbor_threshold_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::NeighborVarThresholdParam& EnergyDetectionParam::_internal_neighbor_threshold() const {
  const ::zb::dcts::scenario::detection::NeighborVarThresholdParam* p = neighbor_threshold_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::NeighborVarThresholdParam*>(
      &::zb::dcts::scenario::detection::_NeighborVarThresholdParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::NeighborVarThresholdParam& EnergyDetectionParam::neighbor_threshold() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.EnergyDetectionParam.neighbor_threshold)
  return _internal_neighbor_threshold();
}
inline void EnergyDetectionParam::unsafe_arena_set_allocated_neighbor_threshold(
    ::zb::dcts::scenario::detection::NeighborVarThresholdParam* neighbor_threshold) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(neighbor_threshold_);
  }
  neighbor_threshold_ = neighbor_threshold;
  if (neighbor_threshold) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.EnergyDetectionParam.neighbor_threshold)
}
inline ::zb::dcts::scenario::detection::NeighborVarThresholdParam* EnergyDetectionParam::release_neighbor_threshold() {
  auto temp = unsafe_arena_release_neighbor_threshold();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::NeighborVarThresholdParam* EnergyDetectionParam::unsafe_arena_release_neighbor_threshold() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.EnergyDetectionParam.neighbor_threshold)
  
  ::zb::dcts::scenario::detection::NeighborVarThresholdParam* temp = neighbor_threshold_;
  neighbor_threshold_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::NeighborVarThresholdParam* EnergyDetectionParam::_internal_mutable_neighbor_threshold() {
  
  if (neighbor_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::NeighborVarThresholdParam>(GetArena());
    neighbor_threshold_ = p;
  }
  return neighbor_threshold_;
}
inline ::zb::dcts::scenario::detection::NeighborVarThresholdParam* EnergyDetectionParam::mutable_neighbor_threshold() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.EnergyDetectionParam.neighbor_threshold)
  return _internal_mutable_neighbor_threshold();
}
inline void EnergyDetectionParam::set_allocated_neighbor_threshold(::zb::dcts::scenario::detection::NeighborVarThresholdParam* neighbor_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete neighbor_threshold_;
  }
  if (neighbor_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(neighbor_threshold);
    if (message_arena != submessage_arena) {
      neighbor_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neighbor_threshold, submessage_arena);
    }
    
  } else {
    
  }
  neighbor_threshold_ = neighbor_threshold;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.EnergyDetectionParam.neighbor_threshold)
}

// -------------------------------------------------------------------

// ThresholdTrace

// .zb.dcts.scenario.detection.ThresholdType type = 1;
inline void ThresholdTrace::clear_type() {
  type_ = 0;
}
inline ::zb::dcts::scenario::detection::ThresholdType ThresholdTrace::_internal_type() const {
  return static_cast< ::zb::dcts::scenario::detection::ThresholdType >(type_);
}
inline ::zb::dcts::scenario::detection::ThresholdType ThresholdTrace::type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.ThresholdTrace.type)
  return _internal_type();
}
inline void ThresholdTrace::_internal_set_type(::zb::dcts::scenario::detection::ThresholdType value) {
  
  type_ = value;
}
inline void ThresholdTrace::set_type(::zb::dcts::scenario::detection::ThresholdType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.ThresholdTrace.type)
}

// repeated float threshold_trace = 2;
inline int ThresholdTrace::_internal_threshold_trace_size() const {
  return threshold_trace_.size();
}
inline int ThresholdTrace::threshold_trace_size() const {
  return _internal_threshold_trace_size();
}
inline void ThresholdTrace::clear_threshold_trace() {
  threshold_trace_.Clear();
}
inline float ThresholdTrace::_internal_threshold_trace(int index) const {
  return threshold_trace_.Get(index);
}
inline float ThresholdTrace::threshold_trace(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.ThresholdTrace.threshold_trace)
  return _internal_threshold_trace(index);
}
inline void ThresholdTrace::set_threshold_trace(int index, float value) {
  threshold_trace_.Set(index, value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.ThresholdTrace.threshold_trace)
}
inline void ThresholdTrace::_internal_add_threshold_trace(float value) {
  threshold_trace_.Add(value);
}
inline void ThresholdTrace::add_threshold_trace(float value) {
  _internal_add_threshold_trace(value);
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.ThresholdTrace.threshold_trace)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ThresholdTrace::_internal_threshold_trace() const {
  return threshold_trace_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ThresholdTrace::threshold_trace() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.ThresholdTrace.threshold_trace)
  return _internal_threshold_trace();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ThresholdTrace::_internal_mutable_threshold_trace() {
  return &threshold_trace_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ThresholdTrace::mutable_threshold_trace() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.ThresholdTrace.threshold_trace)
  return _internal_mutable_threshold_trace();
}

// -------------------------------------------------------------------

// FreqSpanFilter

// repeated .zb.dcts.scenario.spectrum.FrequencySpan freq_spans = 1;
inline int FreqSpanFilter::_internal_freq_spans_size() const {
  return freq_spans_.size();
}
inline int FreqSpanFilter::freq_spans_size() const {
  return _internal_freq_spans_size();
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* FreqSpanFilter::mutable_freq_spans(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.FreqSpanFilter.freq_spans)
  return freq_spans_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::spectrum::FrequencySpan >*
FreqSpanFilter::mutable_freq_spans() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.FreqSpanFilter.freq_spans)
  return &freq_spans_;
}
inline const ::zb::dcts::scenario::spectrum::FrequencySpan& FreqSpanFilter::_internal_freq_spans(int index) const {
  return freq_spans_.Get(index);
}
inline const ::zb::dcts::scenario::spectrum::FrequencySpan& FreqSpanFilter::freq_spans(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.FreqSpanFilter.freq_spans)
  return _internal_freq_spans(index);
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* FreqSpanFilter::_internal_add_freq_spans() {
  return freq_spans_.Add();
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* FreqSpanFilter::add_freq_spans() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.FreqSpanFilter.freq_spans)
  return _internal_add_freq_spans();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::spectrum::FrequencySpan >&
FreqSpanFilter::freq_spans() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.FreqSpanFilter.freq_spans)
  return freq_spans_;
}

// -------------------------------------------------------------------

// SignalSegmentationParam

// float freq_center_jitter_tolerance = 1;
inline void SignalSegmentationParam::clear_freq_center_jitter_tolerance() {
  freq_center_jitter_tolerance_ = 0;
}
inline float SignalSegmentationParam::_internal_freq_center_jitter_tolerance() const {
  return freq_center_jitter_tolerance_;
}
inline float SignalSegmentationParam::freq_center_jitter_tolerance() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalSegmentationParam.freq_center_jitter_tolerance)
  return _internal_freq_center_jitter_tolerance();
}
inline void SignalSegmentationParam::_internal_set_freq_center_jitter_tolerance(float value) {
  
  freq_center_jitter_tolerance_ = value;
}
inline void SignalSegmentationParam::set_freq_center_jitter_tolerance(float value) {
  _internal_set_freq_center_jitter_tolerance(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalSegmentationParam.freq_center_jitter_tolerance)
}

// float freq_border_blur_tolerance = 2;
inline void SignalSegmentationParam::clear_freq_border_blur_tolerance() {
  freq_border_blur_tolerance_ = 0;
}
inline float SignalSegmentationParam::_internal_freq_border_blur_tolerance() const {
  return freq_border_blur_tolerance_;
}
inline float SignalSegmentationParam::freq_border_blur_tolerance() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalSegmentationParam.freq_border_blur_tolerance)
  return _internal_freq_border_blur_tolerance();
}
inline void SignalSegmentationParam::_internal_set_freq_border_blur_tolerance(float value) {
  
  freq_border_blur_tolerance_ = value;
}
inline void SignalSegmentationParam::set_freq_border_blur_tolerance(float value) {
  _internal_set_freq_border_blur_tolerance(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalSegmentationParam.freq_border_blur_tolerance)
}

// float min_rss = 3;
inline void SignalSegmentationParam::clear_min_rss() {
  min_rss_ = 0;
}
inline float SignalSegmentationParam::_internal_min_rss() const {
  return min_rss_;
}
inline float SignalSegmentationParam::min_rss() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalSegmentationParam.min_rss)
  return _internal_min_rss();
}
inline void SignalSegmentationParam::_internal_set_min_rss(float value) {
  
  min_rss_ = value;
}
inline void SignalSegmentationParam::set_min_rss(float value) {
  _internal_set_min_rss(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalSegmentationParam.min_rss)
}

// int32 time_gap_tolerance = 4;
inline void SignalSegmentationParam::clear_time_gap_tolerance() {
  time_gap_tolerance_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalSegmentationParam::_internal_time_gap_tolerance() const {
  return time_gap_tolerance_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalSegmentationParam::time_gap_tolerance() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalSegmentationParam.time_gap_tolerance)
  return _internal_time_gap_tolerance();
}
inline void SignalSegmentationParam::_internal_set_time_gap_tolerance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  time_gap_tolerance_ = value;
}
inline void SignalSegmentationParam::set_time_gap_tolerance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time_gap_tolerance(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalSegmentationParam.time_gap_tolerance)
}

// -------------------------------------------------------------------

// HopSignalClusterParam

// string name = 1;
inline void HopSignalClusterParam::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HopSignalClusterParam::name() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalClusterParam.name)
  return _internal_name();
}
inline void HopSignalClusterParam::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.HopSignalClusterParam.name)
}
inline std::string* HopSignalClusterParam::mutable_name() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalClusterParam.name)
  return _internal_mutable_name();
}
inline const std::string& HopSignalClusterParam::_internal_name() const {
  return name_.Get();
}
inline void HopSignalClusterParam::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HopSignalClusterParam::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.scenario.detection.HopSignalClusterParam.name)
}
inline void HopSignalClusterParam::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.scenario.detection.HopSignalClusterParam.name)
}
inline void HopSignalClusterParam::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.scenario.detection.HopSignalClusterParam.name)
}
inline std::string* HopSignalClusterParam::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HopSignalClusterParam::release_name() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.HopSignalClusterParam.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HopSignalClusterParam::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.HopSignalClusterParam.name)
}
inline std::string* HopSignalClusterParam::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.scenario.detection.HopSignalClusterParam.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void HopSignalClusterParam::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.HopSignalClusterParam.name)
}

// .zb.dcts.scenario.spectrum.FrequencySpan frequency_range = 2;
inline bool HopSignalClusterParam::_internal_has_frequency_range() const {
  return this != internal_default_instance() && frequency_range_ != nullptr;
}
inline bool HopSignalClusterParam::has_frequency_range() const {
  return _internal_has_frequency_range();
}
inline const ::zb::dcts::scenario::spectrum::FrequencySpan& HopSignalClusterParam::_internal_frequency_range() const {
  const ::zb::dcts::scenario::spectrum::FrequencySpan* p = frequency_range_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::spectrum::FrequencySpan*>(
      &::zb::dcts::scenario::spectrum::_FrequencySpan_default_instance_);
}
inline const ::zb::dcts::scenario::spectrum::FrequencySpan& HopSignalClusterParam::frequency_range() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalClusterParam.frequency_range)
  return _internal_frequency_range();
}
inline void HopSignalClusterParam::unsafe_arena_set_allocated_frequency_range(
    ::zb::dcts::scenario::spectrum::FrequencySpan* frequency_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frequency_range_);
  }
  frequency_range_ = frequency_range;
  if (frequency_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.HopSignalClusterParam.frequency_range)
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* HopSignalClusterParam::release_frequency_range() {
  auto temp = unsafe_arena_release_frequency_range();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* HopSignalClusterParam::unsafe_arena_release_frequency_range() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.HopSignalClusterParam.frequency_range)
  
  ::zb::dcts::scenario::spectrum::FrequencySpan* temp = frequency_range_;
  frequency_range_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* HopSignalClusterParam::_internal_mutable_frequency_range() {
  
  if (frequency_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::spectrum::FrequencySpan>(GetArena());
    frequency_range_ = p;
  }
  return frequency_range_;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* HopSignalClusterParam::mutable_frequency_range() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalClusterParam.frequency_range)
  return _internal_mutable_frequency_range();
}
inline void HopSignalClusterParam::set_allocated_frequency_range(::zb::dcts::scenario::spectrum::FrequencySpan* frequency_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(frequency_range_);
  }
  if (frequency_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frequency_range)->GetArena();
    if (message_arena != submessage_arena) {
      frequency_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frequency_range, submessage_arena);
    }
    
  } else {
    
  }
  frequency_range_ = frequency_range;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.HopSignalClusterParam.frequency_range)
}

// .zb.dcts.DRange band_width_range = 3;
inline bool HopSignalClusterParam::_internal_has_band_width_range() const {
  return this != internal_default_instance() && band_width_range_ != nullptr;
}
inline bool HopSignalClusterParam::has_band_width_range() const {
  return _internal_has_band_width_range();
}
inline const ::zb::dcts::DRange& HopSignalClusterParam::_internal_band_width_range() const {
  const ::zb::dcts::DRange* p = band_width_range_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::DRange*>(
      &::zb::dcts::_DRange_default_instance_);
}
inline const ::zb::dcts::DRange& HopSignalClusterParam::band_width_range() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalClusterParam.band_width_range)
  return _internal_band_width_range();
}
inline void HopSignalClusterParam::unsafe_arena_set_allocated_band_width_range(
    ::zb::dcts::DRange* band_width_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width_range_);
  }
  band_width_range_ = band_width_range;
  if (band_width_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.HopSignalClusterParam.band_width_range)
}
inline ::zb::dcts::DRange* HopSignalClusterParam::release_band_width_range() {
  auto temp = unsafe_arena_release_band_width_range();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::DRange* HopSignalClusterParam::unsafe_arena_release_band_width_range() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.HopSignalClusterParam.band_width_range)
  
  ::zb::dcts::DRange* temp = band_width_range_;
  band_width_range_ = nullptr;
  return temp;
}
inline ::zb::dcts::DRange* HopSignalClusterParam::_internal_mutable_band_width_range() {
  
  if (band_width_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::DRange>(GetArena());
    band_width_range_ = p;
  }
  return band_width_range_;
}
inline ::zb::dcts::DRange* HopSignalClusterParam::mutable_band_width_range() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalClusterParam.band_width_range)
  return _internal_mutable_band_width_range();
}
inline void HopSignalClusterParam::set_allocated_band_width_range(::zb::dcts::DRange* band_width_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width_range_);
  }
  if (band_width_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width_range)->GetArena();
    if (message_arena != submessage_arena) {
      band_width_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, band_width_range, submessage_arena);
    }
    
  } else {
    
  }
  band_width_range_ = band_width_range;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.HopSignalClusterParam.band_width_range)
}

// float freq_jitter_tolerance = 4;
inline void HopSignalClusterParam::clear_freq_jitter_tolerance() {
  freq_jitter_tolerance_ = 0;
}
inline float HopSignalClusterParam::_internal_freq_jitter_tolerance() const {
  return freq_jitter_tolerance_;
}
inline float HopSignalClusterParam::freq_jitter_tolerance() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalClusterParam.freq_jitter_tolerance)
  return _internal_freq_jitter_tolerance();
}
inline void HopSignalClusterParam::_internal_set_freq_jitter_tolerance(float value) {
  
  freq_jitter_tolerance_ = value;
}
inline void HopSignalClusterParam::set_freq_jitter_tolerance(float value) {
  _internal_set_freq_jitter_tolerance(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.HopSignalClusterParam.freq_jitter_tolerance)
}

// -------------------------------------------------------------------

// HopSignalDetectionParam

// repeated .zb.dcts.scenario.detection.HopSignalClusterParam hop_signal_clusters = 1;
inline int HopSignalDetectionParam::_internal_hop_signal_clusters_size() const {
  return hop_signal_clusters_.size();
}
inline int HopSignalDetectionParam::hop_signal_clusters_size() const {
  return _internal_hop_signal_clusters_size();
}
inline void HopSignalDetectionParam::clear_hop_signal_clusters() {
  hop_signal_clusters_.Clear();
}
inline ::zb::dcts::scenario::detection::HopSignalClusterParam* HopSignalDetectionParam::mutable_hop_signal_clusters(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalDetectionParam.hop_signal_clusters)
  return hop_signal_clusters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalClusterParam >*
HopSignalDetectionParam::mutable_hop_signal_clusters() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.HopSignalDetectionParam.hop_signal_clusters)
  return &hop_signal_clusters_;
}
inline const ::zb::dcts::scenario::detection::HopSignalClusterParam& HopSignalDetectionParam::_internal_hop_signal_clusters(int index) const {
  return hop_signal_clusters_.Get(index);
}
inline const ::zb::dcts::scenario::detection::HopSignalClusterParam& HopSignalDetectionParam::hop_signal_clusters(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalDetectionParam.hop_signal_clusters)
  return _internal_hop_signal_clusters(index);
}
inline ::zb::dcts::scenario::detection::HopSignalClusterParam* HopSignalDetectionParam::_internal_add_hop_signal_clusters() {
  return hop_signal_clusters_.Add();
}
inline ::zb::dcts::scenario::detection::HopSignalClusterParam* HopSignalDetectionParam::add_hop_signal_clusters() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.HopSignalDetectionParam.hop_signal_clusters)
  return _internal_add_hop_signal_clusters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalClusterParam >&
HopSignalDetectionParam::hop_signal_clusters() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.HopSignalDetectionParam.hop_signal_clusters)
  return hop_signal_clusters_;
}

// -------------------------------------------------------------------

// SignalDetectParam

// .zb.dcts.scenario.detection.FreqSpanFilter white_list = 1;
inline bool SignalDetectParam::_internal_has_white_list() const {
  return this != internal_default_instance() && white_list_ != nullptr;
}
inline bool SignalDetectParam::has_white_list() const {
  return _internal_has_white_list();
}
inline void SignalDetectParam::clear_white_list() {
  if (GetArena() == nullptr && white_list_ != nullptr) {
    delete white_list_;
  }
  white_list_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::FreqSpanFilter& SignalDetectParam::_internal_white_list() const {
  const ::zb::dcts::scenario::detection::FreqSpanFilter* p = white_list_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::FreqSpanFilter*>(
      &::zb::dcts::scenario::detection::_FreqSpanFilter_default_instance_);
}
inline const ::zb::dcts::scenario::detection::FreqSpanFilter& SignalDetectParam::white_list() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDetectParam.white_list)
  return _internal_white_list();
}
inline void SignalDetectParam::unsafe_arena_set_allocated_white_list(
    ::zb::dcts::scenario::detection::FreqSpanFilter* white_list) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(white_list_);
  }
  white_list_ = white_list;
  if (white_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDetectParam.white_list)
}
inline ::zb::dcts::scenario::detection::FreqSpanFilter* SignalDetectParam::release_white_list() {
  auto temp = unsafe_arena_release_white_list();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::FreqSpanFilter* SignalDetectParam::unsafe_arena_release_white_list() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDetectParam.white_list)
  
  ::zb::dcts::scenario::detection::FreqSpanFilter* temp = white_list_;
  white_list_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::FreqSpanFilter* SignalDetectParam::_internal_mutable_white_list() {
  
  if (white_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::FreqSpanFilter>(GetArena());
    white_list_ = p;
  }
  return white_list_;
}
inline ::zb::dcts::scenario::detection::FreqSpanFilter* SignalDetectParam::mutable_white_list() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDetectParam.white_list)
  return _internal_mutable_white_list();
}
inline void SignalDetectParam::set_allocated_white_list(::zb::dcts::scenario::detection::FreqSpanFilter* white_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete white_list_;
  }
  if (white_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(white_list);
    if (message_arena != submessage_arena) {
      white_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, white_list, submessage_arena);
    }
    
  } else {
    
  }
  white_list_ = white_list;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDetectParam.white_list)
}

// .zb.dcts.scenario.detection.SignalSegmentationParam signal_segmenation_param = 2;
inline bool SignalDetectParam::_internal_has_signal_segmenation_param() const {
  return this != internal_default_instance() && signal_segmenation_param_ != nullptr;
}
inline bool SignalDetectParam::has_signal_segmenation_param() const {
  return _internal_has_signal_segmenation_param();
}
inline void SignalDetectParam::clear_signal_segmenation_param() {
  if (GetArena() == nullptr && signal_segmenation_param_ != nullptr) {
    delete signal_segmenation_param_;
  }
  signal_segmenation_param_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::SignalSegmentationParam& SignalDetectParam::_internal_signal_segmenation_param() const {
  const ::zb::dcts::scenario::detection::SignalSegmentationParam* p = signal_segmenation_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::SignalSegmentationParam*>(
      &::zb::dcts::scenario::detection::_SignalSegmentationParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::SignalSegmentationParam& SignalDetectParam::signal_segmenation_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDetectParam.signal_segmenation_param)
  return _internal_signal_segmenation_param();
}
inline void SignalDetectParam::unsafe_arena_set_allocated_signal_segmenation_param(
    ::zb::dcts::scenario::detection::SignalSegmentationParam* signal_segmenation_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_segmenation_param_);
  }
  signal_segmenation_param_ = signal_segmenation_param;
  if (signal_segmenation_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDetectParam.signal_segmenation_param)
}
inline ::zb::dcts::scenario::detection::SignalSegmentationParam* SignalDetectParam::release_signal_segmenation_param() {
  auto temp = unsafe_arena_release_signal_segmenation_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::SignalSegmentationParam* SignalDetectParam::unsafe_arena_release_signal_segmenation_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDetectParam.signal_segmenation_param)
  
  ::zb::dcts::scenario::detection::SignalSegmentationParam* temp = signal_segmenation_param_;
  signal_segmenation_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::SignalSegmentationParam* SignalDetectParam::_internal_mutable_signal_segmenation_param() {
  
  if (signal_segmenation_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::SignalSegmentationParam>(GetArena());
    signal_segmenation_param_ = p;
  }
  return signal_segmenation_param_;
}
inline ::zb::dcts::scenario::detection::SignalSegmentationParam* SignalDetectParam::mutable_signal_segmenation_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDetectParam.signal_segmenation_param)
  return _internal_mutable_signal_segmenation_param();
}
inline void SignalDetectParam::set_allocated_signal_segmenation_param(::zb::dcts::scenario::detection::SignalSegmentationParam* signal_segmenation_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete signal_segmenation_param_;
  }
  if (signal_segmenation_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(signal_segmenation_param);
    if (message_arena != submessage_arena) {
      signal_segmenation_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_segmenation_param, submessage_arena);
    }
    
  } else {
    
  }
  signal_segmenation_param_ = signal_segmenation_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDetectParam.signal_segmenation_param)
}

// .zb.dcts.scenario.detection.HopSignalDetectionParam hop_signal_detection_param = 3;
inline bool SignalDetectParam::_internal_has_hop_signal_detection_param() const {
  return this != internal_default_instance() && hop_signal_detection_param_ != nullptr;
}
inline bool SignalDetectParam::has_hop_signal_detection_param() const {
  return _internal_has_hop_signal_detection_param();
}
inline void SignalDetectParam::clear_hop_signal_detection_param() {
  if (GetArena() == nullptr && hop_signal_detection_param_ != nullptr) {
    delete hop_signal_detection_param_;
  }
  hop_signal_detection_param_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::HopSignalDetectionParam& SignalDetectParam::_internal_hop_signal_detection_param() const {
  const ::zb::dcts::scenario::detection::HopSignalDetectionParam* p = hop_signal_detection_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::HopSignalDetectionParam*>(
      &::zb::dcts::scenario::detection::_HopSignalDetectionParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::HopSignalDetectionParam& SignalDetectParam::hop_signal_detection_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDetectParam.hop_signal_detection_param)
  return _internal_hop_signal_detection_param();
}
inline void SignalDetectParam::unsafe_arena_set_allocated_hop_signal_detection_param(
    ::zb::dcts::scenario::detection::HopSignalDetectionParam* hop_signal_detection_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hop_signal_detection_param_);
  }
  hop_signal_detection_param_ = hop_signal_detection_param;
  if (hop_signal_detection_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDetectParam.hop_signal_detection_param)
}
inline ::zb::dcts::scenario::detection::HopSignalDetectionParam* SignalDetectParam::release_hop_signal_detection_param() {
  auto temp = unsafe_arena_release_hop_signal_detection_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::HopSignalDetectionParam* SignalDetectParam::unsafe_arena_release_hop_signal_detection_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDetectParam.hop_signal_detection_param)
  
  ::zb::dcts::scenario::detection::HopSignalDetectionParam* temp = hop_signal_detection_param_;
  hop_signal_detection_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::HopSignalDetectionParam* SignalDetectParam::_internal_mutable_hop_signal_detection_param() {
  
  if (hop_signal_detection_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::HopSignalDetectionParam>(GetArena());
    hop_signal_detection_param_ = p;
  }
  return hop_signal_detection_param_;
}
inline ::zb::dcts::scenario::detection::HopSignalDetectionParam* SignalDetectParam::mutable_hop_signal_detection_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDetectParam.hop_signal_detection_param)
  return _internal_mutable_hop_signal_detection_param();
}
inline void SignalDetectParam::set_allocated_hop_signal_detection_param(::zb::dcts::scenario::detection::HopSignalDetectionParam* hop_signal_detection_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hop_signal_detection_param_;
  }
  if (hop_signal_detection_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hop_signal_detection_param);
    if (message_arena != submessage_arena) {
      hop_signal_detection_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hop_signal_detection_param, submessage_arena);
    }
    
  } else {
    
  }
  hop_signal_detection_param_ = hop_signal_detection_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDetectParam.hop_signal_detection_param)
}

// -------------------------------------------------------------------

// DetectionParam

// int32 result_interval = 1;
inline void DetectionParam::clear_result_interval() {
  result_interval_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DetectionParam::_internal_result_interval() const {
  return result_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DetectionParam::result_interval() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.DetectionParam.result_interval)
  return _internal_result_interval();
}
inline void DetectionParam::_internal_set_result_interval(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  result_interval_ = value;
}
inline void DetectionParam::set_result_interval(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_result_interval(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.DetectionParam.result_interval)
}

// .zb.dcts.scenario.detection.EnergyDetectionParam energy_detect_param = 2;
inline bool DetectionParam::_internal_has_energy_detect_param() const {
  return this != internal_default_instance() && energy_detect_param_ != nullptr;
}
inline bool DetectionParam::has_energy_detect_param() const {
  return _internal_has_energy_detect_param();
}
inline void DetectionParam::clear_energy_detect_param() {
  if (GetArena() == nullptr && energy_detect_param_ != nullptr) {
    delete energy_detect_param_;
  }
  energy_detect_param_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::EnergyDetectionParam& DetectionParam::_internal_energy_detect_param() const {
  const ::zb::dcts::scenario::detection::EnergyDetectionParam* p = energy_detect_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::EnergyDetectionParam*>(
      &::zb::dcts::scenario::detection::_EnergyDetectionParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::EnergyDetectionParam& DetectionParam::energy_detect_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.DetectionParam.energy_detect_param)
  return _internal_energy_detect_param();
}
inline void DetectionParam::unsafe_arena_set_allocated_energy_detect_param(
    ::zb::dcts::scenario::detection::EnergyDetectionParam* energy_detect_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(energy_detect_param_);
  }
  energy_detect_param_ = energy_detect_param;
  if (energy_detect_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.DetectionParam.energy_detect_param)
}
inline ::zb::dcts::scenario::detection::EnergyDetectionParam* DetectionParam::release_energy_detect_param() {
  auto temp = unsafe_arena_release_energy_detect_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::EnergyDetectionParam* DetectionParam::unsafe_arena_release_energy_detect_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.DetectionParam.energy_detect_param)
  
  ::zb::dcts::scenario::detection::EnergyDetectionParam* temp = energy_detect_param_;
  energy_detect_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::EnergyDetectionParam* DetectionParam::_internal_mutable_energy_detect_param() {
  
  if (energy_detect_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::EnergyDetectionParam>(GetArena());
    energy_detect_param_ = p;
  }
  return energy_detect_param_;
}
inline ::zb::dcts::scenario::detection::EnergyDetectionParam* DetectionParam::mutable_energy_detect_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.DetectionParam.energy_detect_param)
  return _internal_mutable_energy_detect_param();
}
inline void DetectionParam::set_allocated_energy_detect_param(::zb::dcts::scenario::detection::EnergyDetectionParam* energy_detect_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete energy_detect_param_;
  }
  if (energy_detect_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(energy_detect_param);
    if (message_arena != submessage_arena) {
      energy_detect_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, energy_detect_param, submessage_arena);
    }
    
  } else {
    
  }
  energy_detect_param_ = energy_detect_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.DetectionParam.energy_detect_param)
}

// .zb.dcts.scenario.detection.SignalDetectParam signal_detect_param = 3;
inline bool DetectionParam::_internal_has_signal_detect_param() const {
  return this != internal_default_instance() && signal_detect_param_ != nullptr;
}
inline bool DetectionParam::has_signal_detect_param() const {
  return _internal_has_signal_detect_param();
}
inline void DetectionParam::clear_signal_detect_param() {
  if (GetArena() == nullptr && signal_detect_param_ != nullptr) {
    delete signal_detect_param_;
  }
  signal_detect_param_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::SignalDetectParam& DetectionParam::_internal_signal_detect_param() const {
  const ::zb::dcts::scenario::detection::SignalDetectParam* p = signal_detect_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::SignalDetectParam*>(
      &::zb::dcts::scenario::detection::_SignalDetectParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::SignalDetectParam& DetectionParam::signal_detect_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.DetectionParam.signal_detect_param)
  return _internal_signal_detect_param();
}
inline void DetectionParam::unsafe_arena_set_allocated_signal_detect_param(
    ::zb::dcts::scenario::detection::SignalDetectParam* signal_detect_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_detect_param_);
  }
  signal_detect_param_ = signal_detect_param;
  if (signal_detect_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.DetectionParam.signal_detect_param)
}
inline ::zb::dcts::scenario::detection::SignalDetectParam* DetectionParam::release_signal_detect_param() {
  auto temp = unsafe_arena_release_signal_detect_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::SignalDetectParam* DetectionParam::unsafe_arena_release_signal_detect_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.DetectionParam.signal_detect_param)
  
  ::zb::dcts::scenario::detection::SignalDetectParam* temp = signal_detect_param_;
  signal_detect_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::SignalDetectParam* DetectionParam::_internal_mutable_signal_detect_param() {
  
  if (signal_detect_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::SignalDetectParam>(GetArena());
    signal_detect_param_ = p;
  }
  return signal_detect_param_;
}
inline ::zb::dcts::scenario::detection::SignalDetectParam* DetectionParam::mutable_signal_detect_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.DetectionParam.signal_detect_param)
  return _internal_mutable_signal_detect_param();
}
inline void DetectionParam::set_allocated_signal_detect_param(::zb::dcts::scenario::detection::SignalDetectParam* signal_detect_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete signal_detect_param_;
  }
  if (signal_detect_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(signal_detect_param);
    if (message_arena != submessage_arena) {
      signal_detect_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_detect_param, submessage_arena);
    }
    
  } else {
    
  }
  signal_detect_param_ = signal_detect_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.DetectionParam.signal_detect_param)
}

// -------------------------------------------------------------------

// SignalFeature

// int32 sequence_number = 1;
inline void SignalFeature::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalFeature::_internal_sequence_number() const {
  return sequence_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalFeature::sequence_number() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalFeature.sequence_number)
  return _internal_sequence_number();
}
inline void SignalFeature::_internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sequence_number_ = value;
}
inline void SignalFeature::set_sequence_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalFeature.sequence_number)
}

// .zb.dcts.scenario.spectrum.SignalBand signal_band = 2;
inline bool SignalFeature::_internal_has_signal_band() const {
  return this != internal_default_instance() && signal_band_ != nullptr;
}
inline bool SignalFeature::has_signal_band() const {
  return _internal_has_signal_band();
}
inline const ::zb::dcts::scenario::spectrum::SignalBand& SignalFeature::_internal_signal_band() const {
  const ::zb::dcts::scenario::spectrum::SignalBand* p = signal_band_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::spectrum::SignalBand*>(
      &::zb::dcts::scenario::spectrum::_SignalBand_default_instance_);
}
inline const ::zb::dcts::scenario::spectrum::SignalBand& SignalFeature::signal_band() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalFeature.signal_band)
  return _internal_signal_band();
}
inline void SignalFeature::unsafe_arena_set_allocated_signal_band(
    ::zb::dcts::scenario::spectrum::SignalBand* signal_band) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_band_);
  }
  signal_band_ = signal_band;
  if (signal_band) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalFeature.signal_band)
}
inline ::zb::dcts::scenario::spectrum::SignalBand* SignalFeature::release_signal_band() {
  auto temp = unsafe_arena_release_signal_band();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::spectrum::SignalBand* SignalFeature::unsafe_arena_release_signal_band() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalFeature.signal_band)
  
  ::zb::dcts::scenario::spectrum::SignalBand* temp = signal_band_;
  signal_band_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::spectrum::SignalBand* SignalFeature::_internal_mutable_signal_band() {
  
  if (signal_band_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::spectrum::SignalBand>(GetArena());
    signal_band_ = p;
  }
  return signal_band_;
}
inline ::zb::dcts::scenario::spectrum::SignalBand* SignalFeature::mutable_signal_band() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalFeature.signal_band)
  return _internal_mutable_signal_band();
}
inline void SignalFeature::set_allocated_signal_band(::zb::dcts::scenario::spectrum::SignalBand* signal_band) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_band_);
  }
  if (signal_band) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_band)->GetArena();
    if (message_arena != submessage_arena) {
      signal_band = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_band, submessage_arena);
    }
    
  } else {
    
  }
  signal_band_ = signal_band;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalFeature.signal_band)
}

// .zb.dcts.StatisticVal amplitude = 4;
inline bool SignalFeature::_internal_has_amplitude() const {
  return this != internal_default_instance() && amplitude_ != nullptr;
}
inline bool SignalFeature::has_amplitude() const {
  return _internal_has_amplitude();
}
inline const ::zb::dcts::StatisticVal& SignalFeature::_internal_amplitude() const {
  const ::zb::dcts::StatisticVal* p = amplitude_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::StatisticVal*>(
      &::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& SignalFeature::amplitude() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalFeature.amplitude)
  return _internal_amplitude();
}
inline void SignalFeature::unsafe_arena_set_allocated_amplitude(
    ::zb::dcts::StatisticVal* amplitude) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude_);
  }
  amplitude_ = amplitude;
  if (amplitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalFeature.amplitude)
}
inline ::zb::dcts::StatisticVal* SignalFeature::release_amplitude() {
  auto temp = unsafe_arena_release_amplitude();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalFeature::unsafe_arena_release_amplitude() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalFeature.amplitude)
  
  ::zb::dcts::StatisticVal* temp = amplitude_;
  amplitude_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalFeature::_internal_mutable_amplitude() {
  
  if (amplitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    amplitude_ = p;
  }
  return amplitude_;
}
inline ::zb::dcts::StatisticVal* SignalFeature::mutable_amplitude() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalFeature.amplitude)
  return _internal_mutable_amplitude();
}
inline void SignalFeature::set_allocated_amplitude(::zb::dcts::StatisticVal* amplitude) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude_);
  }
  if (amplitude) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude)->GetArena();
    if (message_arena != submessage_arena) {
      amplitude = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amplitude, submessage_arena);
    }
    
  } else {
    
  }
  amplitude_ = amplitude;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalFeature.amplitude)
}

// .zb.dcts.StatisticVal hits = 5;
inline bool SignalFeature::_internal_has_hits() const {
  return this != internal_default_instance() && hits_ != nullptr;
}
inline bool SignalFeature::has_hits() const {
  return _internal_has_hits();
}
inline const ::zb::dcts::StatisticVal& SignalFeature::_internal_hits() const {
  const ::zb::dcts::StatisticVal* p = hits_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::StatisticVal*>(
      &::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& SignalFeature::hits() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalFeature.hits)
  return _internal_hits();
}
inline void SignalFeature::unsafe_arena_set_allocated_hits(
    ::zb::dcts::StatisticVal* hits) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hits_);
  }
  hits_ = hits;
  if (hits) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalFeature.hits)
}
inline ::zb::dcts::StatisticVal* SignalFeature::release_hits() {
  auto temp = unsafe_arena_release_hits();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalFeature::unsafe_arena_release_hits() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalFeature.hits)
  
  ::zb::dcts::StatisticVal* temp = hits_;
  hits_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalFeature::_internal_mutable_hits() {
  
  if (hits_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    hits_ = p;
  }
  return hits_;
}
inline ::zb::dcts::StatisticVal* SignalFeature::mutable_hits() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalFeature.hits)
  return _internal_mutable_hits();
}
inline void SignalFeature::set_allocated_hits(::zb::dcts::StatisticVal* hits) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hits_);
  }
  if (hits) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hits)->GetArena();
    if (message_arena != submessage_arena) {
      hits = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hits, submessage_arena);
    }
    
  } else {
    
  }
  hits_ = hits;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalFeature.hits)
}

// -------------------------------------------------------------------

// SignalDigest

// string id = 1;
inline void SignalDigest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SignalDigest::id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDigest.id)
  return _internal_id();
}
inline void SignalDigest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalDigest.id)
}
inline std::string* SignalDigest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDigest.id)
  return _internal_mutable_id();
}
inline const std::string& SignalDigest::_internal_id() const {
  return id_.Get();
}
inline void SignalDigest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignalDigest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.scenario.detection.SignalDigest.id)
}
inline void SignalDigest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.scenario.detection.SignalDigest.id)
}
inline void SignalDigest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.scenario.detection.SignalDigest.id)
}
inline std::string* SignalDigest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignalDigest::release_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDigest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignalDigest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDigest.id)
}
inline std::string* SignalDigest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.scenario.detection.SignalDigest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SignalDigest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDigest.id)
}

// .zb.dcts.scenario.detection.SignalActivity activity = 2;
inline void SignalDigest::clear_activity() {
  activity_ = 0;
}
inline ::zb::dcts::scenario::detection::SignalActivity SignalDigest::_internal_activity() const {
  return static_cast< ::zb::dcts::scenario::detection::SignalActivity >(activity_);
}
inline ::zb::dcts::scenario::detection::SignalActivity SignalDigest::activity() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDigest.activity)
  return _internal_activity();
}
inline void SignalDigest::_internal_set_activity(::zb::dcts::scenario::detection::SignalActivity value) {
  
  activity_ = value;
}
inline void SignalDigest::set_activity(::zb::dcts::scenario::detection::SignalActivity value) {
  _internal_set_activity(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalDigest.activity)
}

// .zb.dcts.StatisticVal center_freq = 3;
inline bool SignalDigest::_internal_has_center_freq() const {
  return this != internal_default_instance() && center_freq_ != nullptr;
}
inline bool SignalDigest::has_center_freq() const {
  return _internal_has_center_freq();
}
inline const ::zb::dcts::StatisticVal& SignalDigest::_internal_center_freq() const {
  const ::zb::dcts::StatisticVal* p = center_freq_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::StatisticVal*>(
      &::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& SignalDigest::center_freq() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDigest.center_freq)
  return _internal_center_freq();
}
inline void SignalDigest::unsafe_arena_set_allocated_center_freq(
    ::zb::dcts::StatisticVal* center_freq) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_freq_);
  }
  center_freq_ = center_freq;
  if (center_freq) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDigest.center_freq)
}
inline ::zb::dcts::StatisticVal* SignalDigest::release_center_freq() {
  auto temp = unsafe_arena_release_center_freq();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalDigest::unsafe_arena_release_center_freq() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDigest.center_freq)
  
  ::zb::dcts::StatisticVal* temp = center_freq_;
  center_freq_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalDigest::_internal_mutable_center_freq() {
  
  if (center_freq_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    center_freq_ = p;
  }
  return center_freq_;
}
inline ::zb::dcts::StatisticVal* SignalDigest::mutable_center_freq() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDigest.center_freq)
  return _internal_mutable_center_freq();
}
inline void SignalDigest::set_allocated_center_freq(::zb::dcts::StatisticVal* center_freq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_freq_);
  }
  if (center_freq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_freq)->GetArena();
    if (message_arena != submessage_arena) {
      center_freq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center_freq, submessage_arena);
    }
    
  } else {
    
  }
  center_freq_ = center_freq;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDigest.center_freq)
}

// .zb.dcts.StatisticVal band_width = 4;
inline bool SignalDigest::_internal_has_band_width() const {
  return this != internal_default_instance() && band_width_ != nullptr;
}
inline bool SignalDigest::has_band_width() const {
  return _internal_has_band_width();
}
inline const ::zb::dcts::StatisticVal& SignalDigest::_internal_band_width() const {
  const ::zb::dcts::StatisticVal* p = band_width_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::StatisticVal*>(
      &::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& SignalDigest::band_width() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDigest.band_width)
  return _internal_band_width();
}
inline void SignalDigest::unsafe_arena_set_allocated_band_width(
    ::zb::dcts::StatisticVal* band_width) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width_);
  }
  band_width_ = band_width;
  if (band_width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDigest.band_width)
}
inline ::zb::dcts::StatisticVal* SignalDigest::release_band_width() {
  auto temp = unsafe_arena_release_band_width();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalDigest::unsafe_arena_release_band_width() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDigest.band_width)
  
  ::zb::dcts::StatisticVal* temp = band_width_;
  band_width_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalDigest::_internal_mutable_band_width() {
  
  if (band_width_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    band_width_ = p;
  }
  return band_width_;
}
inline ::zb::dcts::StatisticVal* SignalDigest::mutable_band_width() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDigest.band_width)
  return _internal_mutable_band_width();
}
inline void SignalDigest::set_allocated_band_width(::zb::dcts::StatisticVal* band_width) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width_);
  }
  if (band_width) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width)->GetArena();
    if (message_arena != submessage_arena) {
      band_width = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, band_width, submessage_arena);
    }
    
  } else {
    
  }
  band_width_ = band_width;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDigest.band_width)
}

// .zb.dcts.StatisticVal amplitude = 5;
inline bool SignalDigest::_internal_has_amplitude() const {
  return this != internal_default_instance() && amplitude_ != nullptr;
}
inline bool SignalDigest::has_amplitude() const {
  return _internal_has_amplitude();
}
inline const ::zb::dcts::StatisticVal& SignalDigest::_internal_amplitude() const {
  const ::zb::dcts::StatisticVal* p = amplitude_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::StatisticVal*>(
      &::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& SignalDigest::amplitude() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDigest.amplitude)
  return _internal_amplitude();
}
inline void SignalDigest::unsafe_arena_set_allocated_amplitude(
    ::zb::dcts::StatisticVal* amplitude) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude_);
  }
  amplitude_ = amplitude;
  if (amplitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDigest.amplitude)
}
inline ::zb::dcts::StatisticVal* SignalDigest::release_amplitude() {
  auto temp = unsafe_arena_release_amplitude();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalDigest::unsafe_arena_release_amplitude() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDigest.amplitude)
  
  ::zb::dcts::StatisticVal* temp = amplitude_;
  amplitude_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalDigest::_internal_mutable_amplitude() {
  
  if (amplitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    amplitude_ = p;
  }
  return amplitude_;
}
inline ::zb::dcts::StatisticVal* SignalDigest::mutable_amplitude() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDigest.amplitude)
  return _internal_mutable_amplitude();
}
inline void SignalDigest::set_allocated_amplitude(::zb::dcts::StatisticVal* amplitude) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude_);
  }
  if (amplitude) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude)->GetArena();
    if (message_arena != submessage_arena) {
      amplitude = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amplitude, submessage_arena);
    }
    
  } else {
    
  }
  amplitude_ = amplitude;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDigest.amplitude)
}

// .zb.dcts.TimeSpan emit_time_span = 6;
inline bool SignalDigest::_internal_has_emit_time_span() const {
  return this != internal_default_instance() && emit_time_span_ != nullptr;
}
inline bool SignalDigest::has_emit_time_span() const {
  return _internal_has_emit_time_span();
}
inline const ::zb::dcts::TimeSpan& SignalDigest::_internal_emit_time_span() const {
  const ::zb::dcts::TimeSpan* p = emit_time_span_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::TimeSpan*>(
      &::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& SignalDigest::emit_time_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDigest.emit_time_span)
  return _internal_emit_time_span();
}
inline void SignalDigest::unsafe_arena_set_allocated_emit_time_span(
    ::zb::dcts::TimeSpan* emit_time_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(emit_time_span_);
  }
  emit_time_span_ = emit_time_span;
  if (emit_time_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDigest.emit_time_span)
}
inline ::zb::dcts::TimeSpan* SignalDigest::release_emit_time_span() {
  auto temp = unsafe_arena_release_emit_time_span();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* SignalDigest::unsafe_arena_release_emit_time_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDigest.emit_time_span)
  
  ::zb::dcts::TimeSpan* temp = emit_time_span_;
  emit_time_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* SignalDigest::_internal_mutable_emit_time_span() {
  
  if (emit_time_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    emit_time_span_ = p;
  }
  return emit_time_span_;
}
inline ::zb::dcts::TimeSpan* SignalDigest::mutable_emit_time_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDigest.emit_time_span)
  return _internal_mutable_emit_time_span();
}
inline void SignalDigest::set_allocated_emit_time_span(::zb::dcts::TimeSpan* emit_time_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(emit_time_span_);
  }
  if (emit_time_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(emit_time_span)->GetArena();
    if (message_arena != submessage_arena) {
      emit_time_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, emit_time_span, submessage_arena);
    }
    
  } else {
    
  }
  emit_time_span_ = emit_time_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDigest.emit_time_span)
}

// int32 num_features = 7;
inline void SignalDigest::clear_num_features() {
  num_features_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalDigest::_internal_num_features() const {
  return num_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalDigest::num_features() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDigest.num_features)
  return _internal_num_features();
}
inline void SignalDigest::_internal_set_num_features(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_features_ = value;
}
inline void SignalDigest::set_num_features(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_features(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalDigest.num_features)
}

// .zb.dcts.DOA dir_of_arrival = 9;
inline bool SignalDigest::_internal_has_dir_of_arrival() const {
  return this != internal_default_instance() && dir_of_arrival_ != nullptr;
}
inline bool SignalDigest::has_dir_of_arrival() const {
  return _internal_has_dir_of_arrival();
}
inline const ::zb::dcts::DOA& SignalDigest::_internal_dir_of_arrival() const {
  const ::zb::dcts::DOA* p = dir_of_arrival_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::DOA*>(
      &::zb::dcts::_DOA_default_instance_);
}
inline const ::zb::dcts::DOA& SignalDigest::dir_of_arrival() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDigest.dir_of_arrival)
  return _internal_dir_of_arrival();
}
inline void SignalDigest::unsafe_arena_set_allocated_dir_of_arrival(
    ::zb::dcts::DOA* dir_of_arrival) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dir_of_arrival_);
  }
  dir_of_arrival_ = dir_of_arrival;
  if (dir_of_arrival) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDigest.dir_of_arrival)
}
inline ::zb::dcts::DOA* SignalDigest::release_dir_of_arrival() {
  auto temp = unsafe_arena_release_dir_of_arrival();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::DOA* SignalDigest::unsafe_arena_release_dir_of_arrival() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDigest.dir_of_arrival)
  
  ::zb::dcts::DOA* temp = dir_of_arrival_;
  dir_of_arrival_ = nullptr;
  return temp;
}
inline ::zb::dcts::DOA* SignalDigest::_internal_mutable_dir_of_arrival() {
  
  if (dir_of_arrival_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::DOA>(GetArena());
    dir_of_arrival_ = p;
  }
  return dir_of_arrival_;
}
inline ::zb::dcts::DOA* SignalDigest::mutable_dir_of_arrival() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDigest.dir_of_arrival)
  return _internal_mutable_dir_of_arrival();
}
inline void SignalDigest::set_allocated_dir_of_arrival(::zb::dcts::DOA* dir_of_arrival) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dir_of_arrival_);
  }
  if (dir_of_arrival) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dir_of_arrival)->GetArena();
    if (message_arena != submessage_arena) {
      dir_of_arrival = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dir_of_arrival, submessage_arena);
    }
    
  } else {
    
  }
  dir_of_arrival_ = dir_of_arrival;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDigest.dir_of_arrival)
}

// string classification = 10;
inline void SignalDigest::clear_classification() {
  classification_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SignalDigest::classification() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDigest.classification)
  return _internal_classification();
}
inline void SignalDigest::set_classification(const std::string& value) {
  _internal_set_classification(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalDigest.classification)
}
inline std::string* SignalDigest::mutable_classification() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDigest.classification)
  return _internal_mutable_classification();
}
inline const std::string& SignalDigest::_internal_classification() const {
  return classification_.Get();
}
inline void SignalDigest::_internal_set_classification(const std::string& value) {
  
  classification_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignalDigest::set_classification(std::string&& value) {
  
  classification_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.scenario.detection.SignalDigest.classification)
}
inline void SignalDigest::set_classification(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  classification_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.scenario.detection.SignalDigest.classification)
}
inline void SignalDigest::set_classification(const char* value,
    size_t size) {
  
  classification_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.scenario.detection.SignalDigest.classification)
}
inline std::string* SignalDigest::_internal_mutable_classification() {
  
  return classification_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignalDigest::release_classification() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDigest.classification)
  return classification_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignalDigest::set_allocated_classification(std::string* classification) {
  if (classification != nullptr) {
    
  } else {
    
  }
  classification_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), classification,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDigest.classification)
}
inline std::string* SignalDigest::unsafe_arena_release_classification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.scenario.detection.SignalDigest.classification)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return classification_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SignalDigest::unsafe_arena_set_allocated_classification(
    std::string* classification) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (classification != nullptr) {
    
  } else {
    
  }
  classification_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      classification, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDigest.classification)
}

// string description = 11;
inline void SignalDigest::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SignalDigest::description() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalDigest.description)
  return _internal_description();
}
inline void SignalDigest::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalDigest.description)
}
inline std::string* SignalDigest::mutable_description() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalDigest.description)
  return _internal_mutable_description();
}
inline const std::string& SignalDigest::_internal_description() const {
  return description_.Get();
}
inline void SignalDigest::_internal_set_description(const std::string& value) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignalDigest::set_description(std::string&& value) {
  
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.scenario.detection.SignalDigest.description)
}
inline void SignalDigest::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.scenario.detection.SignalDigest.description)
}
inline void SignalDigest::set_description(const char* value,
    size_t size) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.scenario.detection.SignalDigest.description)
}
inline std::string* SignalDigest::_internal_mutable_description() {
  
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignalDigest::release_description() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalDigest.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignalDigest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalDigest.description)
}
inline std::string* SignalDigest::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.scenario.detection.SignalDigest.description)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return description_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SignalDigest::unsafe_arena_set_allocated_description(
    std::string* description) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (description != nullptr) {
    
  } else {
    
  }
  description_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      description, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalDigest.description)
}

// -------------------------------------------------------------------

// SignalSegment

// .zb.dcts.scenario.detection.SignalDigest digest = 1;
inline bool SignalSegment::_internal_has_digest() const {
  return this != internal_default_instance() && digest_ != nullptr;
}
inline bool SignalSegment::has_digest() const {
  return _internal_has_digest();
}
inline void SignalSegment::clear_digest() {
  if (GetArena() == nullptr && digest_ != nullptr) {
    delete digest_;
  }
  digest_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::SignalDigest& SignalSegment::_internal_digest() const {
  const ::zb::dcts::scenario::detection::SignalDigest* p = digest_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::SignalDigest*>(
      &::zb::dcts::scenario::detection::_SignalDigest_default_instance_);
}
inline const ::zb::dcts::scenario::detection::SignalDigest& SignalSegment::digest() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalSegment.digest)
  return _internal_digest();
}
inline void SignalSegment::unsafe_arena_set_allocated_digest(
    ::zb::dcts::scenario::detection::SignalDigest* digest) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(digest_);
  }
  digest_ = digest;
  if (digest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalSegment.digest)
}
inline ::zb::dcts::scenario::detection::SignalDigest* SignalSegment::release_digest() {
  auto temp = unsafe_arena_release_digest();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::SignalDigest* SignalSegment::unsafe_arena_release_digest() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalSegment.digest)
  
  ::zb::dcts::scenario::detection::SignalDigest* temp = digest_;
  digest_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::SignalDigest* SignalSegment::_internal_mutable_digest() {
  
  if (digest_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::SignalDigest>(GetArena());
    digest_ = p;
  }
  return digest_;
}
inline ::zb::dcts::scenario::detection::SignalDigest* SignalSegment::mutable_digest() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalSegment.digest)
  return _internal_mutable_digest();
}
inline void SignalSegment::set_allocated_digest(::zb::dcts::scenario::detection::SignalDigest* digest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete digest_;
  }
  if (digest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(digest);
    if (message_arena != submessage_arena) {
      digest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, digest, submessage_arena);
    }
    
  } else {
    
  }
  digest_ = digest;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalSegment.digest)
}

// repeated .zb.dcts.scenario.detection.SignalFeature feature_details = 2;
inline int SignalSegment::_internal_feature_details_size() const {
  return feature_details_.size();
}
inline int SignalSegment::feature_details_size() const {
  return _internal_feature_details_size();
}
inline void SignalSegment::clear_feature_details() {
  feature_details_.Clear();
}
inline ::zb::dcts::scenario::detection::SignalFeature* SignalSegment::mutable_feature_details(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalSegment.feature_details)
  return feature_details_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalFeature >*
SignalSegment::mutable_feature_details() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.SignalSegment.feature_details)
  return &feature_details_;
}
inline const ::zb::dcts::scenario::detection::SignalFeature& SignalSegment::_internal_feature_details(int index) const {
  return feature_details_.Get(index);
}
inline const ::zb::dcts::scenario::detection::SignalFeature& SignalSegment::feature_details(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalSegment.feature_details)
  return _internal_feature_details(index);
}
inline ::zb::dcts::scenario::detection::SignalFeature* SignalSegment::_internal_add_feature_details() {
  return feature_details_.Add();
}
inline ::zb::dcts::scenario::detection::SignalFeature* SignalSegment::add_feature_details() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.SignalSegment.feature_details)
  return _internal_add_feature_details();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalFeature >&
SignalSegment::feature_details() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.SignalSegment.feature_details)
  return feature_details_;
}

// -------------------------------------------------------------------

// HopSignalDigest

// .zb.dcts.StatisticVal center_freq = 1;
inline bool HopSignalDigest::_internal_has_center_freq() const {
  return this != internal_default_instance() && center_freq_ != nullptr;
}
inline bool HopSignalDigest::has_center_freq() const {
  return _internal_has_center_freq();
}
inline const ::zb::dcts::StatisticVal& HopSignalDigest::_internal_center_freq() const {
  const ::zb::dcts::StatisticVal* p = center_freq_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::StatisticVal*>(
      &::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& HopSignalDigest::center_freq() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalDigest.center_freq)
  return _internal_center_freq();
}
inline void HopSignalDigest::unsafe_arena_set_allocated_center_freq(
    ::zb::dcts::StatisticVal* center_freq) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_freq_);
  }
  center_freq_ = center_freq;
  if (center_freq) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.HopSignalDigest.center_freq)
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::release_center_freq() {
  auto temp = unsafe_arena_release_center_freq();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::unsafe_arena_release_center_freq() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.HopSignalDigest.center_freq)
  
  ::zb::dcts::StatisticVal* temp = center_freq_;
  center_freq_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::_internal_mutable_center_freq() {
  
  if (center_freq_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    center_freq_ = p;
  }
  return center_freq_;
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::mutable_center_freq() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalDigest.center_freq)
  return _internal_mutable_center_freq();
}
inline void HopSignalDigest::set_allocated_center_freq(::zb::dcts::StatisticVal* center_freq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_freq_);
  }
  if (center_freq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_freq)->GetArena();
    if (message_arena != submessage_arena) {
      center_freq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center_freq, submessage_arena);
    }
    
  } else {
    
  }
  center_freq_ = center_freq;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.HopSignalDigest.center_freq)
}

// .zb.dcts.StatisticVal band_width = 2;
inline bool HopSignalDigest::_internal_has_band_width() const {
  return this != internal_default_instance() && band_width_ != nullptr;
}
inline bool HopSignalDigest::has_band_width() const {
  return _internal_has_band_width();
}
inline const ::zb::dcts::StatisticVal& HopSignalDigest::_internal_band_width() const {
  const ::zb::dcts::StatisticVal* p = band_width_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::StatisticVal*>(
      &::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& HopSignalDigest::band_width() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalDigest.band_width)
  return _internal_band_width();
}
inline void HopSignalDigest::unsafe_arena_set_allocated_band_width(
    ::zb::dcts::StatisticVal* band_width) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width_);
  }
  band_width_ = band_width;
  if (band_width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.HopSignalDigest.band_width)
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::release_band_width() {
  auto temp = unsafe_arena_release_band_width();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::unsafe_arena_release_band_width() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.HopSignalDigest.band_width)
  
  ::zb::dcts::StatisticVal* temp = band_width_;
  band_width_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::_internal_mutable_band_width() {
  
  if (band_width_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    band_width_ = p;
  }
  return band_width_;
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::mutable_band_width() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalDigest.band_width)
  return _internal_mutable_band_width();
}
inline void HopSignalDigest::set_allocated_band_width(::zb::dcts::StatisticVal* band_width) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width_);
  }
  if (band_width) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width)->GetArena();
    if (message_arena != submessage_arena) {
      band_width = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, band_width, submessage_arena);
    }
    
  } else {
    
  }
  band_width_ = band_width;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.HopSignalDigest.band_width)
}

// .zb.dcts.StatisticVal amplitude = 3;
inline bool HopSignalDigest::_internal_has_amplitude() const {
  return this != internal_default_instance() && amplitude_ != nullptr;
}
inline bool HopSignalDigest::has_amplitude() const {
  return _internal_has_amplitude();
}
inline const ::zb::dcts::StatisticVal& HopSignalDigest::_internal_amplitude() const {
  const ::zb::dcts::StatisticVal* p = amplitude_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::StatisticVal*>(
      &::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& HopSignalDigest::amplitude() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalDigest.amplitude)
  return _internal_amplitude();
}
inline void HopSignalDigest::unsafe_arena_set_allocated_amplitude(
    ::zb::dcts::StatisticVal* amplitude) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude_);
  }
  amplitude_ = amplitude;
  if (amplitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.HopSignalDigest.amplitude)
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::release_amplitude() {
  auto temp = unsafe_arena_release_amplitude();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::unsafe_arena_release_amplitude() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.HopSignalDigest.amplitude)
  
  ::zb::dcts::StatisticVal* temp = amplitude_;
  amplitude_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::_internal_mutable_amplitude() {
  
  if (amplitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    amplitude_ = p;
  }
  return amplitude_;
}
inline ::zb::dcts::StatisticVal* HopSignalDigest::mutable_amplitude() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalDigest.amplitude)
  return _internal_mutable_amplitude();
}
inline void HopSignalDigest::set_allocated_amplitude(::zb::dcts::StatisticVal* amplitude) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude_);
  }
  if (amplitude) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude)->GetArena();
    if (message_arena != submessage_arena) {
      amplitude = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amplitude, submessage_arena);
    }
    
  } else {
    
  }
  amplitude_ = amplitude;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.HopSignalDigest.amplitude)
}

// int32 num_features = 5;
inline void HopSignalDigest::clear_num_features() {
  num_features_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HopSignalDigest::_internal_num_features() const {
  return num_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HopSignalDigest::num_features() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalDigest.num_features)
  return _internal_num_features();
}
inline void HopSignalDigest::_internal_set_num_features(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_features_ = value;
}
inline void HopSignalDigest::set_num_features(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_features(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.HopSignalDigest.num_features)
}

// -------------------------------------------------------------------

// HopSignalCluster

// string name = 1;
inline void HopSignalCluster::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HopSignalCluster::name() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalCluster.name)
  return _internal_name();
}
inline void HopSignalCluster::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.HopSignalCluster.name)
}
inline std::string* HopSignalCluster::mutable_name() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalCluster.name)
  return _internal_mutable_name();
}
inline const std::string& HopSignalCluster::_internal_name() const {
  return name_.Get();
}
inline void HopSignalCluster::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HopSignalCluster::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.scenario.detection.HopSignalCluster.name)
}
inline void HopSignalCluster::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.scenario.detection.HopSignalCluster.name)
}
inline void HopSignalCluster::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.scenario.detection.HopSignalCluster.name)
}
inline std::string* HopSignalCluster::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HopSignalCluster::release_name() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.HopSignalCluster.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HopSignalCluster::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.HopSignalCluster.name)
}
inline std::string* HopSignalCluster::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.scenario.detection.HopSignalCluster.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void HopSignalCluster::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.HopSignalCluster.name)
}

// .zb.dcts.scenario.detection.SignalActivity activity = 2;
inline void HopSignalCluster::clear_activity() {
  activity_ = 0;
}
inline ::zb::dcts::scenario::detection::SignalActivity HopSignalCluster::_internal_activity() const {
  return static_cast< ::zb::dcts::scenario::detection::SignalActivity >(activity_);
}
inline ::zb::dcts::scenario::detection::SignalActivity HopSignalCluster::activity() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalCluster.activity)
  return _internal_activity();
}
inline void HopSignalCluster::_internal_set_activity(::zb::dcts::scenario::detection::SignalActivity value) {
  
  activity_ = value;
}
inline void HopSignalCluster::set_activity(::zb::dcts::scenario::detection::SignalActivity value) {
  _internal_set_activity(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.HopSignalCluster.activity)
}

// .zb.dcts.TimeSpan emit_time_span = 3;
inline bool HopSignalCluster::_internal_has_emit_time_span() const {
  return this != internal_default_instance() && emit_time_span_ != nullptr;
}
inline bool HopSignalCluster::has_emit_time_span() const {
  return _internal_has_emit_time_span();
}
inline const ::zb::dcts::TimeSpan& HopSignalCluster::_internal_emit_time_span() const {
  const ::zb::dcts::TimeSpan* p = emit_time_span_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::TimeSpan*>(
      &::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& HopSignalCluster::emit_time_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalCluster.emit_time_span)
  return _internal_emit_time_span();
}
inline void HopSignalCluster::unsafe_arena_set_allocated_emit_time_span(
    ::zb::dcts::TimeSpan* emit_time_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(emit_time_span_);
  }
  emit_time_span_ = emit_time_span;
  if (emit_time_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.HopSignalCluster.emit_time_span)
}
inline ::zb::dcts::TimeSpan* HopSignalCluster::release_emit_time_span() {
  auto temp = unsafe_arena_release_emit_time_span();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* HopSignalCluster::unsafe_arena_release_emit_time_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.HopSignalCluster.emit_time_span)
  
  ::zb::dcts::TimeSpan* temp = emit_time_span_;
  emit_time_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* HopSignalCluster::_internal_mutable_emit_time_span() {
  
  if (emit_time_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    emit_time_span_ = p;
  }
  return emit_time_span_;
}
inline ::zb::dcts::TimeSpan* HopSignalCluster::mutable_emit_time_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalCluster.emit_time_span)
  return _internal_mutable_emit_time_span();
}
inline void HopSignalCluster::set_allocated_emit_time_span(::zb::dcts::TimeSpan* emit_time_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(emit_time_span_);
  }
  if (emit_time_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(emit_time_span)->GetArena();
    if (message_arena != submessage_arena) {
      emit_time_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, emit_time_span, submessage_arena);
    }
    
  } else {
    
  }
  emit_time_span_ = emit_time_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.HopSignalCluster.emit_time_span)
}

// repeated .zb.dcts.scenario.detection.HopSignalDigest freq_set = 4;
inline int HopSignalCluster::_internal_freq_set_size() const {
  return freq_set_.size();
}
inline int HopSignalCluster::freq_set_size() const {
  return _internal_freq_set_size();
}
inline void HopSignalCluster::clear_freq_set() {
  freq_set_.Clear();
}
inline ::zb::dcts::scenario::detection::HopSignalDigest* HopSignalCluster::mutable_freq_set(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalCluster.freq_set)
  return freq_set_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalDigest >*
HopSignalCluster::mutable_freq_set() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.HopSignalCluster.freq_set)
  return &freq_set_;
}
inline const ::zb::dcts::scenario::detection::HopSignalDigest& HopSignalCluster::_internal_freq_set(int index) const {
  return freq_set_.Get(index);
}
inline const ::zb::dcts::scenario::detection::HopSignalDigest& HopSignalCluster::freq_set(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalCluster.freq_set)
  return _internal_freq_set(index);
}
inline ::zb::dcts::scenario::detection::HopSignalDigest* HopSignalCluster::_internal_add_freq_set() {
  return freq_set_.Add();
}
inline ::zb::dcts::scenario::detection::HopSignalDigest* HopSignalCluster::add_freq_set() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.HopSignalCluster.freq_set)
  return _internal_add_freq_set();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalDigest >&
HopSignalCluster::freq_set() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.HopSignalCluster.freq_set)
  return freq_set_;
}

// -------------------------------------------------------------------

// FixSignalList

// repeated .zb.dcts.scenario.detection.SignalSegment fix_signals = 1;
inline int FixSignalList::_internal_fix_signals_size() const {
  return fix_signals_.size();
}
inline int FixSignalList::fix_signals_size() const {
  return _internal_fix_signals_size();
}
inline void FixSignalList::clear_fix_signals() {
  fix_signals_.Clear();
}
inline ::zb::dcts::scenario::detection::SignalSegment* FixSignalList::mutable_fix_signals(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.FixSignalList.fix_signals)
  return fix_signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalSegment >*
FixSignalList::mutable_fix_signals() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.FixSignalList.fix_signals)
  return &fix_signals_;
}
inline const ::zb::dcts::scenario::detection::SignalSegment& FixSignalList::_internal_fix_signals(int index) const {
  return fix_signals_.Get(index);
}
inline const ::zb::dcts::scenario::detection::SignalSegment& FixSignalList::fix_signals(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.FixSignalList.fix_signals)
  return _internal_fix_signals(index);
}
inline ::zb::dcts::scenario::detection::SignalSegment* FixSignalList::_internal_add_fix_signals() {
  return fix_signals_.Add();
}
inline ::zb::dcts::scenario::detection::SignalSegment* FixSignalList::add_fix_signals() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.FixSignalList.fix_signals)
  return _internal_add_fix_signals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalSegment >&
FixSignalList::fix_signals() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.FixSignalList.fix_signals)
  return fix_signals_;
}

// -------------------------------------------------------------------

// HopSignalList

// repeated .zb.dcts.scenario.detection.HopSignalCluster hop_signal_clusters = 1;
inline int HopSignalList::_internal_hop_signal_clusters_size() const {
  return hop_signal_clusters_.size();
}
inline int HopSignalList::hop_signal_clusters_size() const {
  return _internal_hop_signal_clusters_size();
}
inline void HopSignalList::clear_hop_signal_clusters() {
  hop_signal_clusters_.Clear();
}
inline ::zb::dcts::scenario::detection::HopSignalCluster* HopSignalList::mutable_hop_signal_clusters(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.HopSignalList.hop_signal_clusters)
  return hop_signal_clusters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >*
HopSignalList::mutable_hop_signal_clusters() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.HopSignalList.hop_signal_clusters)
  return &hop_signal_clusters_;
}
inline const ::zb::dcts::scenario::detection::HopSignalCluster& HopSignalList::_internal_hop_signal_clusters(int index) const {
  return hop_signal_clusters_.Get(index);
}
inline const ::zb::dcts::scenario::detection::HopSignalCluster& HopSignalList::hop_signal_clusters(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.HopSignalList.hop_signal_clusters)
  return _internal_hop_signal_clusters(index);
}
inline ::zb::dcts::scenario::detection::HopSignalCluster* HopSignalList::_internal_add_hop_signal_clusters() {
  return hop_signal_clusters_.Add();
}
inline ::zb::dcts::scenario::detection::HopSignalCluster* HopSignalList::add_hop_signal_clusters() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.HopSignalList.hop_signal_clusters)
  return _internal_add_hop_signal_clusters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >&
HopSignalList::hop_signal_clusters() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.HopSignalList.hop_signal_clusters)
  return hop_signal_clusters_;
}

// -------------------------------------------------------------------

// DetectionRequest

// .zb.dcts.scenario.ScenarioTaskId responser = 1;
inline bool DetectionRequest::_internal_has_responser() const {
  return this != internal_default_instance() && responser_ != nullptr;
}
inline bool DetectionRequest::has_responser() const {
  return _internal_has_responser();
}
inline const ::zb::dcts::scenario::ScenarioTaskId& DetectionRequest::_internal_responser() const {
  const ::zb::dcts::scenario::ScenarioTaskId* p = responser_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::ScenarioTaskId*>(
      &::zb::dcts::scenario::_ScenarioTaskId_default_instance_);
}
inline const ::zb::dcts::scenario::ScenarioTaskId& DetectionRequest::responser() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.DetectionRequest.responser)
  return _internal_responser();
}
inline void DetectionRequest::unsafe_arena_set_allocated_responser(
    ::zb::dcts::scenario::ScenarioTaskId* responser) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(responser_);
  }
  responser_ = responser;
  if (responser) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.DetectionRequest.responser)
}
inline ::zb::dcts::scenario::ScenarioTaskId* DetectionRequest::release_responser() {
  auto temp = unsafe_arena_release_responser();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::ScenarioTaskId* DetectionRequest::unsafe_arena_release_responser() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.DetectionRequest.responser)
  
  ::zb::dcts::scenario::ScenarioTaskId* temp = responser_;
  responser_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::ScenarioTaskId* DetectionRequest::_internal_mutable_responser() {
  
  if (responser_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::ScenarioTaskId>(GetArena());
    responser_ = p;
  }
  return responser_;
}
inline ::zb::dcts::scenario::ScenarioTaskId* DetectionRequest::mutable_responser() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.DetectionRequest.responser)
  return _internal_mutable_responser();
}
inline void DetectionRequest::set_allocated_responser(::zb::dcts::scenario::ScenarioTaskId* responser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(responser_);
  }
  if (responser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(responser)->GetArena();
    if (message_arena != submessage_arena) {
      responser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, responser, submessage_arena);
    }
    
  } else {
    
  }
  responser_ = responser;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.DetectionRequest.responser)
}

// .zb.dcts.scenario.detection.DetectionParam detection_param = 2;
inline bool DetectionRequest::_internal_has_detection_param() const {
  return this != internal_default_instance() && detection_param_ != nullptr;
}
inline bool DetectionRequest::has_detection_param() const {
  return _internal_has_detection_param();
}
inline void DetectionRequest::clear_detection_param() {
  if (GetArena() == nullptr && detection_param_ != nullptr) {
    delete detection_param_;
  }
  detection_param_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::DetectionParam& DetectionRequest::_internal_detection_param() const {
  const ::zb::dcts::scenario::detection::DetectionParam* p = detection_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::DetectionParam*>(
      &::zb::dcts::scenario::detection::_DetectionParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::DetectionParam& DetectionRequest::detection_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.DetectionRequest.detection_param)
  return _internal_detection_param();
}
inline void DetectionRequest::unsafe_arena_set_allocated_detection_param(
    ::zb::dcts::scenario::detection::DetectionParam* detection_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detection_param_);
  }
  detection_param_ = detection_param;
  if (detection_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.DetectionRequest.detection_param)
}
inline ::zb::dcts::scenario::detection::DetectionParam* DetectionRequest::release_detection_param() {
  auto temp = unsafe_arena_release_detection_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::DetectionParam* DetectionRequest::unsafe_arena_release_detection_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.DetectionRequest.detection_param)
  
  ::zb::dcts::scenario::detection::DetectionParam* temp = detection_param_;
  detection_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::DetectionParam* DetectionRequest::_internal_mutable_detection_param() {
  
  if (detection_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::DetectionParam>(GetArena());
    detection_param_ = p;
  }
  return detection_param_;
}
inline ::zb::dcts::scenario::detection::DetectionParam* DetectionRequest::mutable_detection_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.DetectionRequest.detection_param)
  return _internal_mutable_detection_param();
}
inline void DetectionRequest::set_allocated_detection_param(::zb::dcts::scenario::detection::DetectionParam* detection_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete detection_param_;
  }
  if (detection_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(detection_param);
    if (message_arena != submessage_arena) {
      detection_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detection_param, submessage_arena);
    }
    
  } else {
    
  }
  detection_param_ = detection_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.DetectionRequest.detection_param)
}

// -------------------------------------------------------------------

// AutoGatheringParam

// int32 time_span_in_msec = 1;
inline void AutoGatheringParam::clear_time_span_in_msec() {
  time_span_in_msec_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AutoGatheringParam::_internal_time_span_in_msec() const {
  return time_span_in_msec_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AutoGatheringParam::time_span_in_msec() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.AutoGatheringParam.time_span_in_msec)
  return _internal_time_span_in_msec();
}
inline void AutoGatheringParam::_internal_set_time_span_in_msec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  time_span_in_msec_ = value;
}
inline void AutoGatheringParam::set_time_span_in_msec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time_span_in_msec(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.AutoGatheringParam.time_span_in_msec)
}

// repeated string signal_candidates = 2;
inline int AutoGatheringParam::_internal_signal_candidates_size() const {
  return signal_candidates_.size();
}
inline int AutoGatheringParam::signal_candidates_size() const {
  return _internal_signal_candidates_size();
}
inline void AutoGatheringParam::clear_signal_candidates() {
  signal_candidates_.Clear();
}
inline std::string* AutoGatheringParam::add_signal_candidates() {
  // @@protoc_insertion_point(field_add_mutable:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
  return _internal_add_signal_candidates();
}
inline const std::string& AutoGatheringParam::_internal_signal_candidates(int index) const {
  return signal_candidates_.Get(index);
}
inline const std::string& AutoGatheringParam::signal_candidates(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
  return _internal_signal_candidates(index);
}
inline std::string* AutoGatheringParam::mutable_signal_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
  return signal_candidates_.Mutable(index);
}
inline void AutoGatheringParam::set_signal_candidates(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
  signal_candidates_.Mutable(index)->assign(value);
}
inline void AutoGatheringParam::set_signal_candidates(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
  signal_candidates_.Mutable(index)->assign(std::move(value));
}
inline void AutoGatheringParam::set_signal_candidates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signal_candidates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
}
inline void AutoGatheringParam::set_signal_candidates(int index, const char* value, size_t size) {
  signal_candidates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
}
inline std::string* AutoGatheringParam::_internal_add_signal_candidates() {
  return signal_candidates_.Add();
}
inline void AutoGatheringParam::add_signal_candidates(const std::string& value) {
  signal_candidates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
}
inline void AutoGatheringParam::add_signal_candidates(std::string&& value) {
  signal_candidates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
}
inline void AutoGatheringParam::add_signal_candidates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signal_candidates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
}
inline void AutoGatheringParam::add_signal_candidates(const char* value, size_t size) {
  signal_candidates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AutoGatheringParam::signal_candidates() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
  return signal_candidates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AutoGatheringParam::mutable_signal_candidates() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.AutoGatheringParam.signal_candidates)
  return &signal_candidates_;
}

// -------------------------------------------------------------------

// ManualGatheringParam

// string id = 1;
inline void ManualGatheringParam::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ManualGatheringParam::id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.ManualGatheringParam.id)
  return _internal_id();
}
inline void ManualGatheringParam::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.ManualGatheringParam.id)
}
inline std::string* ManualGatheringParam::mutable_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.ManualGatheringParam.id)
  return _internal_mutable_id();
}
inline const std::string& ManualGatheringParam::_internal_id() const {
  return id_.Get();
}
inline void ManualGatheringParam::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ManualGatheringParam::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.scenario.detection.ManualGatheringParam.id)
}
inline void ManualGatheringParam::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.scenario.detection.ManualGatheringParam.id)
}
inline void ManualGatheringParam::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.scenario.detection.ManualGatheringParam.id)
}
inline std::string* ManualGatheringParam::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ManualGatheringParam::release_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.ManualGatheringParam.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ManualGatheringParam::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.ManualGatheringParam.id)
}
inline std::string* ManualGatheringParam::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.scenario.detection.ManualGatheringParam.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ManualGatheringParam::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.ManualGatheringParam.id)
}

// int32 time_span_in_msec = 2;
inline void ManualGatheringParam::clear_time_span_in_msec() {
  time_span_in_msec_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ManualGatheringParam::_internal_time_span_in_msec() const {
  return time_span_in_msec_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ManualGatheringParam::time_span_in_msec() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.ManualGatheringParam.time_span_in_msec)
  return _internal_time_span_in_msec();
}
inline void ManualGatheringParam::_internal_set_time_span_in_msec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  time_span_in_msec_ = value;
}
inline void ManualGatheringParam::set_time_span_in_msec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time_span_in_msec(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.ManualGatheringParam.time_span_in_msec)
}

// .zb.dcts.scenario.spectrum.FrequencySpan freq_span = 3;
inline bool ManualGatheringParam::_internal_has_freq_span() const {
  return this != internal_default_instance() && freq_span_ != nullptr;
}
inline bool ManualGatheringParam::has_freq_span() const {
  return _internal_has_freq_span();
}
inline const ::zb::dcts::scenario::spectrum::FrequencySpan& ManualGatheringParam::_internal_freq_span() const {
  const ::zb::dcts::scenario::spectrum::FrequencySpan* p = freq_span_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::spectrum::FrequencySpan*>(
      &::zb::dcts::scenario::spectrum::_FrequencySpan_default_instance_);
}
inline const ::zb::dcts::scenario::spectrum::FrequencySpan& ManualGatheringParam::freq_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.ManualGatheringParam.freq_span)
  return _internal_freq_span();
}
inline void ManualGatheringParam::unsafe_arena_set_allocated_freq_span(
    ::zb::dcts::scenario::spectrum::FrequencySpan* freq_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_span_);
  }
  freq_span_ = freq_span;
  if (freq_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.ManualGatheringParam.freq_span)
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* ManualGatheringParam::release_freq_span() {
  auto temp = unsafe_arena_release_freq_span();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* ManualGatheringParam::unsafe_arena_release_freq_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.ManualGatheringParam.freq_span)
  
  ::zb::dcts::scenario::spectrum::FrequencySpan* temp = freq_span_;
  freq_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* ManualGatheringParam::_internal_mutable_freq_span() {
  
  if (freq_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::spectrum::FrequencySpan>(GetArena());
    freq_span_ = p;
  }
  return freq_span_;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* ManualGatheringParam::mutable_freq_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.ManualGatheringParam.freq_span)
  return _internal_mutable_freq_span();
}
inline void ManualGatheringParam::set_allocated_freq_span(::zb::dcts::scenario::spectrum::FrequencySpan* freq_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_span_);
  }
  if (freq_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_span)->GetArena();
    if (message_arena != submessage_arena) {
      freq_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, freq_span, submessage_arena);
    }
    
  } else {
    
  }
  freq_span_ = freq_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.ManualGatheringParam.freq_span)
}

// -------------------------------------------------------------------

// SignalGatheringRequest

// .zb.dcts.scenario.ScenarioTaskId responser = 1;
inline bool SignalGatheringRequest::_internal_has_responser() const {
  return this != internal_default_instance() && responser_ != nullptr;
}
inline bool SignalGatheringRequest::has_responser() const {
  return _internal_has_responser();
}
inline const ::zb::dcts::scenario::ScenarioTaskId& SignalGatheringRequest::_internal_responser() const {
  const ::zb::dcts::scenario::ScenarioTaskId* p = responser_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::ScenarioTaskId*>(
      &::zb::dcts::scenario::_ScenarioTaskId_default_instance_);
}
inline const ::zb::dcts::scenario::ScenarioTaskId& SignalGatheringRequest::responser() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalGatheringRequest.responser)
  return _internal_responser();
}
inline void SignalGatheringRequest::unsafe_arena_set_allocated_responser(
    ::zb::dcts::scenario::ScenarioTaskId* responser) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(responser_);
  }
  responser_ = responser;
  if (responser) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalGatheringRequest.responser)
}
inline ::zb::dcts::scenario::ScenarioTaskId* SignalGatheringRequest::release_responser() {
  auto temp = unsafe_arena_release_responser();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::ScenarioTaskId* SignalGatheringRequest::unsafe_arena_release_responser() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalGatheringRequest.responser)
  
  ::zb::dcts::scenario::ScenarioTaskId* temp = responser_;
  responser_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::ScenarioTaskId* SignalGatheringRequest::_internal_mutable_responser() {
  
  if (responser_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::ScenarioTaskId>(GetArena());
    responser_ = p;
  }
  return responser_;
}
inline ::zb::dcts::scenario::ScenarioTaskId* SignalGatheringRequest::mutable_responser() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalGatheringRequest.responser)
  return _internal_mutable_responser();
}
inline void SignalGatheringRequest::set_allocated_responser(::zb::dcts::scenario::ScenarioTaskId* responser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(responser_);
  }
  if (responser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(responser)->GetArena();
    if (message_arena != submessage_arena) {
      responser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, responser, submessage_arena);
    }
    
  } else {
    
  }
  responser_ = responser;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalGatheringRequest.responser)
}

// .zb.dcts.scenario.detection.AutoGatheringParam auto_gathering_param = 2;
inline bool SignalGatheringRequest::_internal_has_auto_gathering_param() const {
  return this != internal_default_instance() && auto_gathering_param_ != nullptr;
}
inline bool SignalGatheringRequest::has_auto_gathering_param() const {
  return _internal_has_auto_gathering_param();
}
inline void SignalGatheringRequest::clear_auto_gathering_param() {
  if (GetArena() == nullptr && auto_gathering_param_ != nullptr) {
    delete auto_gathering_param_;
  }
  auto_gathering_param_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::AutoGatheringParam& SignalGatheringRequest::_internal_auto_gathering_param() const {
  const ::zb::dcts::scenario::detection::AutoGatheringParam* p = auto_gathering_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::AutoGatheringParam*>(
      &::zb::dcts::scenario::detection::_AutoGatheringParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::AutoGatheringParam& SignalGatheringRequest::auto_gathering_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalGatheringRequest.auto_gathering_param)
  return _internal_auto_gathering_param();
}
inline void SignalGatheringRequest::unsafe_arena_set_allocated_auto_gathering_param(
    ::zb::dcts::scenario::detection::AutoGatheringParam* auto_gathering_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auto_gathering_param_);
  }
  auto_gathering_param_ = auto_gathering_param;
  if (auto_gathering_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalGatheringRequest.auto_gathering_param)
}
inline ::zb::dcts::scenario::detection::AutoGatheringParam* SignalGatheringRequest::release_auto_gathering_param() {
  auto temp = unsafe_arena_release_auto_gathering_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::AutoGatheringParam* SignalGatheringRequest::unsafe_arena_release_auto_gathering_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalGatheringRequest.auto_gathering_param)
  
  ::zb::dcts::scenario::detection::AutoGatheringParam* temp = auto_gathering_param_;
  auto_gathering_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::AutoGatheringParam* SignalGatheringRequest::_internal_mutable_auto_gathering_param() {
  
  if (auto_gathering_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::AutoGatheringParam>(GetArena());
    auto_gathering_param_ = p;
  }
  return auto_gathering_param_;
}
inline ::zb::dcts::scenario::detection::AutoGatheringParam* SignalGatheringRequest::mutable_auto_gathering_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalGatheringRequest.auto_gathering_param)
  return _internal_mutable_auto_gathering_param();
}
inline void SignalGatheringRequest::set_allocated_auto_gathering_param(::zb::dcts::scenario::detection::AutoGatheringParam* auto_gathering_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete auto_gathering_param_;
  }
  if (auto_gathering_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(auto_gathering_param);
    if (message_arena != submessage_arena) {
      auto_gathering_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_gathering_param, submessage_arena);
    }
    
  } else {
    
  }
  auto_gathering_param_ = auto_gathering_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalGatheringRequest.auto_gathering_param)
}

// .zb.dcts.scenario.detection.ManualGatheringParam manual_gathering_param = 3;
inline bool SignalGatheringRequest::_internal_has_manual_gathering_param() const {
  return this != internal_default_instance() && manual_gathering_param_ != nullptr;
}
inline bool SignalGatheringRequest::has_manual_gathering_param() const {
  return _internal_has_manual_gathering_param();
}
inline void SignalGatheringRequest::clear_manual_gathering_param() {
  if (GetArena() == nullptr && manual_gathering_param_ != nullptr) {
    delete manual_gathering_param_;
  }
  manual_gathering_param_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::ManualGatheringParam& SignalGatheringRequest::_internal_manual_gathering_param() const {
  const ::zb::dcts::scenario::detection::ManualGatheringParam* p = manual_gathering_param_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::ManualGatheringParam*>(
      &::zb::dcts::scenario::detection::_ManualGatheringParam_default_instance_);
}
inline const ::zb::dcts::scenario::detection::ManualGatheringParam& SignalGatheringRequest::manual_gathering_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalGatheringRequest.manual_gathering_param)
  return _internal_manual_gathering_param();
}
inline void SignalGatheringRequest::unsafe_arena_set_allocated_manual_gathering_param(
    ::zb::dcts::scenario::detection::ManualGatheringParam* manual_gathering_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(manual_gathering_param_);
  }
  manual_gathering_param_ = manual_gathering_param;
  if (manual_gathering_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalGatheringRequest.manual_gathering_param)
}
inline ::zb::dcts::scenario::detection::ManualGatheringParam* SignalGatheringRequest::release_manual_gathering_param() {
  auto temp = unsafe_arena_release_manual_gathering_param();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::ManualGatheringParam* SignalGatheringRequest::unsafe_arena_release_manual_gathering_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalGatheringRequest.manual_gathering_param)
  
  ::zb::dcts::scenario::detection::ManualGatheringParam* temp = manual_gathering_param_;
  manual_gathering_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::ManualGatheringParam* SignalGatheringRequest::_internal_mutable_manual_gathering_param() {
  
  if (manual_gathering_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::ManualGatheringParam>(GetArena());
    manual_gathering_param_ = p;
  }
  return manual_gathering_param_;
}
inline ::zb::dcts::scenario::detection::ManualGatheringParam* SignalGatheringRequest::mutable_manual_gathering_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalGatheringRequest.manual_gathering_param)
  return _internal_mutable_manual_gathering_param();
}
inline void SignalGatheringRequest::set_allocated_manual_gathering_param(::zb::dcts::scenario::detection::ManualGatheringParam* manual_gathering_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete manual_gathering_param_;
  }
  if (manual_gathering_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(manual_gathering_param);
    if (message_arena != submessage_arena) {
      manual_gathering_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, manual_gathering_param, submessage_arena);
    }
    
  } else {
    
  }
  manual_gathering_param_ = manual_gathering_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalGatheringRequest.manual_gathering_param)
}

// -------------------------------------------------------------------

// SignalSample

// string id = 1;
inline void SignalSample::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SignalSample::id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalSample.id)
  return _internal_id();
}
inline void SignalSample::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalSample.id)
}
inline std::string* SignalSample::mutable_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalSample.id)
  return _internal_mutable_id();
}
inline const std::string& SignalSample::_internal_id() const {
  return id_.Get();
}
inline void SignalSample::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignalSample::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.scenario.detection.SignalSample.id)
}
inline void SignalSample::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.scenario.detection.SignalSample.id)
}
inline void SignalSample::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.scenario.detection.SignalSample.id)
}
inline std::string* SignalSample::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignalSample::release_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalSample.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignalSample::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalSample.id)
}
inline std::string* SignalSample::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zb.dcts.scenario.detection.SignalSample.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SignalSample::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalSample.id)
}

// .zb.dcts.scenario.spectrum.SpectrumBlock sample_block = 2;
inline bool SignalSample::_internal_has_sample_block() const {
  return this != internal_default_instance() && sample_block_ != nullptr;
}
inline bool SignalSample::has_sample_block() const {
  return _internal_has_sample_block();
}
inline const ::zb::dcts::scenario::spectrum::SpectrumBlock& SignalSample::_internal_sample_block() const {
  const ::zb::dcts::scenario::spectrum::SpectrumBlock* p = sample_block_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::spectrum::SpectrumBlock*>(
      &::zb::dcts::scenario::spectrum::_SpectrumBlock_default_instance_);
}
inline const ::zb::dcts::scenario::spectrum::SpectrumBlock& SignalSample::sample_block() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalSample.sample_block)
  return _internal_sample_block();
}
inline void SignalSample::unsafe_arena_set_allocated_sample_block(
    ::zb::dcts::scenario::spectrum::SpectrumBlock* sample_block) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sample_block_);
  }
  sample_block_ = sample_block;
  if (sample_block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalSample.sample_block)
}
inline ::zb::dcts::scenario::spectrum::SpectrumBlock* SignalSample::release_sample_block() {
  auto temp = unsafe_arena_release_sample_block();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::spectrum::SpectrumBlock* SignalSample::unsafe_arena_release_sample_block() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalSample.sample_block)
  
  ::zb::dcts::scenario::spectrum::SpectrumBlock* temp = sample_block_;
  sample_block_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::spectrum::SpectrumBlock* SignalSample::_internal_mutable_sample_block() {
  
  if (sample_block_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::spectrum::SpectrumBlock>(GetArena());
    sample_block_ = p;
  }
  return sample_block_;
}
inline ::zb::dcts::scenario::spectrum::SpectrumBlock* SignalSample::mutable_sample_block() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalSample.sample_block)
  return _internal_mutable_sample_block();
}
inline void SignalSample::set_allocated_sample_block(::zb::dcts::scenario::spectrum::SpectrumBlock* sample_block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sample_block_);
  }
  if (sample_block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sample_block)->GetArena();
    if (message_arena != submessage_arena) {
      sample_block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sample_block, submessage_arena);
    }
    
  } else {
    
  }
  sample_block_ = sample_block;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalSample.sample_block)
}

// -------------------------------------------------------------------

// SignalSampleList

// repeated .zb.dcts.scenario.detection.SignalSample samples = 1;
inline int SignalSampleList::_internal_samples_size() const {
  return samples_.size();
}
inline int SignalSampleList::samples_size() const {
  return _internal_samples_size();
}
inline void SignalSampleList::clear_samples() {
  samples_.Clear();
}
inline ::zb::dcts::scenario::detection::SignalSample* SignalSampleList::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalSampleList.samples)
  return samples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalSample >*
SignalSampleList::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.SignalSampleList.samples)
  return &samples_;
}
inline const ::zb::dcts::scenario::detection::SignalSample& SignalSampleList::_internal_samples(int index) const {
  return samples_.Get(index);
}
inline const ::zb::dcts::scenario::detection::SignalSample& SignalSampleList::samples(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalSampleList.samples)
  return _internal_samples(index);
}
inline ::zb::dcts::scenario::detection::SignalSample* SignalSampleList::_internal_add_samples() {
  return samples_.Add();
}
inline ::zb::dcts::scenario::detection::SignalSample* SignalSampleList::add_samples() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.SignalSampleList.samples)
  return _internal_add_samples();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalSample >&
SignalSampleList::samples() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.SignalSampleList.samples)
  return samples_;
}

// -------------------------------------------------------------------

// SignalTableQueryRequest

// .zb.dcts.scenario.ScenarioTaskId responser = 1;
inline bool SignalTableQueryRequest::_internal_has_responser() const {
  return this != internal_default_instance() && responser_ != nullptr;
}
inline bool SignalTableQueryRequest::has_responser() const {
  return _internal_has_responser();
}
inline const ::zb::dcts::scenario::ScenarioTaskId& SignalTableQueryRequest::_internal_responser() const {
  const ::zb::dcts::scenario::ScenarioTaskId* p = responser_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::ScenarioTaskId*>(
      &::zb::dcts::scenario::_ScenarioTaskId_default_instance_);
}
inline const ::zb::dcts::scenario::ScenarioTaskId& SignalTableQueryRequest::responser() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryRequest.responser)
  return _internal_responser();
}
inline void SignalTableQueryRequest::unsafe_arena_set_allocated_responser(
    ::zb::dcts::scenario::ScenarioTaskId* responser) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(responser_);
  }
  responser_ = responser;
  if (responser) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalTableQueryRequest.responser)
}
inline ::zb::dcts::scenario::ScenarioTaskId* SignalTableQueryRequest::release_responser() {
  auto temp = unsafe_arena_release_responser();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::ScenarioTaskId* SignalTableQueryRequest::unsafe_arena_release_responser() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalTableQueryRequest.responser)
  
  ::zb::dcts::scenario::ScenarioTaskId* temp = responser_;
  responser_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::ScenarioTaskId* SignalTableQueryRequest::_internal_mutable_responser() {
  
  if (responser_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::ScenarioTaskId>(GetArena());
    responser_ = p;
  }
  return responser_;
}
inline ::zb::dcts::scenario::ScenarioTaskId* SignalTableQueryRequest::mutable_responser() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalTableQueryRequest.responser)
  return _internal_mutable_responser();
}
inline void SignalTableQueryRequest::set_allocated_responser(::zb::dcts::scenario::ScenarioTaskId* responser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(responser_);
  }
  if (responser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(responser)->GetArena();
    if (message_arena != submessage_arena) {
      responser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, responser, submessage_arena);
    }
    
  } else {
    
  }
  responser_ = responser;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalTableQueryRequest.responser)
}

// .zb.dcts.source.SourceId data_source = 2;
inline bool SignalTableQueryRequest::_internal_has_data_source() const {
  return this != internal_default_instance() && data_source_ != nullptr;
}
inline bool SignalTableQueryRequest::has_data_source() const {
  return _internal_has_data_source();
}
inline const ::zb::dcts::source::SourceId& SignalTableQueryRequest::_internal_data_source() const {
  const ::zb::dcts::source::SourceId* p = data_source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::SourceId*>(
      &::zb::dcts::source::_SourceId_default_instance_);
}
inline const ::zb::dcts::source::SourceId& SignalTableQueryRequest::data_source() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryRequest.data_source)
  return _internal_data_source();
}
inline void SignalTableQueryRequest::unsafe_arena_set_allocated_data_source(
    ::zb::dcts::source::SourceId* data_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_source_);
  }
  data_source_ = data_source;
  if (data_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalTableQueryRequest.data_source)
}
inline ::zb::dcts::source::SourceId* SignalTableQueryRequest::release_data_source() {
  auto temp = unsafe_arena_release_data_source();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::SourceId* SignalTableQueryRequest::unsafe_arena_release_data_source() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalTableQueryRequest.data_source)
  
  ::zb::dcts::source::SourceId* temp = data_source_;
  data_source_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::SourceId* SignalTableQueryRequest::_internal_mutable_data_source() {
  
  if (data_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::SourceId>(GetArena());
    data_source_ = p;
  }
  return data_source_;
}
inline ::zb::dcts::source::SourceId* SignalTableQueryRequest::mutable_data_source() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalTableQueryRequest.data_source)
  return _internal_mutable_data_source();
}
inline void SignalTableQueryRequest::set_allocated_data_source(::zb::dcts::source::SourceId* data_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_source_);
  }
  if (data_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_source)->GetArena();
    if (message_arena != submessage_arena) {
      data_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_source, submessage_arena);
    }
    
  } else {
    
  }
  data_source_ = data_source;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalTableQueryRequest.data_source)
}

// .zb.dcts.Integer activiy_mask = 3;
inline bool SignalTableQueryRequest::_internal_has_activiy_mask() const {
  return this != internal_default_instance() && activiy_mask_ != nullptr;
}
inline bool SignalTableQueryRequest::has_activiy_mask() const {
  return _internal_has_activiy_mask();
}
inline const ::zb::dcts::Integer& SignalTableQueryRequest::_internal_activiy_mask() const {
  const ::zb::dcts::Integer* p = activiy_mask_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Integer*>(
      &::zb::dcts::_Integer_default_instance_);
}
inline const ::zb::dcts::Integer& SignalTableQueryRequest::activiy_mask() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryRequest.activiy_mask)
  return _internal_activiy_mask();
}
inline void SignalTableQueryRequest::unsafe_arena_set_allocated_activiy_mask(
    ::zb::dcts::Integer* activiy_mask) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(activiy_mask_);
  }
  activiy_mask_ = activiy_mask;
  if (activiy_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalTableQueryRequest.activiy_mask)
}
inline ::zb::dcts::Integer* SignalTableQueryRequest::release_activiy_mask() {
  auto temp = unsafe_arena_release_activiy_mask();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Integer* SignalTableQueryRequest::unsafe_arena_release_activiy_mask() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalTableQueryRequest.activiy_mask)
  
  ::zb::dcts::Integer* temp = activiy_mask_;
  activiy_mask_ = nullptr;
  return temp;
}
inline ::zb::dcts::Integer* SignalTableQueryRequest::_internal_mutable_activiy_mask() {
  
  if (activiy_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Integer>(GetArena());
    activiy_mask_ = p;
  }
  return activiy_mask_;
}
inline ::zb::dcts::Integer* SignalTableQueryRequest::mutable_activiy_mask() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalTableQueryRequest.activiy_mask)
  return _internal_mutable_activiy_mask();
}
inline void SignalTableQueryRequest::set_allocated_activiy_mask(::zb::dcts::Integer* activiy_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(activiy_mask_);
  }
  if (activiy_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(activiy_mask)->GetArena();
    if (message_arena != submessage_arena) {
      activiy_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activiy_mask, submessage_arena);
    }
    
  } else {
    
  }
  activiy_mask_ = activiy_mask;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalTableQueryRequest.activiy_mask)
}

// .zb.dcts.scenario.spectrum.FrequencySpan freq_range = 4;
inline bool SignalTableQueryRequest::_internal_has_freq_range() const {
  return this != internal_default_instance() && freq_range_ != nullptr;
}
inline bool SignalTableQueryRequest::has_freq_range() const {
  return _internal_has_freq_range();
}
inline const ::zb::dcts::scenario::spectrum::FrequencySpan& SignalTableQueryRequest::_internal_freq_range() const {
  const ::zb::dcts::scenario::spectrum::FrequencySpan* p = freq_range_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::spectrum::FrequencySpan*>(
      &::zb::dcts::scenario::spectrum::_FrequencySpan_default_instance_);
}
inline const ::zb::dcts::scenario::spectrum::FrequencySpan& SignalTableQueryRequest::freq_range() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryRequest.freq_range)
  return _internal_freq_range();
}
inline void SignalTableQueryRequest::unsafe_arena_set_allocated_freq_range(
    ::zb::dcts::scenario::spectrum::FrequencySpan* freq_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_range_);
  }
  freq_range_ = freq_range;
  if (freq_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalTableQueryRequest.freq_range)
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* SignalTableQueryRequest::release_freq_range() {
  auto temp = unsafe_arena_release_freq_range();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* SignalTableQueryRequest::unsafe_arena_release_freq_range() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalTableQueryRequest.freq_range)
  
  ::zb::dcts::scenario::spectrum::FrequencySpan* temp = freq_range_;
  freq_range_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* SignalTableQueryRequest::_internal_mutable_freq_range() {
  
  if (freq_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::spectrum::FrequencySpan>(GetArena());
    freq_range_ = p;
  }
  return freq_range_;
}
inline ::zb::dcts::scenario::spectrum::FrequencySpan* SignalTableQueryRequest::mutable_freq_range() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalTableQueryRequest.freq_range)
  return _internal_mutable_freq_range();
}
inline void SignalTableQueryRequest::set_allocated_freq_range(::zb::dcts::scenario::spectrum::FrequencySpan* freq_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_range_);
  }
  if (freq_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_range)->GetArena();
    if (message_arena != submessage_arena) {
      freq_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, freq_range, submessage_arena);
    }
    
  } else {
    
  }
  freq_range_ = freq_range;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalTableQueryRequest.freq_range)
}

// .zb.dcts.TimeSpan time_range = 5;
inline bool SignalTableQueryRequest::_internal_has_time_range() const {
  return this != internal_default_instance() && time_range_ != nullptr;
}
inline bool SignalTableQueryRequest::has_time_range() const {
  return _internal_has_time_range();
}
inline const ::zb::dcts::TimeSpan& SignalTableQueryRequest::_internal_time_range() const {
  const ::zb::dcts::TimeSpan* p = time_range_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::TimeSpan*>(
      &::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& SignalTableQueryRequest::time_range() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryRequest.time_range)
  return _internal_time_range();
}
inline void SignalTableQueryRequest::unsafe_arena_set_allocated_time_range(
    ::zb::dcts::TimeSpan* time_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range_);
  }
  time_range_ = time_range;
  if (time_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalTableQueryRequest.time_range)
}
inline ::zb::dcts::TimeSpan* SignalTableQueryRequest::release_time_range() {
  auto temp = unsafe_arena_release_time_range();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* SignalTableQueryRequest::unsafe_arena_release_time_range() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalTableQueryRequest.time_range)
  
  ::zb::dcts::TimeSpan* temp = time_range_;
  time_range_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* SignalTableQueryRequest::_internal_mutable_time_range() {
  
  if (time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    time_range_ = p;
  }
  return time_range_;
}
inline ::zb::dcts::TimeSpan* SignalTableQueryRequest::mutable_time_range() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalTableQueryRequest.time_range)
  return _internal_mutable_time_range();
}
inline void SignalTableQueryRequest::set_allocated_time_range(::zb::dcts::TimeSpan* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range)->GetArena();
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    
  } else {
    
  }
  time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalTableQueryRequest.time_range)
}

// -------------------------------------------------------------------

// SignalTableQueryResponse

// .zb.dcts.source.SourceId data_source = 1;
inline bool SignalTableQueryResponse::_internal_has_data_source() const {
  return this != internal_default_instance() && data_source_ != nullptr;
}
inline bool SignalTableQueryResponse::has_data_source() const {
  return _internal_has_data_source();
}
inline const ::zb::dcts::source::SourceId& SignalTableQueryResponse::_internal_data_source() const {
  const ::zb::dcts::source::SourceId* p = data_source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::SourceId*>(
      &::zb::dcts::source::_SourceId_default_instance_);
}
inline const ::zb::dcts::source::SourceId& SignalTableQueryResponse::data_source() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryResponse.data_source)
  return _internal_data_source();
}
inline void SignalTableQueryResponse::unsafe_arena_set_allocated_data_source(
    ::zb::dcts::source::SourceId* data_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_source_);
  }
  data_source_ = data_source;
  if (data_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalTableQueryResponse.data_source)
}
inline ::zb::dcts::source::SourceId* SignalTableQueryResponse::release_data_source() {
  auto temp = unsafe_arena_release_data_source();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::SourceId* SignalTableQueryResponse::unsafe_arena_release_data_source() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalTableQueryResponse.data_source)
  
  ::zb::dcts::source::SourceId* temp = data_source_;
  data_source_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::SourceId* SignalTableQueryResponse::_internal_mutable_data_source() {
  
  if (data_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::SourceId>(GetArena());
    data_source_ = p;
  }
  return data_source_;
}
inline ::zb::dcts::source::SourceId* SignalTableQueryResponse::mutable_data_source() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalTableQueryResponse.data_source)
  return _internal_mutable_data_source();
}
inline void SignalTableQueryResponse::set_allocated_data_source(::zb::dcts::source::SourceId* data_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_source_);
  }
  if (data_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_source)->GetArena();
    if (message_arena != submessage_arena) {
      data_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_source, submessage_arena);
    }
    
  } else {
    
  }
  data_source_ = data_source;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalTableQueryResponse.data_source)
}

// int32 num_sweeps = 2;
inline void SignalTableQueryResponse::clear_num_sweeps() {
  num_sweeps_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalTableQueryResponse::_internal_num_sweeps() const {
  return num_sweeps_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalTableQueryResponse::num_sweeps() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryResponse.num_sweeps)
  return _internal_num_sweeps();
}
inline void SignalTableQueryResponse::_internal_set_num_sweeps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_sweeps_ = value;
}
inline void SignalTableQueryResponse::set_num_sweeps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_sweeps(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalTableQueryResponse.num_sweeps)
}

// int32 num_detects = 3;
inline void SignalTableQueryResponse::clear_num_detects() {
  num_detects_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalTableQueryResponse::_internal_num_detects() const {
  return num_detects_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalTableQueryResponse::num_detects() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryResponse.num_detects)
  return _internal_num_detects();
}
inline void SignalTableQueryResponse::_internal_set_num_detects(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_detects_ = value;
}
inline void SignalTableQueryResponse::set_num_detects(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_detects(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalTableQueryResponse.num_detects)
}

// int32 num_total_signals = 4;
inline void SignalTableQueryResponse::clear_num_total_signals() {
  num_total_signals_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalTableQueryResponse::_internal_num_total_signals() const {
  return num_total_signals_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalTableQueryResponse::num_total_signals() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryResponse.num_total_signals)
  return _internal_num_total_signals();
}
inline void SignalTableQueryResponse::_internal_set_num_total_signals(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_total_signals_ = value;
}
inline void SignalTableQueryResponse::set_num_total_signals(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_total_signals(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalTableQueryResponse.num_total_signals)
}

// int32 num_query_signals = 5;
inline void SignalTableQueryResponse::clear_num_query_signals() {
  num_query_signals_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalTableQueryResponse::_internal_num_query_signals() const {
  return num_query_signals_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalTableQueryResponse::num_query_signals() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryResponse.num_query_signals)
  return _internal_num_query_signals();
}
inline void SignalTableQueryResponse::_internal_set_num_query_signals(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_query_signals_ = value;
}
inline void SignalTableQueryResponse::set_num_query_signals(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_query_signals(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.SignalTableQueryResponse.num_query_signals)
}

// repeated .zb.dcts.scenario.detection.SignalDigest fix_signal_list = 7;
inline int SignalTableQueryResponse::_internal_fix_signal_list_size() const {
  return fix_signal_list_.size();
}
inline int SignalTableQueryResponse::fix_signal_list_size() const {
  return _internal_fix_signal_list_size();
}
inline void SignalTableQueryResponse::clear_fix_signal_list() {
  fix_signal_list_.Clear();
}
inline ::zb::dcts::scenario::detection::SignalDigest* SignalTableQueryResponse::mutable_fix_signal_list(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalTableQueryResponse.fix_signal_list)
  return fix_signal_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalDigest >*
SignalTableQueryResponse::mutable_fix_signal_list() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.SignalTableQueryResponse.fix_signal_list)
  return &fix_signal_list_;
}
inline const ::zb::dcts::scenario::detection::SignalDigest& SignalTableQueryResponse::_internal_fix_signal_list(int index) const {
  return fix_signal_list_.Get(index);
}
inline const ::zb::dcts::scenario::detection::SignalDigest& SignalTableQueryResponse::fix_signal_list(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryResponse.fix_signal_list)
  return _internal_fix_signal_list(index);
}
inline ::zb::dcts::scenario::detection::SignalDigest* SignalTableQueryResponse::_internal_add_fix_signal_list() {
  return fix_signal_list_.Add();
}
inline ::zb::dcts::scenario::detection::SignalDigest* SignalTableQueryResponse::add_fix_signal_list() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.SignalTableQueryResponse.fix_signal_list)
  return _internal_add_fix_signal_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalDigest >&
SignalTableQueryResponse::fix_signal_list() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.SignalTableQueryResponse.fix_signal_list)
  return fix_signal_list_;
}

// repeated .zb.dcts.scenario.detection.HopSignalCluster hop_signal_list = 8;
inline int SignalTableQueryResponse::_internal_hop_signal_list_size() const {
  return hop_signal_list_.size();
}
inline int SignalTableQueryResponse::hop_signal_list_size() const {
  return _internal_hop_signal_list_size();
}
inline void SignalTableQueryResponse::clear_hop_signal_list() {
  hop_signal_list_.Clear();
}
inline ::zb::dcts::scenario::detection::HopSignalCluster* SignalTableQueryResponse::mutable_hop_signal_list(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalTableQueryResponse.hop_signal_list)
  return hop_signal_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >*
SignalTableQueryResponse::mutable_hop_signal_list() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.SignalTableQueryResponse.hop_signal_list)
  return &hop_signal_list_;
}
inline const ::zb::dcts::scenario::detection::HopSignalCluster& SignalTableQueryResponse::_internal_hop_signal_list(int index) const {
  return hop_signal_list_.Get(index);
}
inline const ::zb::dcts::scenario::detection::HopSignalCluster& SignalTableQueryResponse::hop_signal_list(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalTableQueryResponse.hop_signal_list)
  return _internal_hop_signal_list(index);
}
inline ::zb::dcts::scenario::detection::HopSignalCluster* SignalTableQueryResponse::_internal_add_hop_signal_list() {
  return hop_signal_list_.Add();
}
inline ::zb::dcts::scenario::detection::HopSignalCluster* SignalTableQueryResponse::add_hop_signal_list() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.SignalTableQueryResponse.hop_signal_list)
  return _internal_add_hop_signal_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >&
SignalTableQueryResponse::hop_signal_list() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.SignalTableQueryResponse.hop_signal_list)
  return hop_signal_list_;
}

// -------------------------------------------------------------------

// Header

// .zb.dcts.source.SourceId result_from = 1;
inline bool Header::_internal_has_result_from() const {
  return this != internal_default_instance() && result_from_ != nullptr;
}
inline bool Header::has_result_from() const {
  return _internal_has_result_from();
}
inline const ::zb::dcts::source::SourceId& Header::_internal_result_from() const {
  const ::zb::dcts::source::SourceId* p = result_from_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::SourceId*>(
      &::zb::dcts::source::_SourceId_default_instance_);
}
inline const ::zb::dcts::source::SourceId& Header::result_from() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.Header.result_from)
  return _internal_result_from();
}
inline void Header::unsafe_arena_set_allocated_result_from(
    ::zb::dcts::source::SourceId* result_from) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_from_);
  }
  result_from_ = result_from;
  if (result_from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.Header.result_from)
}
inline ::zb::dcts::source::SourceId* Header::release_result_from() {
  auto temp = unsafe_arena_release_result_from();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::SourceId* Header::unsafe_arena_release_result_from() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.Header.result_from)
  
  ::zb::dcts::source::SourceId* temp = result_from_;
  result_from_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::SourceId* Header::_internal_mutable_result_from() {
  
  if (result_from_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::SourceId>(GetArena());
    result_from_ = p;
  }
  return result_from_;
}
inline ::zb::dcts::source::SourceId* Header::mutable_result_from() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.Header.result_from)
  return _internal_mutable_result_from();
}
inline void Header::set_allocated_result_from(::zb::dcts::source::SourceId* result_from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_from_);
  }
  if (result_from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_from)->GetArena();
    if (message_arena != submessage_arena) {
      result_from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_from, submessage_arena);
    }
    
  } else {
    
  }
  result_from_ = result_from;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.Header.result_from)
}

// uint32 sequence_number = 3;
inline void Header::clear_sequence_number() {
  sequence_number_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::_internal_sequence_number() const {
  return sequence_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::sequence_number() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.Header.sequence_number)
  return _internal_sequence_number();
}
inline void Header::_internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sequence_number_ = value;
}
inline void Header::set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.Header.sequence_number)
}

// uint32 sweep_count = 4;
inline void Header::clear_sweep_count() {
  sweep_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::_internal_sweep_count() const {
  return sweep_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::sweep_count() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.Header.sweep_count)
  return _internal_sweep_count();
}
inline void Header::_internal_set_sweep_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sweep_count_ = value;
}
inline void Header::set_sweep_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sweep_count(value);
  // @@protoc_insertion_point(field_set:zb.dcts.scenario.detection.Header.sweep_count)
}

// .zb.dcts.TimeSpan time_span = 5;
inline bool Header::_internal_has_time_span() const {
  return this != internal_default_instance() && time_span_ != nullptr;
}
inline bool Header::has_time_span() const {
  return _internal_has_time_span();
}
inline const ::zb::dcts::TimeSpan& Header::_internal_time_span() const {
  const ::zb::dcts::TimeSpan* p = time_span_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::TimeSpan*>(
      &::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& Header::time_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.Header.time_span)
  return _internal_time_span();
}
inline void Header::unsafe_arena_set_allocated_time_span(
    ::zb::dcts::TimeSpan* time_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  time_span_ = time_span;
  if (time_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.Header.time_span)
}
inline ::zb::dcts::TimeSpan* Header::release_time_span() {
  auto temp = unsafe_arena_release_time_span();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* Header::unsafe_arena_release_time_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.Header.time_span)
  
  ::zb::dcts::TimeSpan* temp = time_span_;
  time_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* Header::_internal_mutable_time_span() {
  
  if (time_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    time_span_ = p;
  }
  return time_span_;
}
inline ::zb::dcts::TimeSpan* Header::mutable_time_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.Header.time_span)
  return _internal_mutable_time_span();
}
inline void Header::set_allocated_time_span(::zb::dcts::TimeSpan* time_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  if (time_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span)->GetArena();
    if (message_arena != submessage_arena) {
      time_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_span, submessage_arena);
    }
    
  } else {
    
  }
  time_span_ = time_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.Header.time_span)
}

// .zb.dcts.Position device_position = 6;
inline bool Header::_internal_has_device_position() const {
  return this != internal_default_instance() && device_position_ != nullptr;
}
inline bool Header::has_device_position() const {
  return _internal_has_device_position();
}
inline const ::zb::dcts::Position& Header::_internal_device_position() const {
  const ::zb::dcts::Position* p = device_position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Position*>(
      &::zb::dcts::_Position_default_instance_);
}
inline const ::zb::dcts::Position& Header::device_position() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.Header.device_position)
  return _internal_device_position();
}
inline void Header::unsafe_arena_set_allocated_device_position(
    ::zb::dcts::Position* device_position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_position_);
  }
  device_position_ = device_position;
  if (device_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.Header.device_position)
}
inline ::zb::dcts::Position* Header::release_device_position() {
  auto temp = unsafe_arena_release_device_position();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Position* Header::unsafe_arena_release_device_position() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.Header.device_position)
  
  ::zb::dcts::Position* temp = device_position_;
  device_position_ = nullptr;
  return temp;
}
inline ::zb::dcts::Position* Header::_internal_mutable_device_position() {
  
  if (device_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Position>(GetArena());
    device_position_ = p;
  }
  return device_position_;
}
inline ::zb::dcts::Position* Header::mutable_device_position() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.Header.device_position)
  return _internal_mutable_device_position();
}
inline void Header::set_allocated_device_position(::zb::dcts::Position* device_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_position_);
  }
  if (device_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_position)->GetArena();
    if (message_arena != submessage_arena) {
      device_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_position, submessage_arena);
    }
    
  } else {
    
  }
  device_position_ = device_position;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.Header.device_position)
}

// -------------------------------------------------------------------

// RawBody

// .zb.dcts.scenario.spectrum.FrequencySegment freq_seg = 1;
inline bool RawBody::_internal_has_freq_seg() const {
  return this != internal_default_instance() && freq_seg_ != nullptr;
}
inline bool RawBody::has_freq_seg() const {
  return _internal_has_freq_seg();
}
inline const ::zb::dcts::scenario::spectrum::FrequencySegment& RawBody::_internal_freq_seg() const {
  const ::zb::dcts::scenario::spectrum::FrequencySegment* p = freq_seg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::spectrum::FrequencySegment*>(
      &::zb::dcts::scenario::spectrum::_FrequencySegment_default_instance_);
}
inline const ::zb::dcts::scenario::spectrum::FrequencySegment& RawBody::freq_seg() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.RawBody.freq_seg)
  return _internal_freq_seg();
}
inline void RawBody::unsafe_arena_set_allocated_freq_seg(
    ::zb::dcts::scenario::spectrum::FrequencySegment* freq_seg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_seg_);
  }
  freq_seg_ = freq_seg;
  if (freq_seg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.RawBody.freq_seg)
}
inline ::zb::dcts::scenario::spectrum::FrequencySegment* RawBody::release_freq_seg() {
  auto temp = unsafe_arena_release_freq_seg();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::spectrum::FrequencySegment* RawBody::unsafe_arena_release_freq_seg() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.RawBody.freq_seg)
  
  ::zb::dcts::scenario::spectrum::FrequencySegment* temp = freq_seg_;
  freq_seg_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::spectrum::FrequencySegment* RawBody::_internal_mutable_freq_seg() {
  
  if (freq_seg_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::spectrum::FrequencySegment>(GetArena());
    freq_seg_ = p;
  }
  return freq_seg_;
}
inline ::zb::dcts::scenario::spectrum::FrequencySegment* RawBody::mutable_freq_seg() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.RawBody.freq_seg)
  return _internal_mutable_freq_seg();
}
inline void RawBody::set_allocated_freq_seg(::zb::dcts::scenario::spectrum::FrequencySegment* freq_seg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_seg_);
  }
  if (freq_seg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_seg)->GetArena();
    if (message_arena != submessage_arena) {
      freq_seg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, freq_seg, submessage_arena);
    }
    
  } else {
    
  }
  freq_seg_ = freq_seg;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.RawBody.freq_seg)
}

// .zb.dcts.scenario.spectrum.SpectrumLine over_threshold_hits = 2;
inline bool RawBody::_internal_has_over_threshold_hits() const {
  return this != internal_default_instance() && over_threshold_hits_ != nullptr;
}
inline bool RawBody::has_over_threshold_hits() const {
  return _internal_has_over_threshold_hits();
}
inline const ::zb::dcts::scenario::spectrum::SpectrumLine& RawBody::_internal_over_threshold_hits() const {
  const ::zb::dcts::scenario::spectrum::SpectrumLine* p = over_threshold_hits_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::spectrum::SpectrumLine*>(
      &::zb::dcts::scenario::spectrum::_SpectrumLine_default_instance_);
}
inline const ::zb::dcts::scenario::spectrum::SpectrumLine& RawBody::over_threshold_hits() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.RawBody.over_threshold_hits)
  return _internal_over_threshold_hits();
}
inline void RawBody::unsafe_arena_set_allocated_over_threshold_hits(
    ::zb::dcts::scenario::spectrum::SpectrumLine* over_threshold_hits) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(over_threshold_hits_);
  }
  over_threshold_hits_ = over_threshold_hits;
  if (over_threshold_hits) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.RawBody.over_threshold_hits)
}
inline ::zb::dcts::scenario::spectrum::SpectrumLine* RawBody::release_over_threshold_hits() {
  auto temp = unsafe_arena_release_over_threshold_hits();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::spectrum::SpectrumLine* RawBody::unsafe_arena_release_over_threshold_hits() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.RawBody.over_threshold_hits)
  
  ::zb::dcts::scenario::spectrum::SpectrumLine* temp = over_threshold_hits_;
  over_threshold_hits_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::spectrum::SpectrumLine* RawBody::_internal_mutable_over_threshold_hits() {
  
  if (over_threshold_hits_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::spectrum::SpectrumLine>(GetArena());
    over_threshold_hits_ = p;
  }
  return over_threshold_hits_;
}
inline ::zb::dcts::scenario::spectrum::SpectrumLine* RawBody::mutable_over_threshold_hits() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.RawBody.over_threshold_hits)
  return _internal_mutable_over_threshold_hits();
}
inline void RawBody::set_allocated_over_threshold_hits(::zb::dcts::scenario::spectrum::SpectrumLine* over_threshold_hits) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(over_threshold_hits_);
  }
  if (over_threshold_hits) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(over_threshold_hits)->GetArena();
    if (message_arena != submessage_arena) {
      over_threshold_hits = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, over_threshold_hits, submessage_arena);
    }
    
  } else {
    
  }
  over_threshold_hits_ = over_threshold_hits;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.RawBody.over_threshold_hits)
}

// repeated .zb.dcts.scenario.spectrum.SpectrumLine raw_spectrum_lines = 3;
inline int RawBody::_internal_raw_spectrum_lines_size() const {
  return raw_spectrum_lines_.size();
}
inline int RawBody::raw_spectrum_lines_size() const {
  return _internal_raw_spectrum_lines_size();
}
inline ::zb::dcts::scenario::spectrum::SpectrumLine* RawBody::mutable_raw_spectrum_lines(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.RawBody.raw_spectrum_lines)
  return raw_spectrum_lines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::spectrum::SpectrumLine >*
RawBody::mutable_raw_spectrum_lines() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.RawBody.raw_spectrum_lines)
  return &raw_spectrum_lines_;
}
inline const ::zb::dcts::scenario::spectrum::SpectrumLine& RawBody::_internal_raw_spectrum_lines(int index) const {
  return raw_spectrum_lines_.Get(index);
}
inline const ::zb::dcts::scenario::spectrum::SpectrumLine& RawBody::raw_spectrum_lines(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.RawBody.raw_spectrum_lines)
  return _internal_raw_spectrum_lines(index);
}
inline ::zb::dcts::scenario::spectrum::SpectrumLine* RawBody::_internal_add_raw_spectrum_lines() {
  return raw_spectrum_lines_.Add();
}
inline ::zb::dcts::scenario::spectrum::SpectrumLine* RawBody::add_raw_spectrum_lines() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.RawBody.raw_spectrum_lines)
  return _internal_add_raw_spectrum_lines();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::spectrum::SpectrumLine >&
RawBody::raw_spectrum_lines() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.RawBody.raw_spectrum_lines)
  return raw_spectrum_lines_;
}

// -------------------------------------------------------------------

// RawData

// .zb.dcts.scenario.detection.Header header = 1;
inline bool RawData::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RawData::has_header() const {
  return _internal_has_header();
}
inline void RawData::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::Header& RawData::_internal_header() const {
  const ::zb::dcts::scenario::detection::Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::Header*>(
      &::zb::dcts::scenario::detection::_Header_default_instance_);
}
inline const ::zb::dcts::scenario::detection::Header& RawData::header() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.RawData.header)
  return _internal_header();
}
inline void RawData::unsafe_arena_set_allocated_header(
    ::zb::dcts::scenario::detection::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.RawData.header)
}
inline ::zb::dcts::scenario::detection::Header* RawData::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::Header* RawData::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.RawData.header)
  
  ::zb::dcts::scenario::detection::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::Header* RawData::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::zb::dcts::scenario::detection::Header* RawData::mutable_header() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.RawData.header)
  return _internal_mutable_header();
}
inline void RawData::set_allocated_header(::zb::dcts::scenario::detection::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.RawData.header)
}

// .zb.dcts.scenario.detection.RawBody body = 2;
inline bool RawData::_internal_has_body() const {
  return this != internal_default_instance() && body_ != nullptr;
}
inline bool RawData::has_body() const {
  return _internal_has_body();
}
inline void RawData::clear_body() {
  if (GetArena() == nullptr && body_ != nullptr) {
    delete body_;
  }
  body_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::RawBody& RawData::_internal_body() const {
  const ::zb::dcts::scenario::detection::RawBody* p = body_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::RawBody*>(
      &::zb::dcts::scenario::detection::_RawBody_default_instance_);
}
inline const ::zb::dcts::scenario::detection::RawBody& RawData::body() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.RawData.body)
  return _internal_body();
}
inline void RawData::unsafe_arena_set_allocated_body(
    ::zb::dcts::scenario::detection::RawBody* body) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_);
  }
  body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.RawData.body)
}
inline ::zb::dcts::scenario::detection::RawBody* RawData::release_body() {
  auto temp = unsafe_arena_release_body();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::RawBody* RawData::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.RawData.body)
  
  ::zb::dcts::scenario::detection::RawBody* temp = body_;
  body_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::RawBody* RawData::_internal_mutable_body() {
  
  if (body_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::RawBody>(GetArena());
    body_ = p;
  }
  return body_;
}
inline ::zb::dcts::scenario::detection::RawBody* RawData::mutable_body() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.RawData.body)
  return _internal_mutable_body();
}
inline void RawData::set_allocated_body(::zb::dcts::scenario::detection::RawBody* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.RawData.body)
}

// repeated .zb.dcts.IRange signal_segments = 3;
inline int RawData::_internal_signal_segments_size() const {
  return signal_segments_.size();
}
inline int RawData::signal_segments_size() const {
  return _internal_signal_segments_size();
}
inline ::zb::dcts::IRange* RawData::mutable_signal_segments(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.RawData.signal_segments)
  return signal_segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::IRange >*
RawData::mutable_signal_segments() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.RawData.signal_segments)
  return &signal_segments_;
}
inline const ::zb::dcts::IRange& RawData::_internal_signal_segments(int index) const {
  return signal_segments_.Get(index);
}
inline const ::zb::dcts::IRange& RawData::signal_segments(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.RawData.signal_segments)
  return _internal_signal_segments(index);
}
inline ::zb::dcts::IRange* RawData::_internal_add_signal_segments() {
  return signal_segments_.Add();
}
inline ::zb::dcts::IRange* RawData::add_signal_segments() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.RawData.signal_segments)
  return _internal_add_signal_segments();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::IRange >&
RawData::signal_segments() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.RawData.signal_segments)
  return signal_segments_;
}

// -------------------------------------------------------------------

// DeviceDetectResult

// .zb.dcts.scenario.detection.Header header = 1;
inline bool DeviceDetectResult::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DeviceDetectResult::has_header() const {
  return _internal_has_header();
}
inline void DeviceDetectResult::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::Header& DeviceDetectResult::_internal_header() const {
  const ::zb::dcts::scenario::detection::Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::Header*>(
      &::zb::dcts::scenario::detection::_Header_default_instance_);
}
inline const ::zb::dcts::scenario::detection::Header& DeviceDetectResult::header() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.DeviceDetectResult.header)
  return _internal_header();
}
inline void DeviceDetectResult::unsafe_arena_set_allocated_header(
    ::zb::dcts::scenario::detection::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.DeviceDetectResult.header)
}
inline ::zb::dcts::scenario::detection::Header* DeviceDetectResult::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::Header* DeviceDetectResult::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.DeviceDetectResult.header)
  
  ::zb::dcts::scenario::detection::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::Header* DeviceDetectResult::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::zb::dcts::scenario::detection::Header* DeviceDetectResult::mutable_header() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.DeviceDetectResult.header)
  return _internal_mutable_header();
}
inline void DeviceDetectResult::set_allocated_header(::zb::dcts::scenario::detection::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.DeviceDetectResult.header)
}

// .zb.dcts.scenario.detection.FixSignalList fix_signal_list = 3;
inline bool DeviceDetectResult::_internal_has_fix_signal_list() const {
  return this != internal_default_instance() && fix_signal_list_ != nullptr;
}
inline bool DeviceDetectResult::has_fix_signal_list() const {
  return _internal_has_fix_signal_list();
}
inline void DeviceDetectResult::clear_fix_signal_list() {
  if (GetArena() == nullptr && fix_signal_list_ != nullptr) {
    delete fix_signal_list_;
  }
  fix_signal_list_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::FixSignalList& DeviceDetectResult::_internal_fix_signal_list() const {
  const ::zb::dcts::scenario::detection::FixSignalList* p = fix_signal_list_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::FixSignalList*>(
      &::zb::dcts::scenario::detection::_FixSignalList_default_instance_);
}
inline const ::zb::dcts::scenario::detection::FixSignalList& DeviceDetectResult::fix_signal_list() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.DeviceDetectResult.fix_signal_list)
  return _internal_fix_signal_list();
}
inline void DeviceDetectResult::unsafe_arena_set_allocated_fix_signal_list(
    ::zb::dcts::scenario::detection::FixSignalList* fix_signal_list) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fix_signal_list_);
  }
  fix_signal_list_ = fix_signal_list;
  if (fix_signal_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.DeviceDetectResult.fix_signal_list)
}
inline ::zb::dcts::scenario::detection::FixSignalList* DeviceDetectResult::release_fix_signal_list() {
  auto temp = unsafe_arena_release_fix_signal_list();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::FixSignalList* DeviceDetectResult::unsafe_arena_release_fix_signal_list() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.DeviceDetectResult.fix_signal_list)
  
  ::zb::dcts::scenario::detection::FixSignalList* temp = fix_signal_list_;
  fix_signal_list_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::FixSignalList* DeviceDetectResult::_internal_mutable_fix_signal_list() {
  
  if (fix_signal_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::FixSignalList>(GetArena());
    fix_signal_list_ = p;
  }
  return fix_signal_list_;
}
inline ::zb::dcts::scenario::detection::FixSignalList* DeviceDetectResult::mutable_fix_signal_list() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.DeviceDetectResult.fix_signal_list)
  return _internal_mutable_fix_signal_list();
}
inline void DeviceDetectResult::set_allocated_fix_signal_list(::zb::dcts::scenario::detection::FixSignalList* fix_signal_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fix_signal_list_;
  }
  if (fix_signal_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fix_signal_list);
    if (message_arena != submessage_arena) {
      fix_signal_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fix_signal_list, submessage_arena);
    }
    
  } else {
    
  }
  fix_signal_list_ = fix_signal_list;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.DeviceDetectResult.fix_signal_list)
}

// .zb.dcts.scenario.detection.HopSignalList hop_signal_list = 4;
inline bool DeviceDetectResult::_internal_has_hop_signal_list() const {
  return this != internal_default_instance() && hop_signal_list_ != nullptr;
}
inline bool DeviceDetectResult::has_hop_signal_list() const {
  return _internal_has_hop_signal_list();
}
inline void DeviceDetectResult::clear_hop_signal_list() {
  if (GetArena() == nullptr && hop_signal_list_ != nullptr) {
    delete hop_signal_list_;
  }
  hop_signal_list_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::HopSignalList& DeviceDetectResult::_internal_hop_signal_list() const {
  const ::zb::dcts::scenario::detection::HopSignalList* p = hop_signal_list_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::HopSignalList*>(
      &::zb::dcts::scenario::detection::_HopSignalList_default_instance_);
}
inline const ::zb::dcts::scenario::detection::HopSignalList& DeviceDetectResult::hop_signal_list() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.DeviceDetectResult.hop_signal_list)
  return _internal_hop_signal_list();
}
inline void DeviceDetectResult::unsafe_arena_set_allocated_hop_signal_list(
    ::zb::dcts::scenario::detection::HopSignalList* hop_signal_list) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hop_signal_list_);
  }
  hop_signal_list_ = hop_signal_list;
  if (hop_signal_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.DeviceDetectResult.hop_signal_list)
}
inline ::zb::dcts::scenario::detection::HopSignalList* DeviceDetectResult::release_hop_signal_list() {
  auto temp = unsafe_arena_release_hop_signal_list();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::HopSignalList* DeviceDetectResult::unsafe_arena_release_hop_signal_list() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.DeviceDetectResult.hop_signal_list)
  
  ::zb::dcts::scenario::detection::HopSignalList* temp = hop_signal_list_;
  hop_signal_list_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::HopSignalList* DeviceDetectResult::_internal_mutable_hop_signal_list() {
  
  if (hop_signal_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::HopSignalList>(GetArena());
    hop_signal_list_ = p;
  }
  return hop_signal_list_;
}
inline ::zb::dcts::scenario::detection::HopSignalList* DeviceDetectResult::mutable_hop_signal_list() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.DeviceDetectResult.hop_signal_list)
  return _internal_mutable_hop_signal_list();
}
inline void DeviceDetectResult::set_allocated_hop_signal_list(::zb::dcts::scenario::detection::HopSignalList* hop_signal_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hop_signal_list_;
  }
  if (hop_signal_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hop_signal_list);
    if (message_arena != submessage_arena) {
      hop_signal_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hop_signal_list, submessage_arena);
    }
    
  } else {
    
  }
  hop_signal_list_ = hop_signal_list;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.DeviceDetectResult.hop_signal_list)
}

// .zb.dcts.scenario.detection.SignalSampleList signal_sample_list = 5;
inline bool DeviceDetectResult::_internal_has_signal_sample_list() const {
  return this != internal_default_instance() && signal_sample_list_ != nullptr;
}
inline bool DeviceDetectResult::has_signal_sample_list() const {
  return _internal_has_signal_sample_list();
}
inline void DeviceDetectResult::clear_signal_sample_list() {
  if (GetArena() == nullptr && signal_sample_list_ != nullptr) {
    delete signal_sample_list_;
  }
  signal_sample_list_ = nullptr;
}
inline const ::zb::dcts::scenario::detection::SignalSampleList& DeviceDetectResult::_internal_signal_sample_list() const {
  const ::zb::dcts::scenario::detection::SignalSampleList* p = signal_sample_list_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::scenario::detection::SignalSampleList*>(
      &::zb::dcts::scenario::detection::_SignalSampleList_default_instance_);
}
inline const ::zb::dcts::scenario::detection::SignalSampleList& DeviceDetectResult::signal_sample_list() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.DeviceDetectResult.signal_sample_list)
  return _internal_signal_sample_list();
}
inline void DeviceDetectResult::unsafe_arena_set_allocated_signal_sample_list(
    ::zb::dcts::scenario::detection::SignalSampleList* signal_sample_list) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_sample_list_);
  }
  signal_sample_list_ = signal_sample_list;
  if (signal_sample_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.DeviceDetectResult.signal_sample_list)
}
inline ::zb::dcts::scenario::detection::SignalSampleList* DeviceDetectResult::release_signal_sample_list() {
  auto temp = unsafe_arena_release_signal_sample_list();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::scenario::detection::SignalSampleList* DeviceDetectResult::unsafe_arena_release_signal_sample_list() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.DeviceDetectResult.signal_sample_list)
  
  ::zb::dcts::scenario::detection::SignalSampleList* temp = signal_sample_list_;
  signal_sample_list_ = nullptr;
  return temp;
}
inline ::zb::dcts::scenario::detection::SignalSampleList* DeviceDetectResult::_internal_mutable_signal_sample_list() {
  
  if (signal_sample_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::scenario::detection::SignalSampleList>(GetArena());
    signal_sample_list_ = p;
  }
  return signal_sample_list_;
}
inline ::zb::dcts::scenario::detection::SignalSampleList* DeviceDetectResult::mutable_signal_sample_list() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.DeviceDetectResult.signal_sample_list)
  return _internal_mutable_signal_sample_list();
}
inline void DeviceDetectResult::set_allocated_signal_sample_list(::zb::dcts::scenario::detection::SignalSampleList* signal_sample_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete signal_sample_list_;
  }
  if (signal_sample_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(signal_sample_list);
    if (message_arena != submessage_arena) {
      signal_sample_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_sample_list, submessage_arena);
    }
    
  } else {
    
  }
  signal_sample_list_ = signal_sample_list;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.DeviceDetectResult.signal_sample_list)
}

// -------------------------------------------------------------------

// SignalLayerSurvey

// .zb.dcts.source.SourceId result_from = 1;
inline bool SignalLayerSurvey::_internal_has_result_from() const {
  return this != internal_default_instance() && result_from_ != nullptr;
}
inline bool SignalLayerSurvey::has_result_from() const {
  return _internal_has_result_from();
}
inline const ::zb::dcts::source::SourceId& SignalLayerSurvey::_internal_result_from() const {
  const ::zb::dcts::source::SourceId* p = result_from_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::source::SourceId*>(
      &::zb::dcts::source::_SourceId_default_instance_);
}
inline const ::zb::dcts::source::SourceId& SignalLayerSurvey::result_from() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalLayerSurvey.result_from)
  return _internal_result_from();
}
inline void SignalLayerSurvey::unsafe_arena_set_allocated_result_from(
    ::zb::dcts::source::SourceId* result_from) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_from_);
  }
  result_from_ = result_from;
  if (result_from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalLayerSurvey.result_from)
}
inline ::zb::dcts::source::SourceId* SignalLayerSurvey::release_result_from() {
  auto temp = unsafe_arena_release_result_from();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::source::SourceId* SignalLayerSurvey::unsafe_arena_release_result_from() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalLayerSurvey.result_from)
  
  ::zb::dcts::source::SourceId* temp = result_from_;
  result_from_ = nullptr;
  return temp;
}
inline ::zb::dcts::source::SourceId* SignalLayerSurvey::_internal_mutable_result_from() {
  
  if (result_from_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::source::SourceId>(GetArena());
    result_from_ = p;
  }
  return result_from_;
}
inline ::zb::dcts::source::SourceId* SignalLayerSurvey::mutable_result_from() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalLayerSurvey.result_from)
  return _internal_mutable_result_from();
}
inline void SignalLayerSurvey::set_allocated_result_from(::zb::dcts::source::SourceId* result_from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_from_);
  }
  if (result_from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_from)->GetArena();
    if (message_arena != submessage_arena) {
      result_from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_from, submessage_arena);
    }
    
  } else {
    
  }
  result_from_ = result_from;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalLayerSurvey.result_from)
}

// .zb.dcts.Timestamp time_stamp = 2;
inline bool SignalLayerSurvey::_internal_has_time_stamp() const {
  return this != internal_default_instance() && time_stamp_ != nullptr;
}
inline bool SignalLayerSurvey::has_time_stamp() const {
  return _internal_has_time_stamp();
}
inline const ::zb::dcts::Timestamp& SignalLayerSurvey::_internal_time_stamp() const {
  const ::zb::dcts::Timestamp* p = time_stamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Timestamp*>(
      &::zb::dcts::_Timestamp_default_instance_);
}
inline const ::zb::dcts::Timestamp& SignalLayerSurvey::time_stamp() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalLayerSurvey.time_stamp)
  return _internal_time_stamp();
}
inline void SignalLayerSurvey::unsafe_arena_set_allocated_time_stamp(
    ::zb::dcts::Timestamp* time_stamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_stamp_);
  }
  time_stamp_ = time_stamp;
  if (time_stamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalLayerSurvey.time_stamp)
}
inline ::zb::dcts::Timestamp* SignalLayerSurvey::release_time_stamp() {
  auto temp = unsafe_arena_release_time_stamp();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Timestamp* SignalLayerSurvey::unsafe_arena_release_time_stamp() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalLayerSurvey.time_stamp)
  
  ::zb::dcts::Timestamp* temp = time_stamp_;
  time_stamp_ = nullptr;
  return temp;
}
inline ::zb::dcts::Timestamp* SignalLayerSurvey::_internal_mutable_time_stamp() {
  
  if (time_stamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Timestamp>(GetArena());
    time_stamp_ = p;
  }
  return time_stamp_;
}
inline ::zb::dcts::Timestamp* SignalLayerSurvey::mutable_time_stamp() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalLayerSurvey.time_stamp)
  return _internal_mutable_time_stamp();
}
inline void SignalLayerSurvey::set_allocated_time_stamp(::zb::dcts::Timestamp* time_stamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_stamp_);
  }
  if (time_stamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_stamp)->GetArena();
    if (message_arena != submessage_arena) {
      time_stamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_stamp, submessage_arena);
    }
    
  } else {
    
  }
  time_stamp_ = time_stamp;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalLayerSurvey.time_stamp)
}

// .zb.dcts.Position position = 3;
inline bool SignalLayerSurvey::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool SignalLayerSurvey::has_position() const {
  return _internal_has_position();
}
inline const ::zb::dcts::Position& SignalLayerSurvey::_internal_position() const {
  const ::zb::dcts::Position* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::zb::dcts::Position*>(
      &::zb::dcts::_Position_default_instance_);
}
inline const ::zb::dcts::Position& SignalLayerSurvey::position() const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalLayerSurvey.position)
  return _internal_position();
}
inline void SignalLayerSurvey::unsafe_arena_set_allocated_position(
    ::zb::dcts::Position* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.scenario.detection.SignalLayerSurvey.position)
}
inline ::zb::dcts::Position* SignalLayerSurvey::release_position() {
  auto temp = unsafe_arena_release_position();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Position* SignalLayerSurvey::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:zb.dcts.scenario.detection.SignalLayerSurvey.position)
  
  ::zb::dcts::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::zb::dcts::Position* SignalLayerSurvey::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Position>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::zb::dcts::Position* SignalLayerSurvey::mutable_position() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalLayerSurvey.position)
  return _internal_mutable_position();
}
inline void SignalLayerSurvey::set_allocated_position(::zb::dcts::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position)->GetArena();
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.scenario.detection.SignalLayerSurvey.position)
}

// repeated .zb.dcts.scenario.detection.SignalDigest fix_signal_list = 4;
inline int SignalLayerSurvey::_internal_fix_signal_list_size() const {
  return fix_signal_list_.size();
}
inline int SignalLayerSurvey::fix_signal_list_size() const {
  return _internal_fix_signal_list_size();
}
inline void SignalLayerSurvey::clear_fix_signal_list() {
  fix_signal_list_.Clear();
}
inline ::zb::dcts::scenario::detection::SignalDigest* SignalLayerSurvey::mutable_fix_signal_list(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalLayerSurvey.fix_signal_list)
  return fix_signal_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalDigest >*
SignalLayerSurvey::mutable_fix_signal_list() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.SignalLayerSurvey.fix_signal_list)
  return &fix_signal_list_;
}
inline const ::zb::dcts::scenario::detection::SignalDigest& SignalLayerSurvey::_internal_fix_signal_list(int index) const {
  return fix_signal_list_.Get(index);
}
inline const ::zb::dcts::scenario::detection::SignalDigest& SignalLayerSurvey::fix_signal_list(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalLayerSurvey.fix_signal_list)
  return _internal_fix_signal_list(index);
}
inline ::zb::dcts::scenario::detection::SignalDigest* SignalLayerSurvey::_internal_add_fix_signal_list() {
  return fix_signal_list_.Add();
}
inline ::zb::dcts::scenario::detection::SignalDigest* SignalLayerSurvey::add_fix_signal_list() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.SignalLayerSurvey.fix_signal_list)
  return _internal_add_fix_signal_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::SignalDigest >&
SignalLayerSurvey::fix_signal_list() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.SignalLayerSurvey.fix_signal_list)
  return fix_signal_list_;
}

// repeated .zb.dcts.scenario.detection.HopSignalCluster hop_signal_list = 5;
inline int SignalLayerSurvey::_internal_hop_signal_list_size() const {
  return hop_signal_list_.size();
}
inline int SignalLayerSurvey::hop_signal_list_size() const {
  return _internal_hop_signal_list_size();
}
inline void SignalLayerSurvey::clear_hop_signal_list() {
  hop_signal_list_.Clear();
}
inline ::zb::dcts::scenario::detection::HopSignalCluster* SignalLayerSurvey::mutable_hop_signal_list(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.scenario.detection.SignalLayerSurvey.hop_signal_list)
  return hop_signal_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >*
SignalLayerSurvey::mutable_hop_signal_list() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.scenario.detection.SignalLayerSurvey.hop_signal_list)
  return &hop_signal_list_;
}
inline const ::zb::dcts::scenario::detection::HopSignalCluster& SignalLayerSurvey::_internal_hop_signal_list(int index) const {
  return hop_signal_list_.Get(index);
}
inline const ::zb::dcts::scenario::detection::HopSignalCluster& SignalLayerSurvey::hop_signal_list(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.scenario.detection.SignalLayerSurvey.hop_signal_list)
  return _internal_hop_signal_list(index);
}
inline ::zb::dcts::scenario::detection::HopSignalCluster* SignalLayerSurvey::_internal_add_hop_signal_list() {
  return hop_signal_list_.Add();
}
inline ::zb::dcts::scenario::detection::HopSignalCluster* SignalLayerSurvey::add_hop_signal_list() {
  // @@protoc_insertion_point(field_add:zb.dcts.scenario.detection.SignalLayerSurvey.hop_signal_list)
  return _internal_add_hop_signal_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::scenario::detection::HopSignalCluster >&
SignalLayerSurvey::hop_signal_list() const {
  // @@protoc_insertion_point(field_list:zb.dcts.scenario.detection.SignalLayerSurvey.hop_signal_list)
  return hop_signal_list_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace detection
}  // namespace scenario
}  // namespace dcts
}  // namespace zb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode>() {
  return ::zb::dcts::scenario::detection::AdaptiveThresholdParam_PartitionMode_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType>() {
  return ::zb::dcts::scenario::detection::EnergyDetectionParam_LogicType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::scenario::detection::ThresholdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::scenario::detection::ThresholdType>() {
  return ::zb::dcts::scenario::detection::ThresholdType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::scenario::detection::SignalActivity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::scenario::detection::SignalActivity>() {
  return ::zb::dcts::scenario::detection::SignalActivity_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scenario_2fdetection_2eproto
